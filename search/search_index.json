{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ticktick-py \u00b6 Unofficial TickTick API Client for Python 3 \u00b6 Designed for TickTick.com API v2 Description \u00b6 ticktick-py is an unofficial API library for interacting with TickTick.com . It allows users a way to interact with their TickTick account using Python . Currently, as of 1/14/2021 , there is no official API for TickTick . Features \u00b6 The API automatically fetches all the tasks, tags, lists, and more linked to your profile and stores them in a dictionary named state . Tasks Batch create, update, and delete tasks Acquire all your uncompleted tasks Move tasks easily between projects Acquire all completed tasks in a certain date range Tags Batch create, update, and delete tags Create tags with parameters that are not usually allowed: \\\\ / \" # : * ? < > | Space Projects Batch create, update, and delete 'lists' (projects) Batch archive projects Quick Guide \u00b6 Initializing Your Session \u00b6 from ticktick import api client = api . TickTickClient ( 'username' , 'password' ) # Enter correct username and password Once you have initialized your session, all interactions will occur through the reference, in this case: client Example: Creating A Task \u00b6 Lets create a task in our inbox titled \"Get Groceries\", with the date as 5/6/2021 at 2:30PM: from datetime import datetime # Dates are supported through the datetime module name = 'Get Groceries' date = datetime ( 2021 , 5 , 6 , 14 , 30 ) groceries = client . task . create ( name , start = date ) # Create the task with the parameters. Result \u00b6 A dictionary for the newly created task is returned. print ( groceries ) { 'id' : '5ff24e4b8f08904035b304d9' , 'projectId' : 'inbox416323287' , 'sortOrder' : - 1099511627776 , 'title' : 'Get Groceries' , 'content' : '' , 'startDate' : '2021-05-06T21:30:00.000+0000' , 'dueDate' : '2021-05-06T21:30:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : False , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-03T23:07:55.004+0000' , 'etag' : 'ol2zesef' , 'deleted' : 0 , 'createdTime' : '2021-01-03T23:07:55.011+0000' , 'creator' : 359368200 , 'kind' : 'TEXT' } Created Task In TickTick Most methods will return the object that was changed. Consult the usage documentation for more information on specific methods. Installation \u00b6 Note: ticktick-py requires Python 3.6 or above. pip install ticktick-py Future Plans \u00b6 General Enhanced Team Support Tasks Notification and Repeats For Tasks Get and Restore From Trash Projects Smart List Support Column Creation For Kanban View Pomo and Focus Getting the focus / pomo statistics for your profile Starting and stopping the focus / pomo timer Habits Get, create, archive, delete, and complete habits","title":"Overview"},{"location":"#ticktick-py","text":"","title":"ticktick-py"},{"location":"#unofficial-ticktick-api-client-for-python-3","text":"Designed for TickTick.com API v2","title":"Unofficial TickTick API Client for Python 3"},{"location":"#description","text":"ticktick-py is an unofficial API library for interacting with TickTick.com . It allows users a way to interact with their TickTick account using Python . Currently, as of 1/14/2021 , there is no official API for TickTick .","title":"Description"},{"location":"#features","text":"The API automatically fetches all the tasks, tags, lists, and more linked to your profile and stores them in a dictionary named state . Tasks Batch create, update, and delete tasks Acquire all your uncompleted tasks Move tasks easily between projects Acquire all completed tasks in a certain date range Tags Batch create, update, and delete tags Create tags with parameters that are not usually allowed: \\\\ / \" # : * ? < > | Space Projects Batch create, update, and delete 'lists' (projects) Batch archive projects","title":"Features"},{"location":"#quick-guide","text":"","title":"Quick Guide"},{"location":"#initializing-your-session","text":"from ticktick import api client = api . TickTickClient ( 'username' , 'password' ) # Enter correct username and password Once you have initialized your session, all interactions will occur through the reference, in this case: client","title":"Initializing Your Session"},{"location":"#example-creating-a-task","text":"Lets create a task in our inbox titled \"Get Groceries\", with the date as 5/6/2021 at 2:30PM: from datetime import datetime # Dates are supported through the datetime module name = 'Get Groceries' date = datetime ( 2021 , 5 , 6 , 14 , 30 ) groceries = client . task . create ( name , start = date ) # Create the task with the parameters.","title":"Example: Creating A Task"},{"location":"#result","text":"A dictionary for the newly created task is returned. print ( groceries ) { 'id' : '5ff24e4b8f08904035b304d9' , 'projectId' : 'inbox416323287' , 'sortOrder' : - 1099511627776 , 'title' : 'Get Groceries' , 'content' : '' , 'startDate' : '2021-05-06T21:30:00.000+0000' , 'dueDate' : '2021-05-06T21:30:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : False , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-03T23:07:55.004+0000' , 'etag' : 'ol2zesef' , 'deleted' : 0 , 'createdTime' : '2021-01-03T23:07:55.011+0000' , 'creator' : 359368200 , 'kind' : 'TEXT' } Created Task In TickTick Most methods will return the object that was changed. Consult the usage documentation for more information on specific methods.","title":"Result"},{"location":"#installation","text":"Note: ticktick-py requires Python 3.6 or above. pip install ticktick-py","title":"Installation"},{"location":"#future-plans","text":"General Enhanced Team Support Tasks Notification and Repeats For Tasks Get and Restore From Trash Projects Smart List Support Column Creation For Kanban View Pomo and Focus Getting the focus / pomo statistics for your profile Starting and stopping the focus / pomo timer Habits Get, create, archive, delete, and complete habits","title":"Future Plans"},{"location":"changelog/","text":"1.0.0 - 1/18/21 - Initial Release","title":"Changelog"},{"location":"license/","text":"MIT License Copyright (c) 2021 Michael Lazeroff Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"usage/api/","text":"The TickTickClient class is the origin for interactions with the API. It is important to understand how the local data for your profile is stored and the names that you will interact with in order to access the different features. Logging In \u00b6 Info A successful login is required. Initializing Your Session from ticktick import api client = api . TickTickClient ( 'username' , 'password' ) # Enter correct username and password Once you have initialized your session, all interactions will occur through the instance, in this case: client State \u00b6 The state public member is a dictionary that contains objects linked to your TickTick profile. The dictionary is automatically updated and synced when changes are made through the API. state Members The lists are comprised of dictionaries that contain all the fields for each type of TickTick object: tasks, tags, etc. Member Type Contains tasks list All uncompleted task objects tags list All tag objects projects list All project objects project_folders list All project folder objects Accessing Members can be accessed by normal dictionary indexing using the member strings. # Assumes that 'client' is the name that references the TickTickClient class. uncompleted_tasks = client . state [ 'tasks' ] all_tags = client . state [ 'tags' ] Example Task Object { 'id' : '5ff24e4b8f08904035b304d9' , 'projectId' : 'inbox416323287' , 'sortOrder' : - 1099511627776 , 'title' : 'Get Groceries' , 'content' : '' , 'startDate' : '2021-05-06T21:30:00.000+0000' , 'dueDate' : '2021-05-06T21:30:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : False , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-03T23:07:55.004+0000' , 'etag' : 'ol2zesef' , 'deleted' : 0 , 'createdTime' : '2021-01-03T23:07:55.011+0000' , 'creator' : 359368200 , 'kind' : 'TEXT' } Functionality \u00b6 Different functionality can be accessed through different public members of the TickTickClient instance: Functionality Method Managers Accessing the methods for each type of member is easy. It is in this format: client (or whatever name references the TickTickClient instance). manager (members in table below). method() Member Functionality task Task Methods tag Tag Methods project List Methods Example Usage # Assumes that 'client' is the name that references the TickTickClient instance. created_task = client . task . create ( 'My Created Task' ) deleted_project = client . project . delete ( project_id ) Make sure to check the individual documentation for the different method managers. Other Public Members Useful Members Member Type Description profile_id str ID assigned to your profile inbox_id str Inbox ID assigned to your profile time_zone str Timezone string linked to your TickTick profile state dict Holds all the item objects in your profile (described above) Members That Shouldn't Be Messed With Messing with these values could produce unwanted effects. Member Type Description access_token str Instance token generated by TickTick for your session. cookies dict Cookies required for your session. Useful Methods \u00b6 TickTickClient has a lot of helper functions in its documentation...however these should be the only of use methods to you: Tip It's recommended that you look at the documentation for these three methods to see how to obtain / delete objects from the local state dictionary - an important feature that will be useful when updating / deleting TickTick objects remotely. delete_from_local_state get_by_fields get_by_id get_by_etag That's It! \u00b6 That's all the required information for how to get started with the API! To see how to use individual features, check these out next: Tasks Projects Tags ## `TickTickClient Documentation` TickTickClient \u00b6 __init__ ( self , username , password ) special \u00b6 Initializes a client session. In order to interact with the API a successful login must occur. See Logging In for help. Parameters: Name Type Description Default username str TickTick Username required password str TickTick Password required Exceptions: Type Description RunTimeError If the login was not successful. Source code in ticktick/api.py def __init__ ( self , username : str , password : str ) -> None : \"\"\" Initializes a client session. In order to interact with the API a successful login must occur. See [Logging In](api.md#logging-in) for help. Arguments: username: TickTick Username password: TickTick Password Raises: RunTimeError: If the login was not successful. \"\"\" # Class members self . access_token = '' self . cookies = {} self . session = httpx . Client () self . time_zone = '' self . profile_id = '' self . inbox_id = '' self . state = {} self . reset_local_state () self . _login ( username , password ) self . _settings () self . sync () # Mangers for the different operations self . focus = FocusTimeManager ( self ) self . habit = HabitManager ( self ) self . project = ProjectManager ( self ) self . pomo = PomoManager ( self ) self . settings = SettingsManager ( self ) self . tag = TagsManager ( self ) self . task = TaskManager ( self ) check_status_code ( response , error_message ) staticmethod \u00b6 Verifies the http response was status code 200. Parameters: Name Type Description Default response httpx Httpx response required error_message str Error message to be included with the exception required Exceptions: Type Description RuntimeError If the status code of the response was not 200. Source code in ticktick/api.py @staticmethod def check_status_code ( response , error_message : str ) -> None : \"\"\" Verifies the http response was status code 200. Arguments: response (httpx): Httpx response error_message: Error message to be included with the exception Raises: RuntimeError: If the status code of the response was not 200. \"\"\" if response . status_code != 200 : raise RuntimeError ( error_message ) delete_from_local_state ( self , search = None , ** kwargs ) \u00b6 Deletes a single object from the local state dictionary. Does not delete any items remotely. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, lists, and tags are just dictionaries of fields, we can find an object by comparing the fields. For example: Lets say that we wanted to find and delete an existing task object from our local state with the name 'Get Groceries'. To do this, we can specify the field(s) that we want to compare for in the task objects -> in this case the title 'Get Groceries'. The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client . delete_from_local_state ( title = 'Get Groceries' ) deleted_task would now hold the object that was deleted from the state dictionary if it was found. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client . delete_from_local_state ( title = 'Get Groceries' , search = 'tasks' ) The search will now only look through tasks in state . Parameters: Name Type Description Default search str A specific item to look through in the state dictionary. When not specified the entire state dictionary will be searched. None **kwargs Matching fields in the object to look for. {} Returns: Type Description dict The dictionary of the object that was deleted. Exceptions: Type Description ValueError If no key word arguments are provided. KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def delete_from_local_state ( self , search : str = None , ** kwargs ) -> dict : \"\"\" Deletes a single object from the local `state` dictionary. **Does not delete any items remotely.** If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, lists, and tags are just dictionaries of fields, we can find an object by comparing the fields. For example: Lets say that we wanted to find and delete an existing task object from our local state with the name 'Get Groceries'. To do this, we can specify the field(s) that we want to compare for in the task objects -> in this case the `title` 'Get Groceries'. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client.delete_from_local_state(title='Get Groceries') ``` `deleted_task` would now hold the object that was deleted from the [`state`](api.md#state) dictionary if it was found. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client.delete_from_local_state(title='Get Groceries', search='tasks') ``` The search will now only look through `tasks` in `state`. Arguments: search: A specific item to look through in the [`state`](api.md#state) dictionary. When not specified the entire [`state`](api.md#state) dictionary will be searched. **kwargs: Matching fields in the object to look for. Returns: The dictionary of the object that was deleted. Raises: ValueError: If no key word arguments are provided. KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" # Check that kwargs is not empty if kwargs == {}: raise ValueError ( 'Must Include Field(s) To Be Searched For' ) if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : # Go through the state dictionary list and delete the object that matches the fields for item in range ( len ( self . state [ search ])): all_match = True for field in kwargs : if kwargs [ field ] != self . state [ search ][ item ][ field ]: all_match = False break if all_match : deleted = self . state [ search ][ item ] # Delete the item del self . state [ search ][ item ] return deleted else : # No key passed, search entire self.state dictionary # Search the first level of the state dictionary for primary_key in self . state : skip_primary_key = False all_match = True middle_key = 0 # Search the individual lists of the dictionary for middle_key in range ( len ( self . state [ primary_key ])): if skip_primary_key : break # Match the fields in the kwargs dictionary to the specific object -> if all match add index for fields in kwargs : # if the field doesn't exist, we can assume every other item in the list doesn't have the # field either -> so skip this primary_key entirely if fields not in self . state [ primary_key ][ middle_key ]: all_match = False skip_primary_key = True break if kwargs [ fields ] == self . state [ primary_key ][ middle_key ][ fields ]: all_match = True else : all_match = False if all_match : deleted = self . state [ primary_key ][ middle_key ] del self . state [ primary_key ][ middle_key ] return deleted get_by_etag ( self , etag , search = None ) \u00b6 Returns the dictionary object of the item with the matching etag. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the etag fields. For example: Lets get the object that corresponds to an etag referenced by my_etag . The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_etag ( my_etag ) found_obj would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_etag ( my_etag , search = 'projects' ) The search will now only look through projects in state . Parameters: Name Type Description Default etag str The etag of the object that you are looking for. required search str Key in state that the search should take place in. If empty the entire state dictionary will be searched. None Returns: Type Description dict The dictionary object of the item if found, or an empty dictionary if not found. Exceptions: Type Description KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_etag ( self , etag : str , search : str = None ) -> dict : \"\"\" Returns the dictionary object of the item with the matching etag. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the etag fields. For example: Lets get the object that corresponds to an etag referenced by `my_etag`. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_etag(my_etag) ``` `found_obj` would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_etag(my_etag, search='projects') ``` The search will now only look through `projects` in [`state`](api.md#state). Arguments: etag: The etag of the object that you are looking for. search: Key in [`state`](#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. Returns: The dictionary object of the item if found, or an empty dictionary if not found. Raises: KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : for index in self . state [ search ]: if index [ 'etag' ] == etag : return index else : # Search all items in self.state for prim_key in self . state : for our_object in self . state [ prim_key ]: if 'etag' not in our_object : break if our_object [ 'etag' ] == etag : return our_object # Return empty dictionary if not found return {} get_by_fields ( self , search = None , ** kwargs ) \u00b6 Finds and returns the objects in state that match the inputted fields. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing any fields contained in those objects. For example: Lets say we have 3 task objects that are titled 'Hello', and we want to obtain all of them. The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_objs = client . get_by_fields ( title = 'Hello' ) found_objs would now reference a list containing the 3 objects with titles 'Hello'. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_fields ( title = 'Hello' , search = 'tasks' ) The search will now only look through tasks in state . Parameters: Name Type Description Default search str Key in state that the search should take place in. If empty the entire state dictionary will be searched. None **kwargs Matching fields in the object to look for. {} Returns: Type Description dict or list Single Object (dict) : The dictionary of the object. Multiple Objects (list) : A list of dictionary objects. Nothing Found (list) : Empty List Exceptions: Type Description ValueError If no key word arguments are provided. KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_fields ( self , search : str = None , ** kwargs ): \"\"\" Finds and returns the objects in `state` that match the inputted fields. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing any fields contained in those objects. For example: Lets say we have 3 task objects that are titled 'Hello', and we want to obtain all of them. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_objs = client.get_by_fields(title='Hello') ``` `found_objs` would now reference a list containing the 3 objects with titles 'Hello'. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_fields(title='Hello', search='tasks') ``` The search will now only look through `tasks` in [`state`](api.md#state). Arguments: search: Key in [`state`](api.md#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. **kwargs: Matching fields in the object to look for. Returns: dict or list: **Single Object (dict)**: The dictionary of the object. **Multiple Objects (list)**: A list of dictionary objects. **Nothing Found (list)**: Empty List Raises: ValueError: If no key word arguments are provided. KeyError: If the search key provided is not a key in `state`. \"\"\" if kwargs == {}: raise ValueError ( 'Must Include Field(s) To Be Searched For' ) if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) objects = [] if search is not None : # If a specific key was passed for self.state # Go through self.state[key_name] and see if all the fields in kwargs match # If all don't match return empty list for index in self . state [ search ]: all_match = True for field in kwargs : if kwargs [ field ] != index [ field ]: all_match = False break if all_match : objects . append ( index ) else : # No key passed, search entire self.state dictionary # Search the first level of the state dictionary for primarykey in self . state : skip_primary_key = False all_match = True middle_key = 0 # Search the individual lists of the dictionary for middle_key in range ( len ( self . state [ primarykey ])): if skip_primary_key : break # Match the fields in the kwargs dictionary to the specific object -> if all match add index for fields in kwargs : # if the field doesn't exist, we can assume every other item in the list doesn't have the # field either -> so skip this primary_key entirely if fields not in self . state [ primarykey ][ middle_key ]: all_match = False skip_primary_key = True break if kwargs [ fields ] == self . state [ primarykey ][ middle_key ][ fields ]: all_match = True else : all_match = False if all_match : objects . append ( self . state [ primarykey ][ middle_key ]) if len ( objects ) == 1 : return objects [ 0 ] else : return objects get_by_id ( self , obj_id , search = None ) \u00b6 Returns the dictionary of the object corresponding to the passed id. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the id fields. For example: Lets get the object that corresponds to an id referenced by my_id . The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_id ( my_id ) found_obj would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_id ( my_id , search = 'projects' ) The search will now only look through projects in state . Parameters: Name Type Description Default obj_id str Id of the item. required search str Key in state that the search should take place in. If empty the entire state dictionary will be searched. None Returns: Type Description dict The dictionary object of the item if found, or an empty dictionary if not found. Exceptions: Type Description KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_id ( self , obj_id : str , search : str = None ) -> dict : \"\"\" Returns the dictionary of the object corresponding to the passed id. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the id fields. For example: Lets get the object that corresponds to an id referenced by `my_id`. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_id(my_id) ``` `found_obj` would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_id(my_id, search='projects') ``` The search will now only look through `projects` in [`state`](api.md#state). Arguments: obj_id: Id of the item. search: Key in [`state`](api.md#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. Returns: The dictionary object of the item if found, or an empty dictionary if not found. Raises: KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : for index in self . state [ search ]: if index [ 'id' ] == obj_id : return index else : # Search all items in self.state for prim_key in self . state : for our_object in self . state [ prim_key ]: if 'id' not in our_object : break if our_object [ 'id' ] == obj_id : return our_object # Return empty dictionary if not found return {} http_delete ( self , url , ** kwargs ) \u00b6 Sends an http delete request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_delete ( self , url , ** kwargs ): \"\"\" Sends an http delete request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . session . delete ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text http_get ( self , url , ** kwargs ) \u00b6 Sends an http get request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_get ( self , url , ** kwargs ): \"\"\" Sends an http get request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . session . get ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text http_post ( self , url , ** kwargs ) \u00b6 Sends an http post request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_post ( self , url , ** kwargs ): \"\"\" Sends an http post request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . session . post ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text http_put ( self , url , ** kwargs ) \u00b6 Sends an http put request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_put ( self , url , ** kwargs ): \"\"\" Sends an http put request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . session . put ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text parse_etag ( response , multiple = False ) staticmethod \u00b6 Parses the etag of a successful creation of a tag object. Info The response from TickTick upon a successful tag creation is in this form: {\"id2etag\":{\"MyTag\":\"vxzpwo38\"},\"id2error\":{}} We want to obtain \"vxzpwo38\" in this example - the etag of the object. Parameters: Name Type Description Default response dict Dictionary from the successful creation of a tag object required multiple bool Specifies whether there are multiple etags to return. False Returns: Type Description str A single etag string if not multiple, or a list of etag strings if multiple. Source code in ticktick/api.py @staticmethod def parse_etag ( response : dict , multiple : bool = False ) -> str : \"\"\" Parses the etag of a successful creation of a tag object. !!! info The response from TickTick upon a successful tag creation is in this form: ```md {\"id2etag\":{\"MyTag\":\"vxzpwo38\"},\"id2error\":{}} ``` We want to obtain \"vxzpwo38\" in this example - the etag of the object. Arguments: response: Dictionary from the successful creation of a tag object multiple: Specifies whether there are multiple etags to return. Return: A single etag string if not multiple, or a list of etag strings if multiple. \"\"\" etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) if not multiple : return etag [ etag2 [ 0 ]] else : etags = [] for key in range ( len ( etag2 )): etags . append ( etag [ etag2 [ key ]]) return etags parse_id ( response ) staticmethod \u00b6 Parses the Id of a successful creation of a TickTick object. Info The response from the TickTick servers is in this form: {'id2etag': {'5ff2bcf68f08093e5b745a30': '3okkc2xm'}, 'id2error': {}} We want to obtain '5ff2bcf68f08093e5b745a30' in this example - the id of the object. Parameters: Name Type Description Default response dict Dictionary containing the Dd from the TickTick servers. required Returns: Type Description str Id string of the object. Source code in ticktick/api.py @staticmethod def parse_id ( response : dict ) -> str : \"\"\" Parses the Id of a successful creation of a TickTick object. !!! info The response from the TickTick servers is in this form: ```md {'id2etag': {'5ff2bcf68f08093e5b745a30': '3okkc2xm'}, 'id2error': {}} ``` We want to obtain '5ff2bcf68f08093e5b745a30' in this example - the id of the object. Arguments: response: Dictionary containing the Dd from the TickTick servers. Returns: Id string of the object. \"\"\" id_tag = response [ 'id2etag' ] id_tag = list ( id_tag . keys ()) return id_tag [ 0 ] reset_local_state ( self ) \u00b6 Resets the contents of the items in the state dictionary. Source code in ticktick/api.py def reset_local_state ( self ): \"\"\" Resets the contents of the items in the [`state`](api.md#state) dictionary. \"\"\" self . state = { 'projects' : [], 'project_folders' : [], 'tags' : [], 'tasks' : [], 'user_settings' : {}, 'profile' : {} } sync ( self ) \u00b6 Populates the TickTickClient state dictionary with the contents of your account. This method is called when necessary by other methods and does not need to be explicitly called. Returns: Type Description httpx The response from the get request. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py @logged_in def sync ( self ): \"\"\" Populates the `TickTickClient` [`state`](api.md#state) dictionary with the contents of your account. **This method is called when necessary by other methods and does not need to be explicitly called.** Returns: httpx: The response from the get request. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . http_get ( self . INITIAL_BATCH_URL , cookies = self . cookies ) # Inbox Id self . inbox_id = response [ 'inboxId' ] # Set list groups self . state [ 'project_folders' ] = response [ 'projectGroups' ] # Set lists self . state [ 'projects' ] = response [ 'projectProfiles' ] # Set Uncompleted Tasks self . state [ 'tasks' ] = response [ 'syncTaskBean' ][ 'update' ] # Set tags self . state [ 'tags' ] = response [ 'tags' ] return response","title":"API and Important Information"},{"location":"usage/api/#logging-in","text":"Info A successful login is required. Initializing Your Session from ticktick import api client = api . TickTickClient ( 'username' , 'password' ) # Enter correct username and password Once you have initialized your session, all interactions will occur through the instance, in this case: client","title":"Logging In"},{"location":"usage/api/#state","text":"The state public member is a dictionary that contains objects linked to your TickTick profile. The dictionary is automatically updated and synced when changes are made through the API. state Members The lists are comprised of dictionaries that contain all the fields for each type of TickTick object: tasks, tags, etc. Member Type Contains tasks list All uncompleted task objects tags list All tag objects projects list All project objects project_folders list All project folder objects Accessing Members can be accessed by normal dictionary indexing using the member strings. # Assumes that 'client' is the name that references the TickTickClient class. uncompleted_tasks = client . state [ 'tasks' ] all_tags = client . state [ 'tags' ] Example Task Object { 'id' : '5ff24e4b8f08904035b304d9' , 'projectId' : 'inbox416323287' , 'sortOrder' : - 1099511627776 , 'title' : 'Get Groceries' , 'content' : '' , 'startDate' : '2021-05-06T21:30:00.000+0000' , 'dueDate' : '2021-05-06T21:30:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : False , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-03T23:07:55.004+0000' , 'etag' : 'ol2zesef' , 'deleted' : 0 , 'createdTime' : '2021-01-03T23:07:55.011+0000' , 'creator' : 359368200 , 'kind' : 'TEXT' }","title":"State"},{"location":"usage/api/#functionality","text":"Different functionality can be accessed through different public members of the TickTickClient instance: Functionality Method Managers Accessing the methods for each type of member is easy. It is in this format: client (or whatever name references the TickTickClient instance). manager (members in table below). method() Member Functionality task Task Methods tag Tag Methods project List Methods Example Usage # Assumes that 'client' is the name that references the TickTickClient instance. created_task = client . task . create ( 'My Created Task' ) deleted_project = client . project . delete ( project_id ) Make sure to check the individual documentation for the different method managers. Other Public Members Useful Members Member Type Description profile_id str ID assigned to your profile inbox_id str Inbox ID assigned to your profile time_zone str Timezone string linked to your TickTick profile state dict Holds all the item objects in your profile (described above) Members That Shouldn't Be Messed With Messing with these values could produce unwanted effects. Member Type Description access_token str Instance token generated by TickTick for your session. cookies dict Cookies required for your session.","title":"Functionality"},{"location":"usage/api/#useful-methods","text":"TickTickClient has a lot of helper functions in its documentation...however these should be the only of use methods to you: Tip It's recommended that you look at the documentation for these three methods to see how to obtain / delete objects from the local state dictionary - an important feature that will be useful when updating / deleting TickTick objects remotely. delete_from_local_state get_by_fields get_by_id get_by_etag","title":"Useful Methods"},{"location":"usage/api/#thats-it","text":"That's all the required information for how to get started with the API! To see how to use individual features, check these out next: Tasks Projects Tags ## `TickTickClient Documentation`","title":"That's It!"},{"location":"usage/api/#api.TickTickClient","text":"","title":"TickTickClient"},{"location":"usage/api/#api.TickTickClient.__init__","text":"Initializes a client session. In order to interact with the API a successful login must occur. See Logging In for help. Parameters: Name Type Description Default username str TickTick Username required password str TickTick Password required Exceptions: Type Description RunTimeError If the login was not successful. Source code in ticktick/api.py def __init__ ( self , username : str , password : str ) -> None : \"\"\" Initializes a client session. In order to interact with the API a successful login must occur. See [Logging In](api.md#logging-in) for help. Arguments: username: TickTick Username password: TickTick Password Raises: RunTimeError: If the login was not successful. \"\"\" # Class members self . access_token = '' self . cookies = {} self . session = httpx . Client () self . time_zone = '' self . profile_id = '' self . inbox_id = '' self . state = {} self . reset_local_state () self . _login ( username , password ) self . _settings () self . sync () # Mangers for the different operations self . focus = FocusTimeManager ( self ) self . habit = HabitManager ( self ) self . project = ProjectManager ( self ) self . pomo = PomoManager ( self ) self . settings = SettingsManager ( self ) self . tag = TagsManager ( self ) self . task = TaskManager ( self )","title":"__init__()"},{"location":"usage/api/#api.TickTickClient.check_status_code","text":"Verifies the http response was status code 200. Parameters: Name Type Description Default response httpx Httpx response required error_message str Error message to be included with the exception required Exceptions: Type Description RuntimeError If the status code of the response was not 200. Source code in ticktick/api.py @staticmethod def check_status_code ( response , error_message : str ) -> None : \"\"\" Verifies the http response was status code 200. Arguments: response (httpx): Httpx response error_message: Error message to be included with the exception Raises: RuntimeError: If the status code of the response was not 200. \"\"\" if response . status_code != 200 : raise RuntimeError ( error_message )","title":"check_status_code()"},{"location":"usage/api/#api.TickTickClient.delete_from_local_state","text":"Deletes a single object from the local state dictionary. Does not delete any items remotely. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, lists, and tags are just dictionaries of fields, we can find an object by comparing the fields. For example: Lets say that we wanted to find and delete an existing task object from our local state with the name 'Get Groceries'. To do this, we can specify the field(s) that we want to compare for in the task objects -> in this case the title 'Get Groceries'. The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client . delete_from_local_state ( title = 'Get Groceries' ) deleted_task would now hold the object that was deleted from the state dictionary if it was found. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client . delete_from_local_state ( title = 'Get Groceries' , search = 'tasks' ) The search will now only look through tasks in state . Parameters: Name Type Description Default search str A specific item to look through in the state dictionary. When not specified the entire state dictionary will be searched. None **kwargs Matching fields in the object to look for. {} Returns: Type Description dict The dictionary of the object that was deleted. Exceptions: Type Description ValueError If no key word arguments are provided. KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def delete_from_local_state ( self , search : str = None , ** kwargs ) -> dict : \"\"\" Deletes a single object from the local `state` dictionary. **Does not delete any items remotely.** If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, lists, and tags are just dictionaries of fields, we can find an object by comparing the fields. For example: Lets say that we wanted to find and delete an existing task object from our local state with the name 'Get Groceries'. To do this, we can specify the field(s) that we want to compare for in the task objects -> in this case the `title` 'Get Groceries'. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client.delete_from_local_state(title='Get Groceries') ``` `deleted_task` would now hold the object that was deleted from the [`state`](api.md#state) dictionary if it was found. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. deleted_task = client.delete_from_local_state(title='Get Groceries', search='tasks') ``` The search will now only look through `tasks` in `state`. Arguments: search: A specific item to look through in the [`state`](api.md#state) dictionary. When not specified the entire [`state`](api.md#state) dictionary will be searched. **kwargs: Matching fields in the object to look for. Returns: The dictionary of the object that was deleted. Raises: ValueError: If no key word arguments are provided. KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" # Check that kwargs is not empty if kwargs == {}: raise ValueError ( 'Must Include Field(s) To Be Searched For' ) if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : # Go through the state dictionary list and delete the object that matches the fields for item in range ( len ( self . state [ search ])): all_match = True for field in kwargs : if kwargs [ field ] != self . state [ search ][ item ][ field ]: all_match = False break if all_match : deleted = self . state [ search ][ item ] # Delete the item del self . state [ search ][ item ] return deleted else : # No key passed, search entire self.state dictionary # Search the first level of the state dictionary for primary_key in self . state : skip_primary_key = False all_match = True middle_key = 0 # Search the individual lists of the dictionary for middle_key in range ( len ( self . state [ primary_key ])): if skip_primary_key : break # Match the fields in the kwargs dictionary to the specific object -> if all match add index for fields in kwargs : # if the field doesn't exist, we can assume every other item in the list doesn't have the # field either -> so skip this primary_key entirely if fields not in self . state [ primary_key ][ middle_key ]: all_match = False skip_primary_key = True break if kwargs [ fields ] == self . state [ primary_key ][ middle_key ][ fields ]: all_match = True else : all_match = False if all_match : deleted = self . state [ primary_key ][ middle_key ] del self . state [ primary_key ][ middle_key ] return deleted","title":"delete_from_local_state()"},{"location":"usage/api/#api.TickTickClient.get_by_etag","text":"Returns the dictionary object of the item with the matching etag. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the etag fields. For example: Lets get the object that corresponds to an etag referenced by my_etag . The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_etag ( my_etag ) found_obj would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_etag ( my_etag , search = 'projects' ) The search will now only look through projects in state . Parameters: Name Type Description Default etag str The etag of the object that you are looking for. required search str Key in state that the search should take place in. If empty the entire state dictionary will be searched. None Returns: Type Description dict The dictionary object of the item if found, or an empty dictionary if not found. Exceptions: Type Description KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_etag ( self , etag : str , search : str = None ) -> dict : \"\"\" Returns the dictionary object of the item with the matching etag. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the etag fields. For example: Lets get the object that corresponds to an etag referenced by `my_etag`. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_etag(my_etag) ``` `found_obj` would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_etag(my_etag, search='projects') ``` The search will now only look through `projects` in [`state`](api.md#state). Arguments: etag: The etag of the object that you are looking for. search: Key in [`state`](#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. Returns: The dictionary object of the item if found, or an empty dictionary if not found. Raises: KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : for index in self . state [ search ]: if index [ 'etag' ] == etag : return index else : # Search all items in self.state for prim_key in self . state : for our_object in self . state [ prim_key ]: if 'etag' not in our_object : break if our_object [ 'etag' ] == etag : return our_object # Return empty dictionary if not found return {}","title":"get_by_etag()"},{"location":"usage/api/#api.TickTickClient.get_by_fields","text":"Finds and returns the objects in state that match the inputted fields. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing any fields contained in those objects. For example: Lets say we have 3 task objects that are titled 'Hello', and we want to obtain all of them. The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_objs = client . get_by_fields ( title = 'Hello' ) found_objs would now reference a list containing the 3 objects with titles 'Hello'. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_fields ( title = 'Hello' , search = 'tasks' ) The search will now only look through tasks in state . Parameters: Name Type Description Default search str Key in state that the search should take place in. If empty the entire state dictionary will be searched. None **kwargs Matching fields in the object to look for. {} Returns: Type Description dict or list Single Object (dict) : The dictionary of the object. Multiple Objects (list) : A list of dictionary objects. Nothing Found (list) : Empty List Exceptions: Type Description ValueError If no key word arguments are provided. KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_fields ( self , search : str = None , ** kwargs ): \"\"\" Finds and returns the objects in `state` that match the inputted fields. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing any fields contained in those objects. For example: Lets say we have 3 task objects that are titled 'Hello', and we want to obtain all of them. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_objs = client.get_by_fields(title='Hello') ``` `found_objs` would now reference a list containing the 3 objects with titles 'Hello'. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_fields(title='Hello', search='tasks') ``` The search will now only look through `tasks` in [`state`](api.md#state). Arguments: search: Key in [`state`](api.md#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. **kwargs: Matching fields in the object to look for. Returns: dict or list: **Single Object (dict)**: The dictionary of the object. **Multiple Objects (list)**: A list of dictionary objects. **Nothing Found (list)**: Empty List Raises: ValueError: If no key word arguments are provided. KeyError: If the search key provided is not a key in `state`. \"\"\" if kwargs == {}: raise ValueError ( 'Must Include Field(s) To Be Searched For' ) if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) objects = [] if search is not None : # If a specific key was passed for self.state # Go through self.state[key_name] and see if all the fields in kwargs match # If all don't match return empty list for index in self . state [ search ]: all_match = True for field in kwargs : if kwargs [ field ] != index [ field ]: all_match = False break if all_match : objects . append ( index ) else : # No key passed, search entire self.state dictionary # Search the first level of the state dictionary for primarykey in self . state : skip_primary_key = False all_match = True middle_key = 0 # Search the individual lists of the dictionary for middle_key in range ( len ( self . state [ primarykey ])): if skip_primary_key : break # Match the fields in the kwargs dictionary to the specific object -> if all match add index for fields in kwargs : # if the field doesn't exist, we can assume every other item in the list doesn't have the # field either -> so skip this primary_key entirely if fields not in self . state [ primarykey ][ middle_key ]: all_match = False skip_primary_key = True break if kwargs [ fields ] == self . state [ primarykey ][ middle_key ][ fields ]: all_match = True else : all_match = False if all_match : objects . append ( self . state [ primarykey ][ middle_key ]) if len ( objects ) == 1 : return objects [ 0 ] else : return objects","title":"get_by_fields()"},{"location":"usage/api/#api.TickTickClient.get_by_id","text":"Returns the dictionary of the object corresponding to the passed id. If search is specified, it will only search the specific state list, else the entire state dictionary will be searched. Example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the id fields. For example: Lets get the object that corresponds to an id referenced by my_id . The call to the function would look like this: # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_id ( my_id ) found_obj would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the state dictionary. # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client . get_by_id ( my_id , search = 'projects' ) The search will now only look through projects in state . Parameters: Name Type Description Default obj_id str Id of the item. required search str Key in state that the search should take place in. If empty the entire state dictionary will be searched. None Returns: Type Description dict The dictionary object of the item if found, or an empty dictionary if not found. Exceptions: Type Description KeyError If the search key provided is not a key in state . Source code in ticktick/api.py def get_by_id ( self , obj_id : str , search : str = None ) -> dict : \"\"\" Returns the dictionary of the object corresponding to the passed id. If search is specified, it will only search the specific [`state`](api.md#state) list, else the entire [`state`](api.md#state) dictionary will be searched. !!! example Since each TickTick object like tasks, projects, and tags are just dictionaries of fields, we can find an object by comparing the id fields. For example: Lets get the object that corresponds to an id referenced by `my_id`. The call to the function would look like this: ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_id(my_id) ``` `found_obj` would now reference the object if it was found, else it would reference an empty dictionary. Furthermore if we know the type of object we are looking for, we can make the search more efficient by specifying the key its located under in the [`state`](api.md#state) dictionary. ```python # Assumes that `client` is the name referencing the TickTickClient instance. found_obj = client.get_by_id(my_id, search='projects') ``` The search will now only look through `projects` in [`state`](api.md#state). Arguments: obj_id: Id of the item. search: Key in [`state`](api.md#state) that the search should take place in. If empty the entire [`state`](api.md#state) dictionary will be searched. Returns: The dictionary object of the item if found, or an empty dictionary if not found. Raises: KeyError: If the search key provided is not a key in [`state`](api.md#state). \"\"\" if search is not None and search not in self . state : raise KeyError ( f \"' { search } ' Is Not Present In self.state Dictionary\" ) # Search just in the desired list if search is not None : for index in self . state [ search ]: if index [ 'id' ] == obj_id : return index else : # Search all items in self.state for prim_key in self . state : for our_object in self . state [ prim_key ]: if 'id' not in our_object : break if our_object [ 'id' ] == obj_id : return our_object # Return empty dictionary if not found return {}","title":"get_by_id()"},{"location":"usage/api/#api.TickTickClient.http_delete","text":"Sends an http delete request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_delete ( self , url , ** kwargs ): \"\"\" Sends an http delete request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . session . delete ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text","title":"http_delete()"},{"location":"usage/api/#api.TickTickClient.http_get","text":"Sends an http get request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_get ( self , url , ** kwargs ): \"\"\" Sends an http get request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . session . get ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text","title":"http_get()"},{"location":"usage/api/#api.TickTickClient.http_post","text":"Sends an http post request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_post ( self , url , ** kwargs ): \"\"\" Sends an http post request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . session . post ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text","title":"http_post()"},{"location":"usage/api/#api.TickTickClient.http_put","text":"Sends an http put request with the specified url and keyword arguments. Parameters: Name Type Description Default url str Url to send the request. required **kwargs Arguments to send with the request. {} Returns: Type Description dict The json parsed response if possible or just a string of the response text if not. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py def http_put ( self , url , ** kwargs ): \"\"\" Sends an http put request with the specified url and keyword arguments. Arguments: url (str): Url to send the request. **kwargs: Arguments to send with the request. Returns: dict: The json parsed response if possible or just a string of the response text if not. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . session . put ( url , ** kwargs ) self . check_status_code ( response , 'Could Not Complete Request' ) try : return response . json () except ValueError : return response . text","title":"http_put()"},{"location":"usage/api/#api.TickTickClient.parse_etag","text":"Parses the etag of a successful creation of a tag object. Info The response from TickTick upon a successful tag creation is in this form: {\"id2etag\":{\"MyTag\":\"vxzpwo38\"},\"id2error\":{}} We want to obtain \"vxzpwo38\" in this example - the etag of the object. Parameters: Name Type Description Default response dict Dictionary from the successful creation of a tag object required multiple bool Specifies whether there are multiple etags to return. False Returns: Type Description str A single etag string if not multiple, or a list of etag strings if multiple. Source code in ticktick/api.py @staticmethod def parse_etag ( response : dict , multiple : bool = False ) -> str : \"\"\" Parses the etag of a successful creation of a tag object. !!! info The response from TickTick upon a successful tag creation is in this form: ```md {\"id2etag\":{\"MyTag\":\"vxzpwo38\"},\"id2error\":{}} ``` We want to obtain \"vxzpwo38\" in this example - the etag of the object. Arguments: response: Dictionary from the successful creation of a tag object multiple: Specifies whether there are multiple etags to return. Return: A single etag string if not multiple, or a list of etag strings if multiple. \"\"\" etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) if not multiple : return etag [ etag2 [ 0 ]] else : etags = [] for key in range ( len ( etag2 )): etags . append ( etag [ etag2 [ key ]]) return etags","title":"parse_etag()"},{"location":"usage/api/#api.TickTickClient.parse_id","text":"Parses the Id of a successful creation of a TickTick object. Info The response from the TickTick servers is in this form: {'id2etag': {'5ff2bcf68f08093e5b745a30': '3okkc2xm'}, 'id2error': {}} We want to obtain '5ff2bcf68f08093e5b745a30' in this example - the id of the object. Parameters: Name Type Description Default response dict Dictionary containing the Dd from the TickTick servers. required Returns: Type Description str Id string of the object. Source code in ticktick/api.py @staticmethod def parse_id ( response : dict ) -> str : \"\"\" Parses the Id of a successful creation of a TickTick object. !!! info The response from the TickTick servers is in this form: ```md {'id2etag': {'5ff2bcf68f08093e5b745a30': '3okkc2xm'}, 'id2error': {}} ``` We want to obtain '5ff2bcf68f08093e5b745a30' in this example - the id of the object. Arguments: response: Dictionary containing the Dd from the TickTick servers. Returns: Id string of the object. \"\"\" id_tag = response [ 'id2etag' ] id_tag = list ( id_tag . keys ()) return id_tag [ 0 ]","title":"parse_id()"},{"location":"usage/api/#api.TickTickClient.reset_local_state","text":"Resets the contents of the items in the state dictionary. Source code in ticktick/api.py def reset_local_state ( self ): \"\"\" Resets the contents of the items in the [`state`](api.md#state) dictionary. \"\"\" self . state = { 'projects' : [], 'project_folders' : [], 'tags' : [], 'tasks' : [], 'user_settings' : {}, 'profile' : {} }","title":"reset_local_state()"},{"location":"usage/api/#api.TickTickClient.sync","text":"Populates the TickTickClient state dictionary with the contents of your account. This method is called when necessary by other methods and does not need to be explicitly called. Returns: Type Description httpx The response from the get request. Exceptions: Type Description RunTimeError If the request could not be completed. Source code in ticktick/api.py @logged_in def sync ( self ): \"\"\" Populates the `TickTickClient` [`state`](api.md#state) dictionary with the contents of your account. **This method is called when necessary by other methods and does not need to be explicitly called.** Returns: httpx: The response from the get request. Raises: RunTimeError: If the request could not be completed. \"\"\" response = self . http_get ( self . INITIAL_BATCH_URL , cookies = self . cookies ) # Inbox Id self . inbox_id = response [ 'inboxId' ] # Set list groups self . state [ 'project_folders' ] = response [ 'projectGroups' ] # Set lists self . state [ 'projects' ] = response [ 'projectProfiles' ] # Set Uncompleted Tasks self . state [ 'tasks' ] = response [ 'syncTaskBean' ][ 'update' ] # Set tags self . state [ 'tags' ] = response [ 'tags' ] return response","title":"sync()"},{"location":"usage/helpers/","text":"Other Useful Methods and Info \u00b6 Time Zones \u00b6 Source For a list of timezone strings, see List of tz database time zones Acceptable Time Zone names are found under the 'TZ database name' column. time_methods \u00b6 Useful time conversion methods. convert_date_to_tick_tick_format ( date , tz ) \u00b6 Parses ISO 8601 Format to Tick Tick Date Format It first converts the datetime object to UTC time based off the passed time zone, and then returns a string with the TickTick required date format. Info ISO 8601 Format Example: 2020-12-23T01:56:07+00:00 TickTick Required Format: 2020-12-23T01:56:07+0000 -> Where the last colon is removed for timezone Parameters: Name Type Description Default date datetime Datetime object to be parsed. required tz str Time zone string. required Returns: Type Description str The TickTick accepted date string. Import Help from ticktick.helpers.time_methods import convert_iso_to_tick_tick_format Example date = datetime ( 2022 , 12 , 31 , 14 , 30 , 45 ) converted_date = convert_iso_to_tick_tick_format ( date , 'US/Pacific' ) Result The proper format for a date string to be used with TickTick dates. '2022-12-31T22:30:45+0000' Source code in helpers/time_methods.py def convert_date_to_tick_tick_format ( date , tz : str ): \"\"\" Parses ISO 8601 Format to Tick Tick Date Format It first converts the datetime object to UTC time based off the passed time zone, and then returns a string with the TickTick required date format. !!! info Required Format ISO 8601 Format Example: 2020-12-23T01:56:07+00:00 TickTick Required Format: 2020-12-23T01:56:07+0000 -> Where the last colon is removed for timezone Arguments: date (datetime): Datetime object to be parsed. tz: Time zone string. Returns: str: The TickTick accepted date string. ??? info \"Import Help\" ```python from ticktick.helpers.time_methods import convert_iso_to_tick_tick_format ``` ??? example ```python date = datetime(2022, 12, 31, 14, 30, 45) converted_date = convert_iso_to_tick_tick_format(date, 'US/Pacific') ``` ??? success \"Result\" The proper format for a date string to be used with TickTick dates. ```python '2022-12-31T22:30:45+0000' ``` \"\"\" date = convert_local_time_to_utc ( date , tz ) date = date . replace ( tzinfo = datetime . timezone . utc ) . isoformat () date = date [:: - 1 ] . replace ( \":\" , \"\" , 1 )[:: - 1 ] return date convert_local_time_to_utc ( original_time , time_zone ) \u00b6 Converts the datetime object to UTC time. Utilizes the time_zone string for proper conversion. Parameters: Name Type Description Default original_time datetime Datetime object required time_zone str Time zone of original_time required Returns: Type Description datetime Datetime object with the converted UTC time - with no timezone information attached. Import Help from ticktick.helpers.time_methods import convert_local_time_to_utc Example pst = datetime ( 2020 , 12 , 11 , 23 , 59 ) converted = convert_local_time_to_utc ( pst , 'US/Pacific' ) Result A datetime object that is the UTC equivalent of the original date. datetime ( 2020 , 12 , 12 , 7 , 59 ) Source code in helpers/time_methods.py def convert_local_time_to_utc ( original_time , time_zone : str ): \"\"\" Converts the datetime object to UTC time. Utilizes the time_zone string for proper conversion. Arguments: original_time (datetime): Datetime object time_zone: Time zone of `original_time` Returns: datetime: Datetime object with the converted UTC time - with no timezone information attached. ??? info \"Import Help\" ```python from ticktick.helpers.time_methods import convert_local_time_to_utc ``` ??? Example ```python pst = datetime(2020, 12, 11, 23, 59) converted = convert_local_time_to_utc(pst, 'US/Pacific') ``` ??? success \"Result\" A datetime object that is the UTC equivalent of the original date. ```python datetime(2020, 12, 12, 7, 59) ``` \"\"\" utc = pytz . utc time_zone = pytz . timezone ( time_zone ) original_time = original_time . strftime ( DATE_FORMAT ) time_object = datetime . datetime . strptime ( original_time , DATE_FORMAT ) time_zone_dt = time_zone . localize ( time_object ) return time_zone_dt . astimezone ( utc ) . replace ( tzinfo = None ) hex_color \u00b6 Provides some methods for dealing with hex color code strings. check_hex_color ( color ) \u00b6 Verifies if the passed in color string is a valid hexadecimal color string Parameters: Name Type Description Default color str String to check. required Returns: Type Description bool True if the string is a valid hex code, else False. Import Help from ticktick.helpers.hex_color import check_hex_color Source code in helpers/hex_color.py def check_hex_color ( color : str ) -> bool : \"\"\" Verifies if the passed in color string is a valid hexadecimal color string Arguments: color: String to check. Returns: True if the string is a valid hex code, else False. ??? info \"Import Help\" ```python from ticktick.helpers.hex_color import check_hex_color ``` \"\"\" check_color = re . search ( VALID_HEX_VALUES , color ) if not check_color : return False else : return True generate_hex_color () \u00b6 Generates a random hexadecimal color string to be used for rgb color schemes. Returns: Type Description str '#' followed by 6 hexadecimal digits. Import Help from ticktick.helpers.hex_color import generate_hex_color Source code in helpers/hex_color.py def generate_hex_color () -> str : \"\"\" Generates a random hexadecimal color string to be used for rgb color schemes. Returns: '#' followed by 6 hexadecimal digits. ??? info \"Import Help\" ```python from ticktick.helpers.hex_color import generate_hex_color ``` \"\"\" num = random . randint ( 1118481 , 16777215 ) hex_num = format ( num , 'x' ) return '#' + hex_num","title":"Helpers"},{"location":"usage/helpers/#other-useful-methods-and-info","text":"","title":"Other Useful Methods and Info"},{"location":"usage/helpers/#time-zones","text":"Source For a list of timezone strings, see List of tz database time zones Acceptable Time Zone names are found under the 'TZ database name' column.","title":"Time Zones"},{"location":"usage/helpers/#time_methods","text":"Useful time conversion methods.","title":"time_methods"},{"location":"usage/helpers/#helpers.time_methods.convert_date_to_tick_tick_format","text":"Parses ISO 8601 Format to Tick Tick Date Format It first converts the datetime object to UTC time based off the passed time zone, and then returns a string with the TickTick required date format. Info ISO 8601 Format Example: 2020-12-23T01:56:07+00:00 TickTick Required Format: 2020-12-23T01:56:07+0000 -> Where the last colon is removed for timezone Parameters: Name Type Description Default date datetime Datetime object to be parsed. required tz str Time zone string. required Returns: Type Description str The TickTick accepted date string. Import Help from ticktick.helpers.time_methods import convert_iso_to_tick_tick_format Example date = datetime ( 2022 , 12 , 31 , 14 , 30 , 45 ) converted_date = convert_iso_to_tick_tick_format ( date , 'US/Pacific' ) Result The proper format for a date string to be used with TickTick dates. '2022-12-31T22:30:45+0000' Source code in helpers/time_methods.py def convert_date_to_tick_tick_format ( date , tz : str ): \"\"\" Parses ISO 8601 Format to Tick Tick Date Format It first converts the datetime object to UTC time based off the passed time zone, and then returns a string with the TickTick required date format. !!! info Required Format ISO 8601 Format Example: 2020-12-23T01:56:07+00:00 TickTick Required Format: 2020-12-23T01:56:07+0000 -> Where the last colon is removed for timezone Arguments: date (datetime): Datetime object to be parsed. tz: Time zone string. Returns: str: The TickTick accepted date string. ??? info \"Import Help\" ```python from ticktick.helpers.time_methods import convert_iso_to_tick_tick_format ``` ??? example ```python date = datetime(2022, 12, 31, 14, 30, 45) converted_date = convert_iso_to_tick_tick_format(date, 'US/Pacific') ``` ??? success \"Result\" The proper format for a date string to be used with TickTick dates. ```python '2022-12-31T22:30:45+0000' ``` \"\"\" date = convert_local_time_to_utc ( date , tz ) date = date . replace ( tzinfo = datetime . timezone . utc ) . isoformat () date = date [:: - 1 ] . replace ( \":\" , \"\" , 1 )[:: - 1 ] return date","title":"convert_date_to_tick_tick_format()"},{"location":"usage/helpers/#helpers.time_methods.convert_local_time_to_utc","text":"Converts the datetime object to UTC time. Utilizes the time_zone string for proper conversion. Parameters: Name Type Description Default original_time datetime Datetime object required time_zone str Time zone of original_time required Returns: Type Description datetime Datetime object with the converted UTC time - with no timezone information attached. Import Help from ticktick.helpers.time_methods import convert_local_time_to_utc Example pst = datetime ( 2020 , 12 , 11 , 23 , 59 ) converted = convert_local_time_to_utc ( pst , 'US/Pacific' ) Result A datetime object that is the UTC equivalent of the original date. datetime ( 2020 , 12 , 12 , 7 , 59 ) Source code in helpers/time_methods.py def convert_local_time_to_utc ( original_time , time_zone : str ): \"\"\" Converts the datetime object to UTC time. Utilizes the time_zone string for proper conversion. Arguments: original_time (datetime): Datetime object time_zone: Time zone of `original_time` Returns: datetime: Datetime object with the converted UTC time - with no timezone information attached. ??? info \"Import Help\" ```python from ticktick.helpers.time_methods import convert_local_time_to_utc ``` ??? Example ```python pst = datetime(2020, 12, 11, 23, 59) converted = convert_local_time_to_utc(pst, 'US/Pacific') ``` ??? success \"Result\" A datetime object that is the UTC equivalent of the original date. ```python datetime(2020, 12, 12, 7, 59) ``` \"\"\" utc = pytz . utc time_zone = pytz . timezone ( time_zone ) original_time = original_time . strftime ( DATE_FORMAT ) time_object = datetime . datetime . strptime ( original_time , DATE_FORMAT ) time_zone_dt = time_zone . localize ( time_object ) return time_zone_dt . astimezone ( utc ) . replace ( tzinfo = None )","title":"convert_local_time_to_utc()"},{"location":"usage/helpers/#hex_color","text":"Provides some methods for dealing with hex color code strings.","title":"hex_color"},{"location":"usage/helpers/#helpers.hex_color.check_hex_color","text":"Verifies if the passed in color string is a valid hexadecimal color string Parameters: Name Type Description Default color str String to check. required Returns: Type Description bool True if the string is a valid hex code, else False. Import Help from ticktick.helpers.hex_color import check_hex_color Source code in helpers/hex_color.py def check_hex_color ( color : str ) -> bool : \"\"\" Verifies if the passed in color string is a valid hexadecimal color string Arguments: color: String to check. Returns: True if the string is a valid hex code, else False. ??? info \"Import Help\" ```python from ticktick.helpers.hex_color import check_hex_color ``` \"\"\" check_color = re . search ( VALID_HEX_VALUES , color ) if not check_color : return False else : return True","title":"check_hex_color()"},{"location":"usage/helpers/#helpers.hex_color.generate_hex_color","text":"Generates a random hexadecimal color string to be used for rgb color schemes. Returns: Type Description str '#' followed by 6 hexadecimal digits. Import Help from ticktick.helpers.hex_color import generate_hex_color Source code in helpers/hex_color.py def generate_hex_color () -> str : \"\"\" Generates a random hexadecimal color string to be used for rgb color schemes. Returns: '#' followed by 6 hexadecimal digits. ??? info \"Import Help\" ```python from ticktick.helpers.hex_color import generate_hex_color ``` \"\"\" num = random . randint ( 1118481 , 16777215 ) hex_num = format ( num , 'x' ) return '#' + hex_num","title":"generate_hex_color()"},{"location":"usage/projects/","text":"Important Projects within TickTick are known as Lists . However, in the API Lists are referred to as Projects to limit confusion with the list built in type. Info Project methods are accessed through the project public member of your TickTickClient instance. # Assumes that 'client' is the name that references the TickTickClient instance. project = client . project . method () Question About Logging In or Other Functionality Available? API and Important Information Tip All supported methods are documented below with usage examples, take a look! All usage examples assume that client is the name referencing the TickTickClient instance Example TickTick Project Dictionary \u00b6 Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the project '5ffe93f3b04b35082bbce7b0' str N/A name The name of the project 'Hobbies' str N/A isOwner Whether you are the owner of the project or not. True bool N/A color The hex color code for the project. '#6fcbdf' str N/A inAll N/A True bool N/A sortOrder A sort ID relative to other tasks in the project -1099511627776 int Lower sortOrder == Higher Position sortType Sort type of the project dueDate str dueDate , sortOrder , title , tag , priority userCount How many users have access to the project. 1 int N/A etag Etag identifier. 'ji35exmv' str N/A modifiedTime Time last modified. '2021-01-13T07:18:21.000+0000' str N/A closed Archive status. False bool none and False = Not Archived, True = Archived muted Whether the project is 'hidden' (no notifications) False bool N/A transferred Possibly if the ownership of the project has changed. None bool N/A groupId ID of the project folder if it exists. '5ffe11b7b04b356ce74d49da' str N/A viewMode View mode of the project. 'kanban' str kanban or list notificationOptions N/A None N/A N/A teamId ID of your team. 342537403 int N/A permission N/A None N/A N/A kind If the project is a normal TASK project or NOTE project 'TASK' str 'TASK' or 'NOTE' { 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'qbj4z0gl' , 'modifiedTime' : '2021-01-12T22:37:21.823+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Example TickTick Project Folder (group) Dictionary \u00b6 Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the project folder '5ffe93f3b04b35082bbce7b0' str N/A etag Etag identifier. 'ji35exmv' str N/A name The name of the project folder 'Hobbies' str N/A showAll N/A True bool N/A sortOrder A sort ID relative to other tasks in the project -1099511627776 int Lower sortOrder == Higher Position deleted Whether the project folder is deleted or not. 0 int N/A userId User ID of the creator 586938759 int N/A sortType Sort type of the project folder dueDate str dueDate , project , title , tag , priority teamId ID of your team. 342537403 int N/A { 'id' : '600008f2b04b355792c7a42d' , 'etag' : 'yeozz5v8' , 'name' : 'Test' , 'showAll' : True , 'sortOrder' : - 6786182545408 , 'deleted' : 0 , 'userId' : 586934829 , 'sortType' : 'project' , 'teamId' : None } ProjectManager \u00b6 Handles all interactions for projects. archive ( self , ids ) \u00b6 Moves the project(s) to a project folder created by TickTick called \"Archived Lists\" To unarchive a project, change its 'closed' field to True , then update Parameters: Name Type Description Default ids str or list Single Project (str) : ID string of the project to archive. Multiple Projects (list) : List of ID strings of the projects to archive. required Returns: Type Description dict or list Single Project (dict) : Dictionary of the archived object. Multiple Projects (list) : List of dictionaries of the archived objects. Exceptions: Type Description TypeError If ids is not a string or list. ValueError If the project(s) don't already exist RuntimeError If the project(s) could not be successfully archived. Example Single Project Archive # Lets assume there is a project that exists named \"Reading\" reading_project = client . get_by_fields ( name = \"Reading\" , search = \"projects\" ) reading_project_id = reading_project [ 'id' ] archived = client . project . archive ( reading_project_id ) Result A single dictionary is returned. { 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'c9tgze9b' , 'modifiedTime' : '2021-01-13T00:34:50.449+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Before After Multiple Project Archive # Lets assume there is a project that exists named \"Reading\" reading_project = client . get_by_fields ( name = \"Reading\" , search = \"projects\" ) reading_project_id = reading_project [ 'id' ] # Lets assume another project exists named \"Writing\" writing_project = client . get_by_fields ( name = 'Writing' , search = 'projects' ) writing_project_id = writing_project [ 'id' ] # Archiving multiple requires putting the ID's in a list. archive_list = [ reading_project_id , writing_project_id ] archived = client . project . archive ( archive_list ) Result A list of dictionary objects is returned. [{ 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : - 7335938359296 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'qrga45as' , 'modifiedTime' : '2021-01-13T00:40:49.839+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe41328f08237f3d147e33' , 'name' : 'Writing' , 'isOwner' : True , 'color' : '#F2B04B' , 'inAll' : True , 'sortOrder' : - 7885694173184 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'aenkajam' , 'modifiedTime' : '2021-01-13T00:40:49.843+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Before After Source code in managers/projects.py @logged_in def archive ( self , ids ): \"\"\" Moves the project(s) to a project folder created by `TickTick` called \"Archived Lists\" To unarchive a project, change its `'closed'` field to `True`, then [update][managers.projects.ProjectManager.update] Arguments: ids (str or list): **Single Project (str)**: ID string of the project to archive. **Multiple Projects (list)**: List of ID strings of the projects to archive. Returns: dict or list: **Single Project (dict)**: Dictionary of the archived object. **Multiple Projects (list)**: List of dictionaries of the archived objects. Raises: TypeError: If `ids` is not a string or list. ValueError: If the project(s) don't already exist RuntimeError: If the project(s) could not be successfully archived. !!! example === \"Single Project Archive\" ```python # Lets assume there is a project that exists named \"Reading\" reading_project = client.get_by_fields(name=\"Reading\", search=\"projects\") reading_project_id = reading_project['id'] archived = client.project.archive(reading_project_id) ``` ??? success \"Result\" A single dictionary is returned. ```python {'id': '5ffe1673e4b062d60dd29dc0', 'name': 'Reading', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': 0, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'c9tgze9b', 'modifiedTime': '2021-01-13T00:34:50.449+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` **Before** [![archive-before.png](https://i.postimg.cc/R0jfVt7W/archive-before.png)](https://postimg.cc/B8BtmXw3) **After** [![archived-after.png](https://i.postimg.cc/xjPkBh4J/archived-after.png)](https://postimg.cc/K4RvMqFx) === \"Multiple Project Archive\" ```python # Lets assume there is a project that exists named \"Reading\" reading_project = client.get_by_fields(name=\"Reading\", search=\"projects\") reading_project_id = reading_project['id'] # Lets assume another project exists named \"Writing\" writing_project = client.get_by_fields(name='Writing', search='projects') writing_project_id = writing_project['id'] # Archiving multiple requires putting the ID's in a list. archive_list = [reading_project_id, writing_project_id] archived = client.project.archive(archive_list) ``` ??? success \"Result\" A list of dictionary objects is returned. ```python [{'id': '5ffe1673e4b062d60dd29dc0', 'name': 'Reading', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': -7335938359296, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'qrga45as', 'modifiedTime': '2021-01-13T00:40:49.839+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe41328f08237f3d147e33', 'name': 'Writing', 'isOwner': True, 'color': '#F2B04B', 'inAll': True, 'sortOrder': -7885694173184, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'aenkajam', 'modifiedTime': '2021-01-13T00:40:49.843+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` **Before** [![archive-multiple-before.png](https://i.postimg.cc/sgHHmnrb/archive-multiple-before.png)](https://postimg.cc/qNnGMxgG) **After** [![archived-multiple-after.png](https://i.postimg.cc/tg1SMhRJ/archived-multiple-after.png)](https://postimg.cc/rdkNdRr2) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) objs = [] if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { ids } ' Does Not Exist To Archive\" ) # Change the list to archived proj [ 'closed' ] = True objs = [ proj ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { i } ' Does Not Exist To Archive\" ) proj [ 'closed' ] = True objs . append ( proj ) return self . update ( objs ) builder ( self , name , color = 'random' , project_type = 'TASK' , folder_id = None ) \u00b6 Creates and returns a local project object. Helper method for create to make batch creating projects easier. Note The project folder must already exist prior to calling this method. Parameters: Name Type Description Default name str Desired name of the project - project names cannot be repeated required color str Hex color string. A random color will be generated if no color is specified. 'random' project_type str 'TASK' or 'NOTE' 'TASK' folder_id str The project folder id that the project should be placed under (if desired) None Returns: Type Description dict A dictionary containing all the fields necessary to create a remote project. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Project name already exists ValueError Project Folder corresponding to the ID does not exist. ValueError The hex string color inputted is invalid. Argument rules are shared with create , so for more examples on how to use the arguments see that method. Example project_name = 'Work' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Build the object project_object = client . project . builder ( project_name , folder_id = productivity_id ) Result # The fields needed for a successful project creation are set. { 'name' : 'Work' , 'color' : '#665122' , 'kind' : 'TASK' , 'groupId' : '5ffe11b7b04b356ce74d49da' } Source code in managers/projects.py @logged_in def builder ( self , name : str , color : str = 'random' , project_type : str = 'TASK' , folder_id : str = None ) -> dict : \"\"\" Creates and returns a local project object. Helper method for [create][managers.projects.ProjectManager.create] to make batch creating projects easier. !!! note The project [folder][managers.projects.ProjectManager.create_folder] must already exist prior to calling this method. Arguments: name: Desired name of the project - project names cannot be repeated color: Hex color string. A random color will be generated if no color is specified. project_type: 'TASK' or 'NOTE' folder_id: The project folder id that the project should be placed under (if desired) Returns: A dictionary containing all the fields necessary to create a remote project. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Project name already exists ValueError: Project Folder corresponding to the ID does not exist. ValueError: The hex string color inputted is invalid. Argument rules are shared with [create][managers.projects.ProjectManager.create], so for more examples on how to use the arguments see that method. !!! example ```python project_name = 'Work' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Build the object project_object = client.project.builder(project_name, folder_id=productivity_id) ``` ??? success \"Result\" ```python # The fields needed for a successful project creation are set. {'name': 'Work', 'color': '#665122', 'kind': 'TASK', 'groupId': '5ffe11b7b04b356ce74d49da'} ``` \"\"\" if not isinstance ( name , str ): raise TypeError ( \"Name must be a string\" ) if not isinstance ( color , str ) and color is not None : raise TypeError ( \"Color must be a string\" ) if not isinstance ( project_type , str ): raise TypeError ( \"Project type must be a string\" ) if not isinstance ( folder_id , str ) and folder_id is not None : raise TypeError ( \"Folder id must be a string\" ) # Go through self.state['lists'] and determine if the name already exists id_list = self . _client . get_by_fields ( search = 'projects' , name = name ) if id_list : raise ValueError ( f \"Invalid Project Name ' { name } ' -> It Already Exists\" ) # Determine if parent list exists if folder_id is not None : parent = self . _client . get_by_id ( folder_id , search = 'project_folders' ) if not parent : raise ValueError ( f \"Parent Id { folder_id } Does Not Exist\" ) # Make sure project type is valid if project_type != 'TASK' and project_type != 'NOTE' : raise ValueError ( f \"Invalid Project Type ' { project_type } ' -> Should be 'TASK' or 'NOTE'\" ) # Check color_id if color == 'random' : color = generate_hex_color () # Random color will be generated elif color is not None : if not check_hex_color ( color ): raise ValueError ( 'Invalid Hex Color String' ) return { 'name' : name , 'color' : color , 'kind' : project_type , 'groupId' : folder_id } create ( self , name , color = 'random' , project_type = 'TASK' , folder_id = None ) \u00b6 Creates a project remotely. Supports single project creation or batch project creation. Parameters: Name Type Description Default name str or list Single Project (str) : The desired name of the project. Project names cannot be repeated. Multiple Projects (list) : A list of project objects created using the builder method. required color str Hex color string. A random color will be generated if no color is specified. 'random' project_type str 'TASK' or 'NOTE' 'TASK' folder_id str The project folder id that the project should be placed under (if desired) None Returns: Type Description dict or list Single Project : Return the dictionary of the object. Multiple Projects : Return a list of dictionaries containing all the created objects in the same order as created. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Project name already exists ValueError Project Folder corresponding to the ID does not exist. ValueError The hex string color inputted is invalid. RuntimeError The project(s) could not be created. Single Project Just A Name project = client . project . create ( 'School' ) Result # The dictionary object of the created project is returned. { 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'School' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'uerkdkcd' , 'modifiedTime' : '2021-01-12T21:36:51.890+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Our project is created. Specify a Color A random color can be generated using generate_hex_color . However, just not specifying a color will automatically generate a random color (as seen in the previous tab). You can always specify the color that you want. project = client . project . create ( 'Work' , color = '#86bb6d' ) Result Our project is created with the color specified. Changing the Project Type The default project type is for Tasks. To change the type to handle Notes, pass in the string 'NOTE' project = client . project . create ( 'Hobbies' , project_type = 'NOTE' ) Result The project type is now for notes. Creating Inside of A Folder Note For folder_id The project folder must already exist prior to calling this method. project_name = 'Day Job' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Create the object project_object = client . project . create ( project_name , folder_id = productivity_id ) Result The project was created in the group folder. Multiple Projects (batch) To create multiple projects, you will need to build the projects locally prior to calling the create method. This can be accomplished using the builder method. Pass in a list of the locally created project objects to create them remotely. (Again About Folders) The project folders should already be created prior to calling the create method. # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Names of our projects name_1 = 'Reading' name_2 = 'Writing' # Build the local projects project1 = client . project . builder ( name_1 , folder_id = productivity_id ) project2 = client . project . builder ( name_2 , folder_id = productivity_id ) project_list = [ project1 , project2 ] # Create the projects project_object = client . project . create ( project_list ) Result When multiple projects are created, the dictionaries will be returned in a list in the same order as the input. [{ 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'qbj4z0gl' , 'modifiedTime' : '2021-01-12T22:37:21.823+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe24a18f081003f3294c46' , 'name' : 'Writing' , 'isOwner' : True , 'color' : '#9730ce' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'u0loxz2v' , 'modifiedTime' : '2021-01-12T22:37:21.827+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Source code in managers/projects.py @logged_in def create ( self , name , color : str = 'random' , project_type : str = 'TASK' , folder_id : str = None ): \"\"\" Creates a project remotely. Supports single project creation or batch project creation. Arguments: name (str or list): **Single Project** (str) : The desired name of the project. Project names cannot be repeated. **Multiple Projects** (list) : A list of project objects created using the [builder][managers.projects.ProjectManager.builder] method. color: Hex color string. A random color will be generated if no color is specified. project_type: 'TASK' or 'NOTE' folder_id: The project folder id that the project should be placed under (if desired) Returns: dict or list: **Single Project**: Return the dictionary of the object. **Multiple Projects**: Return a list of dictionaries containing all the created objects in the same order as created. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Project name already exists ValueError: Project Folder corresponding to the ID does not exist. ValueError: The hex string color inputted is invalid. RuntimeError: The project(s) could not be created. !!! example \"Single Project\" === \"Just A Name\" ```python project = client.project.create('School') ``` ??? success \"Result\" ```python # The dictionary object of the created project is returned. {'id': '5ffe1673e4b062d60dd29dc0', 'name': 'School', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'uerkdkcd', 'modifiedTime': '2021-01-12T21:36:51.890+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` Our project is created. [![project-create.png](https://i.postimg.cc/d1NNqN7F/project-create.png)](https://postimg.cc/PpZQy4zV) === \"Specify a Color\" A random color can be generated using [generate_hex_color][helpers.hex_color.generate_hex_color]. However, just not specifying a color will automatically generate a random color (as seen in the previous tab). You can always specify the color that you want. ```python project = client.project.create('Work', color='#86bb6d') ``` ??? success \"Result\" Our project is created with the color specified. [![project-color.png](https://i.postimg.cc/K8ppnvrb/project-color.png)](https://postimg.cc/5XvmJJRK) === \"Changing the Project Type\" The default project type is for Tasks. To change the type to handle Notes, pass in the string 'NOTE' ```python project = client.project.create('Hobbies', project_type='NOTE') ``` ??? success \"Result\" The project type is now for notes. [![project-note.png](https://i.postimg.cc/fy0Mhrzt/project-note.png)](https://postimg.cc/rRcB1gtM) === \"Creating Inside of A Folder\" !!! warning \"Note For `folder_id`\" The project [folder][managers.projects.ProjectManager.create_folder] must already exist prior to calling this method. ```python project_name = 'Day Job' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Create the object project_object = client.project.create(project_name, folder_id=productivity_id) ``` ??? success \"Result\" The project was created in the group folder. [![project-create-with-folder.png](https://i.postimg.cc/mr53rmfN/project-create-with-folder.png)](https://postimg.cc/rd5RnCpK) !!! example \"Multiple Projects (batch)\" To create multiple projects, you will need to build the projects locally prior to calling the `create` method. This can be accomplished using the [builder][managers.projects.ProjectManager.builder] method. Pass in a list of the locally created project objects to create them remotely. !!! warning \"(Again About Folders)\" The project folders should already be created prior to calling the create method. ```python # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Names of our projects name_1 = 'Reading' name_2 = 'Writing' # Build the local projects project1 = client.project.builder(name_1, folder_id=productivity_id) project2 = client.project.builder(name_2, folder_id=productivity_id) project_list = [project1, project2] # Create the projects project_object = client.project.create(project_list) ``` ??? success \"Result\" When multiple projects are created, the dictionaries will be returned in a list in the same order as the input. ```python [{'id': '5ffe24a18f081003f3294c44', 'name': 'Reading', 'isOwner': True, 'color': '#6fcbdf', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'qbj4z0gl', 'modifiedTime': '2021-01-12T22:37:21.823+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe24a18f081003f3294c46', 'name': 'Writing', 'isOwner': True, 'color': '#9730ce', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'u0loxz2v', 'modifiedTime': '2021-01-12T22:37:21.827+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` [![project-batch-create.png](https://i.postimg.cc/8CHH8xSZ/project-batch-create.png)](https://postimg.cc/d7hdrHDC) \"\"\" if isinstance ( name , list ): # If task name is a list, we will batch create objects obj = name batch = True # Create the single project object elif isinstance ( name , str ): batch = False obj = self . builder ( name = name , color = color , project_type = project_type , folder_id = folder_id ) obj = [ obj ] else : raise TypeError ( f \"Required Positional Argument Must Be A String or List of Project Objects\" ) url = self . _client . BASE_URL + 'batch/project' payload = { 'add' : obj } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( obj ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'projects' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( obj ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'projects' ) for original in obj : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = obj . index ( original ) # Place found at the index in return list items [ index ] = found return items create_folder ( self , name ) \u00b6 Creates a project folder to allow for project grouping. Project folder names can be repeated. Parameters: Name Type Description Default name str or list Single Folder (str) : A string for the name of the folder Multiple Folders (list) : A list of strings for names of the folders. required Returns: Type Description dict or list Single Folder (dict) : A dictionary for the created folder. Multiple Folders (list) : A list of dictionaries for the created folders. Exceptions: Type Description TypeError If name is not a string or list RuntimeError If the folder(s) could not be created. Example Creating a Single Folder A single string for the name is the only parameter needed. project_folder = client . project . create_folder ( 'Productivity' ) Result A single dictionary is returned. { 'id' : '5ffe44528f089fb5795c45bf' , 'etag' : '9eun9kyc' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 115781412 , 'sortType' : 'project' , 'teamId' : None } Creating Multiple Folders The desired names of the folders are passed to create as a list. names = [ 'Productivity' , 'School' , 'Hobbies' ] project_folder = client . project . create_folder ( names ) Result A list of dictionaries containing the foler objects is returned. [{ 'id' : '5ffe45d6e4b062d60dd3ce15' , 'etag' : '4nvnuiw1' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe45d6e4b062d60dd3ce16' , 'etag' : 's072l3pu' , 'name' : 'School' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe45d6e4b062d60dd3ce17' , 'etag' : '12t1xmt9' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Source code in managers/projects.py @logged_in def create_folder ( self , name ): \"\"\" Creates a project folder to allow for project grouping. Project folder names can be repeated. Arguments: name (str or list): **Single Folder (str)**: A string for the name of the folder **Multiple Folders (list)**: A list of strings for names of the folders. Returns: dict or list: **Single Folder (dict)**: A dictionary for the created folder. **Multiple Folders (list)**: A list of dictionaries for the created folders. Raises: TypeError: If `name` is not a string or list RuntimeError: If the folder(s) could not be created. !!! example === \"Creating a Single Folder\" A single string for the name is the only parameter needed. ```python project_folder = client.project.create_folder('Productivity') ``` ??? success \"Result\" A single dictionary is returned. ```python {'id': '5ffe44528f089fb5795c45bf', 'etag': '9eun9kyc', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 115781412, 'sortType': 'project', 'teamId': None} ``` [![folder.png](https://i.postimg.cc/HWRTjtRW/folder.png)](https://postimg.cc/c6RpbfdP) === \"Creating Multiple Folders\" The desired names of the folders are passed to create as a list. ```python names = ['Productivity', 'School', 'Hobbies'] project_folder = client.project.create_folder(names) ``` ??? success \"Result\" A list of dictionaries containing the foler objects is returned. ```python [{'id': '5ffe45d6e4b062d60dd3ce15', 'etag': '4nvnuiw1', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe45d6e4b062d60dd3ce16', 'etag': 's072l3pu', 'name': 'School', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe45d6e4b062d60dd3ce17', 'etag': '12t1xmt9', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` [![folders-multiple.png](https://i.postimg.cc/2jwXKjds/folders-multiple.png)](https://postimg.cc/0rzf6sBn) \"\"\" if not isinstance ( name , str ) and not isinstance ( name , list ): raise TypeError ( 'Name Must Be A String or List Of Strings' ) objs = [] if isinstance ( name , str ): names = { 'name' : name , 'listType' : 'group' } objs = [ names ] else : for nm in name : objs . append ({ 'name' : nm , 'listType' : 'group' }) url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'add' : objs } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( objs ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'project_folders' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( objs ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'project_folders' ) for original in objs : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = objs . index ( original ) # Place found at the index in return list items [ index ] = found return items delete ( self , ids ) \u00b6 Deletes the project(s) with the passed ID string. Warning Tasks will be deleted from the project. If you want to preserve the tasks before deletion, use move_all Parameters: Name Type Description Default ids str or list Single Deletion (str) : ID string of the project Multiple Deletions (list) : List of ID strings of projects to be deleted. required Returns: Type Description dict or list Single Deletion (dict) : Dictionary of the deleted project. Multiple Deletions (list) : A list of dictionaries of the deleted projects. Exceptions: Type Description TypeError If ids is not a string or list of strings ValueError If ids does not exist. RuntimeError If the deletion was not successful. Example Single Project Deletion # Lets assume that we have a project that exists named 'School' school = client . get_by_fields ( name = 'School' , search = 'projects' ) # Get the project object project_id = school [ 'id' ] # Get the project id delete = client . project . delete ( project_id ) A dictionary of the deleted project object will be returned. Multiple Project Deletion # Lets assume that we have two projects that we want to delete: 'School' and 'Work' school = client . get_by_fields ( name = 'School' , search = 'projects' ) # Get the project object work = client . get_by_fields ( name = 'Work' , search = 'projects' ) delete_ids = [ school [ 'id' ], work [ 'id' ]] # A list of the ID strings of the projects to be deleted delete = client . project . delete ( delete_ids ) A list of the deleted dictionary objects will be returned. Source code in managers/projects.py @logged_in def delete ( self , ids ): \"\"\" Deletes the project(s) with the passed ID string. !!! warning [Tasks](tasks.md) will be deleted from the project. If you want to preserve the tasks before deletion, use [move_all][managers.tasks.TaskManager.move_all] Arguments: ids (str or list): **Single Deletion (str)**: ID string of the project **Multiple Deletions (list)**: List of ID strings of projects to be deleted. Returns: dict or list: **Single Deletion (dict)**: Dictionary of the deleted project. **Multiple Deletions (list)**: A list of dictionaries of the deleted projects. Raises: TypeError: If `ids` is not a string or list of strings ValueError: If `ids` does not exist. RuntimeError: If the deletion was not successful. !!! example === \"Single Project Deletion\" ```python # Lets assume that we have a project that exists named 'School' school = client.get_by_fields(name='School', search='projects') # Get the project object project_id = school['id'] # Get the project id delete = client.project.delete(project_id) ``` A dictionary of the deleted project object will be returned. === \"Multiple Project Deletion\" ```python # Lets assume that we have two projects that we want to delete: 'School' and 'Work' school = client.get_by_fields(name='School', search='projects') # Get the project object work = client.get_by_fields(name='Work', search='projects') delete_ids = [school['id'], work['id']] # A list of the ID strings of the projects to be deleted delete = client.project.delete(delete_ids) ``` A list of the deleted dictionary objects will be returned. \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { ids } ' Does Not Exist To Delete\" ) ids = [ ids ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { i } ' Does Not Exist To Delete\" ) # Delete the task url = self . _client . BASE_URL + 'batch/project' payload = { 'delete' : ids } self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) # Delete the list deleted_list = [] for current_id in ids : tasks = self . _client . task . get_from_project ( current_id ) for task in tasks : self . _client . delete_from_local_state ( id = task [ 'id' ], search = 'tasks' ) deleted_list . append ( self . _client . delete_from_local_state ( id = current_id , search = 'projects' )) if len ( deleted_list ) == 1 : return deleted_list [ 0 ] else : return deleted_list delete_folder ( self , ids ) \u00b6 Deletes the folder(s). Tip Any projects inside of the folder will be preserved - they will just not be grouped anymore. Parameters: Name Type Description Default ids str or list Single Folder (str) : The ID of the folder to be deleted. Multiple Folders (list) : A list containing the ID strings of the folders to be deleted. required Returns: Type Description dict or list Single Folder (dict) : The dictionary object for the deleted folder. Multiple Folders (list) : A list of dictionary objects of the deleted folders. Exceptions: Type Description TypeError If ids is not a str or list ValueError If ids does not match an actual folder object. RunTimeError If the folders could not be successfully deleted. Folder Deletion Single Folder Deletion Pass in the ID of the folder object to delete it remotely. # Lets assume we have a folder named \"Productivity\" project_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Get the project folder deleted_folder = client . project . delete_folder ( project_folder [ 'id' ]) Result The folder is deleted, and a single dictionary of the deleted folder object is returned. { 'id' : '5ffe75008f089fb5795d544a' , 'etag' : 'e95rdzi7' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None } Before After The project inside still exists. Multiple Folder Deletion Pass in the list of ID strings of the folders to be deleted. # Lets assume that we have two folders that already exist: \"Productivity\" and \"Hobbies\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) hobbies_folder = client . get_by_fields ( name = 'Hobbies' , search = 'project_folders' ) ids = [ productivity_folder [ 'id' ], hobbies_folder [ 'id' ]] deleted_folders = client . project . delete_folder ( ids ) Result The folders are deleted, and a list of dictionaries for the deleted folder objects are returned. [{ 'id' : '5ffe79d78f08237f3d1636ad' , 'etag' : '2o2dn2al' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe79d78f08237f3d1636ae' , 'etag' : 'mah5a78l' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Before After All folders deleted and all projects retained. Source code in managers/projects.py @logged_in def delete_folder ( self , ids ): \"\"\" Deletes the folder(s). !!! tip Any projects inside of the folder will be preserved - they will just not be grouped anymore. Arguments: ids (str or list): **Single Folder (str)**: The ID of the folder to be deleted. **Multiple Folders (list)**: A list containing the ID strings of the folders to be deleted. Returns: dict or list: **Single Folder (dict)**: The dictionary object for the deleted folder. **Multiple Folders (list)**: A list of dictionary objects of the deleted folders. Raises: TypeError: If `ids` is not a str or list ValueError: If `ids` does not match an actual folder object. RunTimeError: If the folders could not be successfully deleted. !!! example \"Folder Deletion\" === \"Single Folder Deletion\" Pass in the ID of the folder object to delete it remotely. ```python # Lets assume we have a folder named \"Productivity\" project_folder = client.get_by_fields(name='Productivity', search='project_folders') # Get the project folder deleted_folder = client.project.delete_folder(project_folder['id']) ``` ??? success \"Result\" The folder is deleted, and a single dictionary of the deleted folder object is returned. ```python {'id': '5ffe75008f089fb5795d544a', 'etag': 'e95rdzi7', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104407093-b5573e80-5515-11eb-99dc-16ca4f33d06a.png) **After** The project inside still exists. ![image](https://user-images.githubusercontent.com/56806733/104407123-c607b480-5515-11eb-92ff-15df1d41b404.png) === \"Multiple Folder Deletion\" Pass in the list of ID strings of the folders to be deleted. ```python # Lets assume that we have two folders that already exist: \"Productivity\" and \"Hobbies\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') hobbies_folder = client.get_by_fields(name='Hobbies', search='project_folders') ids = [productivity_folder['id'], hobbies_folder['id']] deleted_folders = client.project.delete_folder(ids) ``` ??? success \"Result\" The folders are deleted, and a list of dictionaries for the deleted folder objects are returned. ```python [{'id': '5ffe79d78f08237f3d1636ad', 'etag': '2o2dn2al', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe79d78f08237f3d1636ae', 'etag': 'mah5a78l', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104407469-8097b700-5516-11eb-9919-069e5beb3b8a.png) **After** All folders deleted and all projects retained. ![image](https://user-images.githubusercontent.com/56806733/104407546-a8871a80-5516-11eb-815b-4df41e3d797a.png) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'project_folders' ) if not proj : raise ValueError ( f \"Project Folder ' { ids } ' Does Not Exist To Delete\" ) ids = [ ids ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'project_folders' ) if not proj : raise ValueError ( f \"Project Folder ' { i } ' Does Not Exist To Delete\" ) url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'delete' : ids } self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) # Delete the list deleted_list = [] for current_id in ids : deleted_list . append ( self . _client . get_by_id ( current_id , search = 'project_folders' )) self . _client . sync () if len ( deleted_list ) == 1 : return deleted_list [ 0 ] else : return deleted_list update ( self , obj ) \u00b6 Updates the passed project(s). Supports single project update and multiple project update (batch) Make local changes to the project objects that you want to change first, then pass the actual objects to the method. Info Every potential update to a project's attributes have not been tested. See Example TickTick Project Dictionary for a listing of the fields present in a project. Parameters: Name Type Description Default obj dict or list Single Project (dict) : The project dictionary. Multiple Projects (list) : A list of project dictionaries. required Returns: Type Description dict or list Single Project (dict) : The updated project dictionary Multiple Projects (list) : A list containing the updated project dictionaries. Exceptions: Type Description TypeError If the input is not a dict or a list. RuntimeError If the projects could not be updated successfully. Updates are done by changing the fields in the objects locally first. Single Project Update Changing The Name # Lets assume that we have a project named \"Reading\" that we want to change to \"Summer Reading\" project = client . get_by_fields ( name = 'Reading' , search = 'projects' ) # Get the project # Now lets change the name project [ 'name' ] = 'Summer Reading' # Updating a single project requires just passing in the entire dictionary. updated = client . project . update ( project ) Result The dictionary is returned and the name changed remotely. { 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Summer Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : - 6236426731520 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : '0vbsvn8e' , 'modifiedTime' : '2021-01-12T23:38:16.456+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe2d37b04b35082bbcdf74' , 'viewMode' : 'list' , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Before After Multiple Project Update Changing Multiple Names # Lets assume that we have a project named \"Writing\" that we want to change to \"Summer Reading\" project = client . get_by_fields ( name = 'Writing' , search = 'projects' ) # Get the project project [ 'name' ] = 'Summer Writing' # Lets assume that we have a project named \"Movies\" that we want to change to \"Summer Movies\" movie_project = client . get_by_fields ( name = 'Movies' , search = 'projects' ) movie_project [ 'name' ] = 'Summer Movies' # Updating multiple projects requires passing the projects in a list. update_list = [ project , movie_project ] # Lets update remotely now updated_projects = client . project . update ( update_list ) Result A list containing the updated projects is returned. [{ 'id' : '5ffe24a18f081003f3294c46' , 'name' : 'Summer Reading' , 'isOwner' : True , 'color' : '#9730ce' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'bgl0pkm8' , 'modifiedTime' : '2021-01-13T00:13:29.796+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe399c8f08237f3d144ece' , 'name' : 'Summer Movies' , 'isOwner' : True , 'color' : '#F18181' , 'inAll' : True , 'sortOrder' : - 2843335458816 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'jmjy1xtc' , 'modifiedTime' : '2021-01-13T00:13:29.800+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Before After Source code in managers/projects.py @logged_in def update ( self , obj ): \"\"\" Updates the passed project(s). Supports single project update and multiple project update (batch) Make local changes to the project objects that you want to change first, then pass the actual objects to the method. !!! info Every potential update to a project's attributes have not been tested. See [Example `TickTick` Project Dictionary](projects.md#example-ticktick-project-dictionary) for a listing of the fields present in a project. Arguments: obj (dict or list): **Single Project (dict)**: The project dictionary. **Multiple Projects (list)**: A list of project dictionaries. Returns: dict or list: **Single Project (dict)**: The updated project dictionary **Multiple Projects (list)**: A list containing the updated project dictionaries. Raises: TypeError: If the input is not a dict or a list. RuntimeError: If the projects could not be updated successfully. Updates are done by changing the fields in the objects locally first. !!! example \"Single Project Update\" === \"Changing The Name\" ```python # Lets assume that we have a project named \"Reading\" that we want to change to \"Summer Reading\" project = client.get_by_fields(name='Reading', search='projects') # Get the project # Now lets change the name project['name'] = 'Summer Reading' # Updating a single project requires just passing in the entire dictionary. updated = client.project.update(project) ``` ??? success \"Result\" The dictionary is returned and the name changed remotely. ```python {'id': '5ffe24a18f081003f3294c44', 'name': 'Summer Reading', 'isOwner': True, 'color': '#6fcbdf', 'inAll': True, 'sortOrder': -6236426731520, 'sortType': 'sortOrder', 'userCount': 1, 'etag': '0vbsvn8e', 'modifiedTime': '2021-01-12T23:38:16.456+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe2d37b04b35082bbcdf74', 'viewMode': 'list', 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` **Before** [![project-update-before.png](https://i.postimg.cc/K8hcpzvP/project-update-before.png)](https://postimg.cc/crTNrd3C) **After** [![project-update-after.png](https://i.postimg.cc/DwcWqsdJ/project-update-after.png)](https://postimg.cc/FY7svY6N) !!! example \"Multiple Project Update\" === \"Changing Multiple Names\" ```python # Lets assume that we have a project named \"Writing\" that we want to change to \"Summer Reading\" project = client.get_by_fields(name='Writing', search='projects') # Get the project project['name'] = 'Summer Writing' # Lets assume that we have a project named \"Movies\" that we want to change to \"Summer Movies\" movie_project = client.get_by_fields(name='Movies', search='projects') movie_project['name'] = 'Summer Movies' # Updating multiple projects requires passing the projects in a list. update_list = [project, movie_project] # Lets update remotely now updated_projects = client.project.update(update_list) ``` ??? success \"Result\" A list containing the updated projects is returned. ```python [{'id': '5ffe24a18f081003f3294c46', 'name': 'Summer Reading', 'isOwner': True, 'color': '#9730ce', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'bgl0pkm8', 'modifiedTime': '2021-01-13T00:13:29.796+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe399c8f08237f3d144ece', 'name': 'Summer Movies', 'isOwner': True, 'color': '#F18181', 'inAll': True, 'sortOrder': -2843335458816, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'jmjy1xtc', 'modifiedTime': '2021-01-13T00:13:29.800+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` **Before** [![project-update-multiople.png](https://i.postimg.cc/9QbcJH81/project-update-multiople.png)](https://postimg.cc/zyLmG61R) **After** [![project-update-multiple-after.png](https://i.postimg.cc/3RVGNv2y/project-update-multiple-after.png)](https://postimg.cc/0MGjHrWx) \"\"\" # Check the types if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Project objects must be a dict or list of dicts.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/project' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'projects' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( obj ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'projects' ) for original in obj : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = obj . index ( original ) # Place found at the index in return list items [ index ] = found return items update_folder ( self , obj ) \u00b6 Updates the project folders(s) remotely based off changes made locally. Make the changes you want to the project folder(s) first. Parameters: Name Type Description Default obj dict or list Single Folder (dict) : The dictionary object of the folder to update. Multiple Folders (list) : A list containing dictionary objects of folders to update. required Returns: Type Description dict or list Single Folder (dict) : The dictionary object of the updated folder. Multiple Folders (list) : A list of dictionary objects corresponding to the updated folders. Exceptions: Type Description TypeError If obj is not a dictionary or list RuntimeError If the updating was unsuccessful. Updating A Project Folder Single Folder Update # Lets assume that we have a folder called \"Productivity\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Lets change the name to \"Hobbies\" productivity_folder [ 'name' ] = \"Hobbies\" # Update updated_folder = client . project . update_folder ( productivity_folder ) Result The dictionary of the updated folder is returned. { 'id' : '5ffe7dab8f089fb5795d8ef2' , 'etag' : 'r9xl60e5' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None } Before After Multiple Folder Update # Lets assume that we have a folder called \"Productivity\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Lets assume that we have another folder called \"Games\" games_folder = client . get_by_fields ( name = 'Games' , search = 'project_folders' ) # Lets change the \"Productivity\" folder to \"Work\" productivity_folder [ 'name' ] = \"Work\" # Lets change the \"Games\" folder to \"Hobbies\" games_folder [ 'name' ] = \"Hobbies\" update_list = [ productivity_folder , games_folder ] # List of objects to update # Update updated_folder = client . project . update_folder ( update_list ) Result A list of the updated folder objects is returned. [{ 'id' : '5ffe80ce8f08068e86aab288' , 'etag' : '0oh0pxel' , 'name' : 'Work' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe80cf8f08068e86aab289' , 'etag' : 'xwvehtfo' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Before After Source code in managers/projects.py @logged_in def update_folder ( self , obj ): \"\"\" Updates the project folders(s) remotely based off changes made locally. Make the changes you want to the project folder(s) first. Arguments: obj (dict or list): **Single Folder (dict)**: The dictionary object of the folder to update. **Multiple Folders (list)**: A list containing dictionary objects of folders to update. Returns: dict or list: **Single Folder (dict)**: The dictionary object of the updated folder. **Multiple Folders (list)**: A list of dictionary objects corresponding to the updated folders. Raises: TypeError: If `obj` is not a dictionary or list RuntimeError: If the updating was unsuccessful. !!! example \"Updating A Project Folder\" === \"Single Folder Update\" ```python # Lets assume that we have a folder called \"Productivity\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') # Lets change the name to \"Hobbies\" productivity_folder['name'] = \"Hobbies\" # Update updated_folder = client.project.update_folder(productivity_folder) ``` ??? success \"Result\" The dictionary of the updated folder is returned. ```python {'id': '5ffe7dab8f089fb5795d8ef2', 'etag': 'r9xl60e5', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104408388-c48bbb80-5518-11eb-80d4-34e82bbaffd7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104408436-e1c08a00-5518-11eb-953a-4933f407e4f9.png) === \"Multiple Folder Update\" ```python # Lets assume that we have a folder called \"Productivity\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') # Lets assume that we have another folder called \"Games\" games_folder = client.get_by_fields(name='Games', search='project_folders') # Lets change the \"Productivity\" folder to \"Work\" productivity_folder['name'] = \"Work\" # Lets change the \"Games\" folder to \"Hobbies\" games_folder['name'] = \"Hobbies\" update_list = [productivity_folder, games_folder] # List of objects to update # Update updated_folder = client.project.update_folder(update_list) ``` ??? success \"Result\" A list of the updated folder objects is returned. ```python [{'id': '5ffe80ce8f08068e86aab288', 'etag': '0oh0pxel', 'name': 'Work', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe80cf8f08068e86aab289', 'etag': 'xwvehtfo', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104409143-75468a80-551a-11eb-96c8-5953c97d6f6a.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104409181-8bece180-551a-11eb-8424-9f147d85eb80.png) \"\"\" # Check the types if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Project objects must be a dict or list of dicts.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'project_folders' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( tasks ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'project_folders' ) for original in tasks : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = tasks . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"Projects"},{"location":"usage/projects/#example-ticktick-project-dictionary","text":"Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the project '5ffe93f3b04b35082bbce7b0' str N/A name The name of the project 'Hobbies' str N/A isOwner Whether you are the owner of the project or not. True bool N/A color The hex color code for the project. '#6fcbdf' str N/A inAll N/A True bool N/A sortOrder A sort ID relative to other tasks in the project -1099511627776 int Lower sortOrder == Higher Position sortType Sort type of the project dueDate str dueDate , sortOrder , title , tag , priority userCount How many users have access to the project. 1 int N/A etag Etag identifier. 'ji35exmv' str N/A modifiedTime Time last modified. '2021-01-13T07:18:21.000+0000' str N/A closed Archive status. False bool none and False = Not Archived, True = Archived muted Whether the project is 'hidden' (no notifications) False bool N/A transferred Possibly if the ownership of the project has changed. None bool N/A groupId ID of the project folder if it exists. '5ffe11b7b04b356ce74d49da' str N/A viewMode View mode of the project. 'kanban' str kanban or list notificationOptions N/A None N/A N/A teamId ID of your team. 342537403 int N/A permission N/A None N/A N/A kind If the project is a normal TASK project or NOTE project 'TASK' str 'TASK' or 'NOTE' { 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'qbj4z0gl' , 'modifiedTime' : '2021-01-12T22:37:21.823+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }","title":"Example TickTick Project Dictionary"},{"location":"usage/projects/#example-ticktick-project-folder-group-dictionary","text":"Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the project folder '5ffe93f3b04b35082bbce7b0' str N/A etag Etag identifier. 'ji35exmv' str N/A name The name of the project folder 'Hobbies' str N/A showAll N/A True bool N/A sortOrder A sort ID relative to other tasks in the project -1099511627776 int Lower sortOrder == Higher Position deleted Whether the project folder is deleted or not. 0 int N/A userId User ID of the creator 586938759 int N/A sortType Sort type of the project folder dueDate str dueDate , project , title , tag , priority teamId ID of your team. 342537403 int N/A { 'id' : '600008f2b04b355792c7a42d' , 'etag' : 'yeozz5v8' , 'name' : 'Test' , 'showAll' : True , 'sortOrder' : - 6786182545408 , 'deleted' : 0 , 'userId' : 586934829 , 'sortType' : 'project' , 'teamId' : None }","title":"Example TickTick Project Folder (group) Dictionary"},{"location":"usage/projects/#managers.projects.ProjectManager","text":"Handles all interactions for projects.","title":"ProjectManager"},{"location":"usage/projects/#managers.projects.ProjectManager.archive","text":"Moves the project(s) to a project folder created by TickTick called \"Archived Lists\" To unarchive a project, change its 'closed' field to True , then update Parameters: Name Type Description Default ids str or list Single Project (str) : ID string of the project to archive. Multiple Projects (list) : List of ID strings of the projects to archive. required Returns: Type Description dict or list Single Project (dict) : Dictionary of the archived object. Multiple Projects (list) : List of dictionaries of the archived objects. Exceptions: Type Description TypeError If ids is not a string or list. ValueError If the project(s) don't already exist RuntimeError If the project(s) could not be successfully archived. Example Single Project Archive # Lets assume there is a project that exists named \"Reading\" reading_project = client . get_by_fields ( name = \"Reading\" , search = \"projects\" ) reading_project_id = reading_project [ 'id' ] archived = client . project . archive ( reading_project_id ) Result A single dictionary is returned. { 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'c9tgze9b' , 'modifiedTime' : '2021-01-13T00:34:50.449+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Before After Multiple Project Archive # Lets assume there is a project that exists named \"Reading\" reading_project = client . get_by_fields ( name = \"Reading\" , search = \"projects\" ) reading_project_id = reading_project [ 'id' ] # Lets assume another project exists named \"Writing\" writing_project = client . get_by_fields ( name = 'Writing' , search = 'projects' ) writing_project_id = writing_project [ 'id' ] # Archiving multiple requires putting the ID's in a list. archive_list = [ reading_project_id , writing_project_id ] archived = client . project . archive ( archive_list ) Result A list of dictionary objects is returned. [{ 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : - 7335938359296 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'qrga45as' , 'modifiedTime' : '2021-01-13T00:40:49.839+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe41328f08237f3d147e33' , 'name' : 'Writing' , 'isOwner' : True , 'color' : '#F2B04B' , 'inAll' : True , 'sortOrder' : - 7885694173184 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'aenkajam' , 'modifiedTime' : '2021-01-13T00:40:49.843+0000' , 'closed' : True , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Before After Source code in managers/projects.py @logged_in def archive ( self , ids ): \"\"\" Moves the project(s) to a project folder created by `TickTick` called \"Archived Lists\" To unarchive a project, change its `'closed'` field to `True`, then [update][managers.projects.ProjectManager.update] Arguments: ids (str or list): **Single Project (str)**: ID string of the project to archive. **Multiple Projects (list)**: List of ID strings of the projects to archive. Returns: dict or list: **Single Project (dict)**: Dictionary of the archived object. **Multiple Projects (list)**: List of dictionaries of the archived objects. Raises: TypeError: If `ids` is not a string or list. ValueError: If the project(s) don't already exist RuntimeError: If the project(s) could not be successfully archived. !!! example === \"Single Project Archive\" ```python # Lets assume there is a project that exists named \"Reading\" reading_project = client.get_by_fields(name=\"Reading\", search=\"projects\") reading_project_id = reading_project['id'] archived = client.project.archive(reading_project_id) ``` ??? success \"Result\" A single dictionary is returned. ```python {'id': '5ffe1673e4b062d60dd29dc0', 'name': 'Reading', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': 0, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'c9tgze9b', 'modifiedTime': '2021-01-13T00:34:50.449+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` **Before** [![archive-before.png](https://i.postimg.cc/R0jfVt7W/archive-before.png)](https://postimg.cc/B8BtmXw3) **After** [![archived-after.png](https://i.postimg.cc/xjPkBh4J/archived-after.png)](https://postimg.cc/K4RvMqFx) === \"Multiple Project Archive\" ```python # Lets assume there is a project that exists named \"Reading\" reading_project = client.get_by_fields(name=\"Reading\", search=\"projects\") reading_project_id = reading_project['id'] # Lets assume another project exists named \"Writing\" writing_project = client.get_by_fields(name='Writing', search='projects') writing_project_id = writing_project['id'] # Archiving multiple requires putting the ID's in a list. archive_list = [reading_project_id, writing_project_id] archived = client.project.archive(archive_list) ``` ??? success \"Result\" A list of dictionary objects is returned. ```python [{'id': '5ffe1673e4b062d60dd29dc0', 'name': 'Reading', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': -7335938359296, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'qrga45as', 'modifiedTime': '2021-01-13T00:40:49.839+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe41328f08237f3d147e33', 'name': 'Writing', 'isOwner': True, 'color': '#F2B04B', 'inAll': True, 'sortOrder': -7885694173184, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'aenkajam', 'modifiedTime': '2021-01-13T00:40:49.843+0000', 'closed': True, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` **Before** [![archive-multiple-before.png](https://i.postimg.cc/sgHHmnrb/archive-multiple-before.png)](https://postimg.cc/qNnGMxgG) **After** [![archived-multiple-after.png](https://i.postimg.cc/tg1SMhRJ/archived-multiple-after.png)](https://postimg.cc/rdkNdRr2) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) objs = [] if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { ids } ' Does Not Exist To Archive\" ) # Change the list to archived proj [ 'closed' ] = True objs = [ proj ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { i } ' Does Not Exist To Archive\" ) proj [ 'closed' ] = True objs . append ( proj ) return self . update ( objs )","title":"archive()"},{"location":"usage/projects/#managers.projects.ProjectManager.builder","text":"Creates and returns a local project object. Helper method for create to make batch creating projects easier. Note The project folder must already exist prior to calling this method. Parameters: Name Type Description Default name str Desired name of the project - project names cannot be repeated required color str Hex color string. A random color will be generated if no color is specified. 'random' project_type str 'TASK' or 'NOTE' 'TASK' folder_id str The project folder id that the project should be placed under (if desired) None Returns: Type Description dict A dictionary containing all the fields necessary to create a remote project. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Project name already exists ValueError Project Folder corresponding to the ID does not exist. ValueError The hex string color inputted is invalid. Argument rules are shared with create , so for more examples on how to use the arguments see that method. Example project_name = 'Work' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Build the object project_object = client . project . builder ( project_name , folder_id = productivity_id ) Result # The fields needed for a successful project creation are set. { 'name' : 'Work' , 'color' : '#665122' , 'kind' : 'TASK' , 'groupId' : '5ffe11b7b04b356ce74d49da' } Source code in managers/projects.py @logged_in def builder ( self , name : str , color : str = 'random' , project_type : str = 'TASK' , folder_id : str = None ) -> dict : \"\"\" Creates and returns a local project object. Helper method for [create][managers.projects.ProjectManager.create] to make batch creating projects easier. !!! note The project [folder][managers.projects.ProjectManager.create_folder] must already exist prior to calling this method. Arguments: name: Desired name of the project - project names cannot be repeated color: Hex color string. A random color will be generated if no color is specified. project_type: 'TASK' or 'NOTE' folder_id: The project folder id that the project should be placed under (if desired) Returns: A dictionary containing all the fields necessary to create a remote project. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Project name already exists ValueError: Project Folder corresponding to the ID does not exist. ValueError: The hex string color inputted is invalid. Argument rules are shared with [create][managers.projects.ProjectManager.create], so for more examples on how to use the arguments see that method. !!! example ```python project_name = 'Work' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Build the object project_object = client.project.builder(project_name, folder_id=productivity_id) ``` ??? success \"Result\" ```python # The fields needed for a successful project creation are set. {'name': 'Work', 'color': '#665122', 'kind': 'TASK', 'groupId': '5ffe11b7b04b356ce74d49da'} ``` \"\"\" if not isinstance ( name , str ): raise TypeError ( \"Name must be a string\" ) if not isinstance ( color , str ) and color is not None : raise TypeError ( \"Color must be a string\" ) if not isinstance ( project_type , str ): raise TypeError ( \"Project type must be a string\" ) if not isinstance ( folder_id , str ) and folder_id is not None : raise TypeError ( \"Folder id must be a string\" ) # Go through self.state['lists'] and determine if the name already exists id_list = self . _client . get_by_fields ( search = 'projects' , name = name ) if id_list : raise ValueError ( f \"Invalid Project Name ' { name } ' -> It Already Exists\" ) # Determine if parent list exists if folder_id is not None : parent = self . _client . get_by_id ( folder_id , search = 'project_folders' ) if not parent : raise ValueError ( f \"Parent Id { folder_id } Does Not Exist\" ) # Make sure project type is valid if project_type != 'TASK' and project_type != 'NOTE' : raise ValueError ( f \"Invalid Project Type ' { project_type } ' -> Should be 'TASK' or 'NOTE'\" ) # Check color_id if color == 'random' : color = generate_hex_color () # Random color will be generated elif color is not None : if not check_hex_color ( color ): raise ValueError ( 'Invalid Hex Color String' ) return { 'name' : name , 'color' : color , 'kind' : project_type , 'groupId' : folder_id }","title":"builder()"},{"location":"usage/projects/#managers.projects.ProjectManager.create","text":"Creates a project remotely. Supports single project creation or batch project creation. Parameters: Name Type Description Default name str or list Single Project (str) : The desired name of the project. Project names cannot be repeated. Multiple Projects (list) : A list of project objects created using the builder method. required color str Hex color string. A random color will be generated if no color is specified. 'random' project_type str 'TASK' or 'NOTE' 'TASK' folder_id str The project folder id that the project should be placed under (if desired) None Returns: Type Description dict or list Single Project : Return the dictionary of the object. Multiple Projects : Return a list of dictionaries containing all the created objects in the same order as created. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Project name already exists ValueError Project Folder corresponding to the ID does not exist. ValueError The hex string color inputted is invalid. RuntimeError The project(s) could not be created. Single Project Just A Name project = client . project . create ( 'School' ) Result # The dictionary object of the created project is returned. { 'id' : '5ffe1673e4b062d60dd29dc0' , 'name' : 'School' , 'isOwner' : True , 'color' : '#51b9e3' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'uerkdkcd' , 'modifiedTime' : '2021-01-12T21:36:51.890+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : None , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Our project is created. Specify a Color A random color can be generated using generate_hex_color . However, just not specifying a color will automatically generate a random color (as seen in the previous tab). You can always specify the color that you want. project = client . project . create ( 'Work' , color = '#86bb6d' ) Result Our project is created with the color specified. Changing the Project Type The default project type is for Tasks. To change the type to handle Notes, pass in the string 'NOTE' project = client . project . create ( 'Hobbies' , project_type = 'NOTE' ) Result The project type is now for notes. Creating Inside of A Folder Note For folder_id The project folder must already exist prior to calling this method. project_name = 'Day Job' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Create the object project_object = client . project . create ( project_name , folder_id = productivity_id ) Result The project was created in the group folder. Multiple Projects (batch) To create multiple projects, you will need to build the projects locally prior to calling the create method. This can be accomplished using the builder method. Pass in a list of the locally created project objects to create them remotely. (Again About Folders) The project folders should already be created prior to calling the create method. # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) productivity_id = productivity_folder [ 'id' ] # Names of our projects name_1 = 'Reading' name_2 = 'Writing' # Build the local projects project1 = client . project . builder ( name_1 , folder_id = productivity_id ) project2 = client . project . builder ( name_2 , folder_id = productivity_id ) project_list = [ project1 , project2 ] # Create the projects project_object = client . project . create ( project_list ) Result When multiple projects are created, the dictionaries will be returned in a list in the same order as the input. [{ 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'qbj4z0gl' , 'modifiedTime' : '2021-01-12T22:37:21.823+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe24a18f081003f3294c46' , 'name' : 'Writing' , 'isOwner' : True , 'color' : '#9730ce' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'u0loxz2v' , 'modifiedTime' : '2021-01-12T22:37:21.827+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Source code in managers/projects.py @logged_in def create ( self , name , color : str = 'random' , project_type : str = 'TASK' , folder_id : str = None ): \"\"\" Creates a project remotely. Supports single project creation or batch project creation. Arguments: name (str or list): **Single Project** (str) : The desired name of the project. Project names cannot be repeated. **Multiple Projects** (list) : A list of project objects created using the [builder][managers.projects.ProjectManager.builder] method. color: Hex color string. A random color will be generated if no color is specified. project_type: 'TASK' or 'NOTE' folder_id: The project folder id that the project should be placed under (if desired) Returns: dict or list: **Single Project**: Return the dictionary of the object. **Multiple Projects**: Return a list of dictionaries containing all the created objects in the same order as created. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Project name already exists ValueError: Project Folder corresponding to the ID does not exist. ValueError: The hex string color inputted is invalid. RuntimeError: The project(s) could not be created. !!! example \"Single Project\" === \"Just A Name\" ```python project = client.project.create('School') ``` ??? success \"Result\" ```python # The dictionary object of the created project is returned. {'id': '5ffe1673e4b062d60dd29dc0', 'name': 'School', 'isOwner': True, 'color': '#51b9e3', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'uerkdkcd', 'modifiedTime': '2021-01-12T21:36:51.890+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': None, 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` Our project is created. [![project-create.png](https://i.postimg.cc/d1NNqN7F/project-create.png)](https://postimg.cc/PpZQy4zV) === \"Specify a Color\" A random color can be generated using [generate_hex_color][helpers.hex_color.generate_hex_color]. However, just not specifying a color will automatically generate a random color (as seen in the previous tab). You can always specify the color that you want. ```python project = client.project.create('Work', color='#86bb6d') ``` ??? success \"Result\" Our project is created with the color specified. [![project-color.png](https://i.postimg.cc/K8ppnvrb/project-color.png)](https://postimg.cc/5XvmJJRK) === \"Changing the Project Type\" The default project type is for Tasks. To change the type to handle Notes, pass in the string 'NOTE' ```python project = client.project.create('Hobbies', project_type='NOTE') ``` ??? success \"Result\" The project type is now for notes. [![project-note.png](https://i.postimg.cc/fy0Mhrzt/project-note.png)](https://postimg.cc/rRcB1gtM) === \"Creating Inside of A Folder\" !!! warning \"Note For `folder_id`\" The project [folder][managers.projects.ProjectManager.create_folder] must already exist prior to calling this method. ```python project_name = 'Day Job' # The name of our project # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Create the object project_object = client.project.create(project_name, folder_id=productivity_id) ``` ??? success \"Result\" The project was created in the group folder. [![project-create-with-folder.png](https://i.postimg.cc/mr53rmfN/project-create-with-folder.png)](https://postimg.cc/rd5RnCpK) !!! example \"Multiple Projects (batch)\" To create multiple projects, you will need to build the projects locally prior to calling the `create` method. This can be accomplished using the [builder][managers.projects.ProjectManager.builder] method. Pass in a list of the locally created project objects to create them remotely. !!! warning \"(Again About Folders)\" The project folders should already be created prior to calling the create method. ```python # Lets assume that we have a project group folder that already exists named 'Productivity' productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') productivity_id = productivity_folder['id'] # Names of our projects name_1 = 'Reading' name_2 = 'Writing' # Build the local projects project1 = client.project.builder(name_1, folder_id=productivity_id) project2 = client.project.builder(name_2, folder_id=productivity_id) project_list = [project1, project2] # Create the projects project_object = client.project.create(project_list) ``` ??? success \"Result\" When multiple projects are created, the dictionaries will be returned in a list in the same order as the input. ```python [{'id': '5ffe24a18f081003f3294c44', 'name': 'Reading', 'isOwner': True, 'color': '#6fcbdf', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'qbj4z0gl', 'modifiedTime': '2021-01-12T22:37:21.823+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe24a18f081003f3294c46', 'name': 'Writing', 'isOwner': True, 'color': '#9730ce', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'u0loxz2v', 'modifiedTime': '2021-01-12T22:37:21.827+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` [![project-batch-create.png](https://i.postimg.cc/8CHH8xSZ/project-batch-create.png)](https://postimg.cc/d7hdrHDC) \"\"\" if isinstance ( name , list ): # If task name is a list, we will batch create objects obj = name batch = True # Create the single project object elif isinstance ( name , str ): batch = False obj = self . builder ( name = name , color = color , project_type = project_type , folder_id = folder_id ) obj = [ obj ] else : raise TypeError ( f \"Required Positional Argument Must Be A String or List of Project Objects\" ) url = self . _client . BASE_URL + 'batch/project' payload = { 'add' : obj } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( obj ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'projects' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( obj ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'projects' ) for original in obj : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = obj . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"create()"},{"location":"usage/projects/#managers.projects.ProjectManager.create_folder","text":"Creates a project folder to allow for project grouping. Project folder names can be repeated. Parameters: Name Type Description Default name str or list Single Folder (str) : A string for the name of the folder Multiple Folders (list) : A list of strings for names of the folders. required Returns: Type Description dict or list Single Folder (dict) : A dictionary for the created folder. Multiple Folders (list) : A list of dictionaries for the created folders. Exceptions: Type Description TypeError If name is not a string or list RuntimeError If the folder(s) could not be created. Example Creating a Single Folder A single string for the name is the only parameter needed. project_folder = client . project . create_folder ( 'Productivity' ) Result A single dictionary is returned. { 'id' : '5ffe44528f089fb5795c45bf' , 'etag' : '9eun9kyc' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 115781412 , 'sortType' : 'project' , 'teamId' : None } Creating Multiple Folders The desired names of the folders are passed to create as a list. names = [ 'Productivity' , 'School' , 'Hobbies' ] project_folder = client . project . create_folder ( names ) Result A list of dictionaries containing the foler objects is returned. [{ 'id' : '5ffe45d6e4b062d60dd3ce15' , 'etag' : '4nvnuiw1' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe45d6e4b062d60dd3ce16' , 'etag' : 's072l3pu' , 'name' : 'School' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe45d6e4b062d60dd3ce17' , 'etag' : '12t1xmt9' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Source code in managers/projects.py @logged_in def create_folder ( self , name ): \"\"\" Creates a project folder to allow for project grouping. Project folder names can be repeated. Arguments: name (str or list): **Single Folder (str)**: A string for the name of the folder **Multiple Folders (list)**: A list of strings for names of the folders. Returns: dict or list: **Single Folder (dict)**: A dictionary for the created folder. **Multiple Folders (list)**: A list of dictionaries for the created folders. Raises: TypeError: If `name` is not a string or list RuntimeError: If the folder(s) could not be created. !!! example === \"Creating a Single Folder\" A single string for the name is the only parameter needed. ```python project_folder = client.project.create_folder('Productivity') ``` ??? success \"Result\" A single dictionary is returned. ```python {'id': '5ffe44528f089fb5795c45bf', 'etag': '9eun9kyc', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 115781412, 'sortType': 'project', 'teamId': None} ``` [![folder.png](https://i.postimg.cc/HWRTjtRW/folder.png)](https://postimg.cc/c6RpbfdP) === \"Creating Multiple Folders\" The desired names of the folders are passed to create as a list. ```python names = ['Productivity', 'School', 'Hobbies'] project_folder = client.project.create_folder(names) ``` ??? success \"Result\" A list of dictionaries containing the foler objects is returned. ```python [{'id': '5ffe45d6e4b062d60dd3ce15', 'etag': '4nvnuiw1', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe45d6e4b062d60dd3ce16', 'etag': 's072l3pu', 'name': 'School', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe45d6e4b062d60dd3ce17', 'etag': '12t1xmt9', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` [![folders-multiple.png](https://i.postimg.cc/2jwXKjds/folders-multiple.png)](https://postimg.cc/0rzf6sBn) \"\"\" if not isinstance ( name , str ) and not isinstance ( name , list ): raise TypeError ( 'Name Must Be A String or List Of Strings' ) objs = [] if isinstance ( name , str ): names = { 'name' : name , 'listType' : 'group' } objs = [ names ] else : for nm in name : objs . append ({ 'name' : nm , 'listType' : 'group' }) url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'add' : objs } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( objs ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'project_folders' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( objs ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'project_folders' ) for original in objs : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = objs . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"create_folder()"},{"location":"usage/projects/#managers.projects.ProjectManager.delete","text":"Deletes the project(s) with the passed ID string. Warning Tasks will be deleted from the project. If you want to preserve the tasks before deletion, use move_all Parameters: Name Type Description Default ids str or list Single Deletion (str) : ID string of the project Multiple Deletions (list) : List of ID strings of projects to be deleted. required Returns: Type Description dict or list Single Deletion (dict) : Dictionary of the deleted project. Multiple Deletions (list) : A list of dictionaries of the deleted projects. Exceptions: Type Description TypeError If ids is not a string or list of strings ValueError If ids does not exist. RuntimeError If the deletion was not successful. Example Single Project Deletion # Lets assume that we have a project that exists named 'School' school = client . get_by_fields ( name = 'School' , search = 'projects' ) # Get the project object project_id = school [ 'id' ] # Get the project id delete = client . project . delete ( project_id ) A dictionary of the deleted project object will be returned. Multiple Project Deletion # Lets assume that we have two projects that we want to delete: 'School' and 'Work' school = client . get_by_fields ( name = 'School' , search = 'projects' ) # Get the project object work = client . get_by_fields ( name = 'Work' , search = 'projects' ) delete_ids = [ school [ 'id' ], work [ 'id' ]] # A list of the ID strings of the projects to be deleted delete = client . project . delete ( delete_ids ) A list of the deleted dictionary objects will be returned. Source code in managers/projects.py @logged_in def delete ( self , ids ): \"\"\" Deletes the project(s) with the passed ID string. !!! warning [Tasks](tasks.md) will be deleted from the project. If you want to preserve the tasks before deletion, use [move_all][managers.tasks.TaskManager.move_all] Arguments: ids (str or list): **Single Deletion (str)**: ID string of the project **Multiple Deletions (list)**: List of ID strings of projects to be deleted. Returns: dict or list: **Single Deletion (dict)**: Dictionary of the deleted project. **Multiple Deletions (list)**: A list of dictionaries of the deleted projects. Raises: TypeError: If `ids` is not a string or list of strings ValueError: If `ids` does not exist. RuntimeError: If the deletion was not successful. !!! example === \"Single Project Deletion\" ```python # Lets assume that we have a project that exists named 'School' school = client.get_by_fields(name='School', search='projects') # Get the project object project_id = school['id'] # Get the project id delete = client.project.delete(project_id) ``` A dictionary of the deleted project object will be returned. === \"Multiple Project Deletion\" ```python # Lets assume that we have two projects that we want to delete: 'School' and 'Work' school = client.get_by_fields(name='School', search='projects') # Get the project object work = client.get_by_fields(name='Work', search='projects') delete_ids = [school['id'], work['id']] # A list of the ID strings of the projects to be deleted delete = client.project.delete(delete_ids) ``` A list of the deleted dictionary objects will be returned. \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { ids } ' Does Not Exist To Delete\" ) ids = [ ids ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'projects' ) if not proj : raise ValueError ( f \"Project ' { i } ' Does Not Exist To Delete\" ) # Delete the task url = self . _client . BASE_URL + 'batch/project' payload = { 'delete' : ids } self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) # Delete the list deleted_list = [] for current_id in ids : tasks = self . _client . task . get_from_project ( current_id ) for task in tasks : self . _client . delete_from_local_state ( id = task [ 'id' ], search = 'tasks' ) deleted_list . append ( self . _client . delete_from_local_state ( id = current_id , search = 'projects' )) if len ( deleted_list ) == 1 : return deleted_list [ 0 ] else : return deleted_list","title":"delete()"},{"location":"usage/projects/#managers.projects.ProjectManager.delete_folder","text":"Deletes the folder(s). Tip Any projects inside of the folder will be preserved - they will just not be grouped anymore. Parameters: Name Type Description Default ids str or list Single Folder (str) : The ID of the folder to be deleted. Multiple Folders (list) : A list containing the ID strings of the folders to be deleted. required Returns: Type Description dict or list Single Folder (dict) : The dictionary object for the deleted folder. Multiple Folders (list) : A list of dictionary objects of the deleted folders. Exceptions: Type Description TypeError If ids is not a str or list ValueError If ids does not match an actual folder object. RunTimeError If the folders could not be successfully deleted. Folder Deletion Single Folder Deletion Pass in the ID of the folder object to delete it remotely. # Lets assume we have a folder named \"Productivity\" project_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Get the project folder deleted_folder = client . project . delete_folder ( project_folder [ 'id' ]) Result The folder is deleted, and a single dictionary of the deleted folder object is returned. { 'id' : '5ffe75008f089fb5795d544a' , 'etag' : 'e95rdzi7' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None } Before After The project inside still exists. Multiple Folder Deletion Pass in the list of ID strings of the folders to be deleted. # Lets assume that we have two folders that already exist: \"Productivity\" and \"Hobbies\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) hobbies_folder = client . get_by_fields ( name = 'Hobbies' , search = 'project_folders' ) ids = [ productivity_folder [ 'id' ], hobbies_folder [ 'id' ]] deleted_folders = client . project . delete_folder ( ids ) Result The folders are deleted, and a list of dictionaries for the deleted folder objects are returned. [{ 'id' : '5ffe79d78f08237f3d1636ad' , 'etag' : '2o2dn2al' , 'name' : 'Productivity' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe79d78f08237f3d1636ae' , 'etag' : 'mah5a78l' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Before After All folders deleted and all projects retained. Source code in managers/projects.py @logged_in def delete_folder ( self , ids ): \"\"\" Deletes the folder(s). !!! tip Any projects inside of the folder will be preserved - they will just not be grouped anymore. Arguments: ids (str or list): **Single Folder (str)**: The ID of the folder to be deleted. **Multiple Folders (list)**: A list containing the ID strings of the folders to be deleted. Returns: dict or list: **Single Folder (dict)**: The dictionary object for the deleted folder. **Multiple Folders (list)**: A list of dictionary objects of the deleted folders. Raises: TypeError: If `ids` is not a str or list ValueError: If `ids` does not match an actual folder object. RunTimeError: If the folders could not be successfully deleted. !!! example \"Folder Deletion\" === \"Single Folder Deletion\" Pass in the ID of the folder object to delete it remotely. ```python # Lets assume we have a folder named \"Productivity\" project_folder = client.get_by_fields(name='Productivity', search='project_folders') # Get the project folder deleted_folder = client.project.delete_folder(project_folder['id']) ``` ??? success \"Result\" The folder is deleted, and a single dictionary of the deleted folder object is returned. ```python {'id': '5ffe75008f089fb5795d544a', 'etag': 'e95rdzi7', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104407093-b5573e80-5515-11eb-99dc-16ca4f33d06a.png) **After** The project inside still exists. ![image](https://user-images.githubusercontent.com/56806733/104407123-c607b480-5515-11eb-92ff-15df1d41b404.png) === \"Multiple Folder Deletion\" Pass in the list of ID strings of the folders to be deleted. ```python # Lets assume that we have two folders that already exist: \"Productivity\" and \"Hobbies\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') hobbies_folder = client.get_by_fields(name='Hobbies', search='project_folders') ids = [productivity_folder['id'], hobbies_folder['id']] deleted_folders = client.project.delete_folder(ids) ``` ??? success \"Result\" The folders are deleted, and a list of dictionaries for the deleted folder objects are returned. ```python [{'id': '5ffe79d78f08237f3d1636ad', 'etag': '2o2dn2al', 'name': 'Productivity', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe79d78f08237f3d1636ae', 'etag': 'mah5a78l', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104407469-8097b700-5516-11eb-9919-069e5beb3b8a.png) **After** All folders deleted and all projects retained. ![image](https://user-images.githubusercontent.com/56806733/104407546-a8871a80-5516-11eb-815b-4df41e3d797a.png) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) if isinstance ( ids , str ): proj = self . _client . get_by_fields ( id = ids , search = 'project_folders' ) if not proj : raise ValueError ( f \"Project Folder ' { ids } ' Does Not Exist To Delete\" ) ids = [ ids ] else : for i in ids : proj = self . _client . get_by_fields ( id = i , search = 'project_folders' ) if not proj : raise ValueError ( f \"Project Folder ' { i } ' Does Not Exist To Delete\" ) url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'delete' : ids } self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) # Delete the list deleted_list = [] for current_id in ids : deleted_list . append ( self . _client . get_by_id ( current_id , search = 'project_folders' )) self . _client . sync () if len ( deleted_list ) == 1 : return deleted_list [ 0 ] else : return deleted_list","title":"delete_folder()"},{"location":"usage/projects/#managers.projects.ProjectManager.update","text":"Updates the passed project(s). Supports single project update and multiple project update (batch) Make local changes to the project objects that you want to change first, then pass the actual objects to the method. Info Every potential update to a project's attributes have not been tested. See Example TickTick Project Dictionary for a listing of the fields present in a project. Parameters: Name Type Description Default obj dict or list Single Project (dict) : The project dictionary. Multiple Projects (list) : A list of project dictionaries. required Returns: Type Description dict or list Single Project (dict) : The updated project dictionary Multiple Projects (list) : A list containing the updated project dictionaries. Exceptions: Type Description TypeError If the input is not a dict or a list. RuntimeError If the projects could not be updated successfully. Updates are done by changing the fields in the objects locally first. Single Project Update Changing The Name # Lets assume that we have a project named \"Reading\" that we want to change to \"Summer Reading\" project = client . get_by_fields ( name = 'Reading' , search = 'projects' ) # Get the project # Now lets change the name project [ 'name' ] = 'Summer Reading' # Updating a single project requires just passing in the entire dictionary. updated = client . project . update ( project ) Result The dictionary is returned and the name changed remotely. { 'id' : '5ffe24a18f081003f3294c44' , 'name' : 'Summer Reading' , 'isOwner' : True , 'color' : '#6fcbdf' , 'inAll' : True , 'sortOrder' : - 6236426731520 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : '0vbsvn8e' , 'modifiedTime' : '2021-01-12T23:38:16.456+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe2d37b04b35082bbcdf74' , 'viewMode' : 'list' , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' } Before After Multiple Project Update Changing Multiple Names # Lets assume that we have a project named \"Writing\" that we want to change to \"Summer Reading\" project = client . get_by_fields ( name = 'Writing' , search = 'projects' ) # Get the project project [ 'name' ] = 'Summer Writing' # Lets assume that we have a project named \"Movies\" that we want to change to \"Summer Movies\" movie_project = client . get_by_fields ( name = 'Movies' , search = 'projects' ) movie_project [ 'name' ] = 'Summer Movies' # Updating multiple projects requires passing the projects in a list. update_list = [ project , movie_project ] # Lets update remotely now updated_projects = client . project . update ( update_list ) Result A list containing the updated projects is returned. [{ 'id' : '5ffe24a18f081003f3294c46' , 'name' : 'Summer Reading' , 'isOwner' : True , 'color' : '#9730ce' , 'inAll' : True , 'sortOrder' : 0 , 'sortType' : None , 'userCount' : 1 , 'etag' : 'bgl0pkm8' , 'modifiedTime' : '2021-01-13T00:13:29.796+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }, { 'id' : '5ffe399c8f08237f3d144ece' , 'name' : 'Summer Movies' , 'isOwner' : True , 'color' : '#F18181' , 'inAll' : True , 'sortOrder' : - 2843335458816 , 'sortType' : 'sortOrder' , 'userCount' : 1 , 'etag' : 'jmjy1xtc' , 'modifiedTime' : '2021-01-13T00:13:29.800+0000' , 'closed' : None , 'muted' : False , 'transferred' : None , 'groupId' : '5ffe11b7b04b356ce74d49da' , 'viewMode' : None , 'notificationOptions' : None , 'teamId' : None , 'permission' : None , 'kind' : 'TASK' }] Before After Source code in managers/projects.py @logged_in def update ( self , obj ): \"\"\" Updates the passed project(s). Supports single project update and multiple project update (batch) Make local changes to the project objects that you want to change first, then pass the actual objects to the method. !!! info Every potential update to a project's attributes have not been tested. See [Example `TickTick` Project Dictionary](projects.md#example-ticktick-project-dictionary) for a listing of the fields present in a project. Arguments: obj (dict or list): **Single Project (dict)**: The project dictionary. **Multiple Projects (list)**: A list of project dictionaries. Returns: dict or list: **Single Project (dict)**: The updated project dictionary **Multiple Projects (list)**: A list containing the updated project dictionaries. Raises: TypeError: If the input is not a dict or a list. RuntimeError: If the projects could not be updated successfully. Updates are done by changing the fields in the objects locally first. !!! example \"Single Project Update\" === \"Changing The Name\" ```python # Lets assume that we have a project named \"Reading\" that we want to change to \"Summer Reading\" project = client.get_by_fields(name='Reading', search='projects') # Get the project # Now lets change the name project['name'] = 'Summer Reading' # Updating a single project requires just passing in the entire dictionary. updated = client.project.update(project) ``` ??? success \"Result\" The dictionary is returned and the name changed remotely. ```python {'id': '5ffe24a18f081003f3294c44', 'name': 'Summer Reading', 'isOwner': True, 'color': '#6fcbdf', 'inAll': True, 'sortOrder': -6236426731520, 'sortType': 'sortOrder', 'userCount': 1, 'etag': '0vbsvn8e', 'modifiedTime': '2021-01-12T23:38:16.456+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe2d37b04b35082bbcdf74', 'viewMode': 'list', 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'} ``` **Before** [![project-update-before.png](https://i.postimg.cc/K8hcpzvP/project-update-before.png)](https://postimg.cc/crTNrd3C) **After** [![project-update-after.png](https://i.postimg.cc/DwcWqsdJ/project-update-after.png)](https://postimg.cc/FY7svY6N) !!! example \"Multiple Project Update\" === \"Changing Multiple Names\" ```python # Lets assume that we have a project named \"Writing\" that we want to change to \"Summer Reading\" project = client.get_by_fields(name='Writing', search='projects') # Get the project project['name'] = 'Summer Writing' # Lets assume that we have a project named \"Movies\" that we want to change to \"Summer Movies\" movie_project = client.get_by_fields(name='Movies', search='projects') movie_project['name'] = 'Summer Movies' # Updating multiple projects requires passing the projects in a list. update_list = [project, movie_project] # Lets update remotely now updated_projects = client.project.update(update_list) ``` ??? success \"Result\" A list containing the updated projects is returned. ```python [{'id': '5ffe24a18f081003f3294c46', 'name': 'Summer Reading', 'isOwner': True, 'color': '#9730ce', 'inAll': True, 'sortOrder': 0, 'sortType': None, 'userCount': 1, 'etag': 'bgl0pkm8', 'modifiedTime': '2021-01-13T00:13:29.796+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}, {'id': '5ffe399c8f08237f3d144ece', 'name': 'Summer Movies', 'isOwner': True, 'color': '#F18181', 'inAll': True, 'sortOrder': -2843335458816, 'sortType': 'sortOrder', 'userCount': 1, 'etag': 'jmjy1xtc', 'modifiedTime': '2021-01-13T00:13:29.800+0000', 'closed': None, 'muted': False, 'transferred': None, 'groupId': '5ffe11b7b04b356ce74d49da', 'viewMode': None, 'notificationOptions': None, 'teamId': None, 'permission': None, 'kind': 'TASK'}] ``` **Before** [![project-update-multiople.png](https://i.postimg.cc/9QbcJH81/project-update-multiople.png)](https://postimg.cc/zyLmG61R) **After** [![project-update-multiple-after.png](https://i.postimg.cc/3RVGNv2y/project-update-multiple-after.png)](https://postimg.cc/0MGjHrWx) \"\"\" # Check the types if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Project objects must be a dict or list of dicts.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/project' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'projects' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( obj ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'projects' ) for original in obj : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = obj . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"update()"},{"location":"usage/projects/#managers.projects.ProjectManager.update_folder","text":"Updates the project folders(s) remotely based off changes made locally. Make the changes you want to the project folder(s) first. Parameters: Name Type Description Default obj dict or list Single Folder (dict) : The dictionary object of the folder to update. Multiple Folders (list) : A list containing dictionary objects of folders to update. required Returns: Type Description dict or list Single Folder (dict) : The dictionary object of the updated folder. Multiple Folders (list) : A list of dictionary objects corresponding to the updated folders. Exceptions: Type Description TypeError If obj is not a dictionary or list RuntimeError If the updating was unsuccessful. Updating A Project Folder Single Folder Update # Lets assume that we have a folder called \"Productivity\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Lets change the name to \"Hobbies\" productivity_folder [ 'name' ] = \"Hobbies\" # Update updated_folder = client . project . update_folder ( productivity_folder ) Result The dictionary of the updated folder is returned. { 'id' : '5ffe7dab8f089fb5795d8ef2' , 'etag' : 'r9xl60e5' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None } Before After Multiple Folder Update # Lets assume that we have a folder called \"Productivity\" productivity_folder = client . get_by_fields ( name = 'Productivity' , search = 'project_folders' ) # Lets assume that we have another folder called \"Games\" games_folder = client . get_by_fields ( name = 'Games' , search = 'project_folders' ) # Lets change the \"Productivity\" folder to \"Work\" productivity_folder [ 'name' ] = \"Work\" # Lets change the \"Games\" folder to \"Hobbies\" games_folder [ 'name' ] = \"Hobbies\" update_list = [ productivity_folder , games_folder ] # List of objects to update # Update updated_folder = client . project . update_folder ( update_list ) Result A list of the updated folder objects is returned. [{ 'id' : '5ffe80ce8f08068e86aab288' , 'etag' : '0oh0pxel' , 'name' : 'Work' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }, { 'id' : '5ffe80cf8f08068e86aab289' , 'etag' : 'xwvehtfo' , 'name' : 'Hobbies' , 'showAll' : True , 'sortOrder' : 0 , 'deleted' : 0 , 'userId' : 447666584 , 'sortType' : 'project' , 'teamId' : None }] Before After Source code in managers/projects.py @logged_in def update_folder ( self , obj ): \"\"\" Updates the project folders(s) remotely based off changes made locally. Make the changes you want to the project folder(s) first. Arguments: obj (dict or list): **Single Folder (dict)**: The dictionary object of the folder to update. **Multiple Folders (list)**: A list containing dictionary objects of folders to update. Returns: dict or list: **Single Folder (dict)**: The dictionary object of the updated folder. **Multiple Folders (list)**: A list of dictionary objects corresponding to the updated folders. Raises: TypeError: If `obj` is not a dictionary or list RuntimeError: If the updating was unsuccessful. !!! example \"Updating A Project Folder\" === \"Single Folder Update\" ```python # Lets assume that we have a folder called \"Productivity\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') # Lets change the name to \"Hobbies\" productivity_folder['name'] = \"Hobbies\" # Update updated_folder = client.project.update_folder(productivity_folder) ``` ??? success \"Result\" The dictionary of the updated folder is returned. ```python {'id': '5ffe7dab8f089fb5795d8ef2', 'etag': 'r9xl60e5', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104408388-c48bbb80-5518-11eb-80d4-34e82bbaffd7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104408436-e1c08a00-5518-11eb-953a-4933f407e4f9.png) === \"Multiple Folder Update\" ```python # Lets assume that we have a folder called \"Productivity\" productivity_folder = client.get_by_fields(name='Productivity', search='project_folders') # Lets assume that we have another folder called \"Games\" games_folder = client.get_by_fields(name='Games', search='project_folders') # Lets change the \"Productivity\" folder to \"Work\" productivity_folder['name'] = \"Work\" # Lets change the \"Games\" folder to \"Hobbies\" games_folder['name'] = \"Hobbies\" update_list = [productivity_folder, games_folder] # List of objects to update # Update updated_folder = client.project.update_folder(update_list) ``` ??? success \"Result\" A list of the updated folder objects is returned. ```python [{'id': '5ffe80ce8f08068e86aab288', 'etag': '0oh0pxel', 'name': 'Work', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}, {'id': '5ffe80cf8f08068e86aab289', 'etag': 'xwvehtfo', 'name': 'Hobbies', 'showAll': True, 'sortOrder': 0, 'deleted': 0, 'userId': 447666584, 'sortType': 'project', 'teamId': None}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104409143-75468a80-551a-11eb-96c8-5953c97d6f6a.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104409181-8bece180-551a-11eb-8424-9f147d85eb80.png) \"\"\" # Check the types if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Project objects must be a dict or list of dicts.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/projectGroup' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'project_folders' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Get the ids items = [ '' ] * len ( tasks ) # Create enough spots for the objects for proj_id in etag2 : found = self . _client . get_by_id ( proj_id , search = 'project_folders' ) for original in tasks : if found [ 'name' ] == original [ 'name' ]: # Get the index of original index = tasks . index ( original ) # Place found at the index in return list items [ index ] = found return items","title":"update_folder()"},{"location":"usage/tags/","text":"Info Tag methods are accessed through the tag public member of your TickTickClient instance. # Assumes that 'client' is the name that references the TickTickClient instance. tag = client . tag . method () Question About Logging In or Other Functionality Available? API and Important Information Tip All supported methods are documented below with usage examples, take a look! All usage examples assume that client is the name referencing the TickTickClient instance Example TickTick Tag Dictionary \u00b6 Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values name The lowercase of label 'books' str N/A label The uppercase of name 'Books' str N/A sortOrder A sort ID relative to other tags. 2748779069440 int N/A sortType Sort type of the tag dueDate str dueDate , project , title , priority color Hex color code string #4AA6EF str N/A etag Etag identifier. 'ji35exmv' str N/A parent name field of the parent tag 'friends' str N/A { 'name' : 'test' , 'label' : 'Test' , 'sortOrder' : 2748779069440 , 'sortType' : 'project' , 'color' : '#4AA6EF' , 'etag' : 'zxdvlhqd' , 'parent' : 'friends' } Sort Dictionary \u00b6 SORT_DICTIONARY The sort dictionary maps integers to the different sort types possible for tags. It is a public member called SORT_DICTIONARY available through the tag public member of the TickTickClient instance. Descriptions Value Sort Type 0 'project' 1 'dueDate' 2 'title' 3 'priority' TagsManager \u00b6 Handles all interactions for tags. builder ( self , label , color = 'random' , parent = None , sort = None ) \u00b6 Creates and returns a local tag object. Helper method for create to make batch creating projects easier. Note The parent tag must already exist prior to calling this method. Parameters: Name Type Description Default label str Desired label of the tag - tag labels cannot be repeated. required color str Hex color string. A random color will be generated if no color is specified. 'random' parent str The label of the parent tag if desired (include capitals in the label if it exists). None sort int The desired sort type of the tag. Valid integer values are present in the sort dictionary . The default sort value will be by 'project' None Returns: Type Description dict A dictionary containing all the fields necessary to create a tag remotely. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Tag label already exists. ValueError Parent tag does not exist. ValueError The hex string color inputted is invalid. Example tag_name = 'Books' # The name for our tag parent_name = 'Productivity' # The desired parent tag -> this should already exist. color_code = '#1387c4' sort_type = 1 # Sort by `dueDate` tag_object = client . tag . builder ( tag_name , parent = parent_name , color = color_code , sort = sort_type ) Result The required fields to create a tag object are created and returned in a dictionary. { 'label' : 'Fiction' , 'color' : '#1387c4' , 'parent' : 'books' , 'sortType' : 'dueDate' , 'name' : 'fiction' } Source code in managers/tags.py def builder ( self , label : str , color : str = 'random' , parent : str = None , sort : int = None ) -> dict : \"\"\" Creates and returns a local tag object. Helper method for [create][managers.tags.TagsManager.create] to make batch creating projects easier. !!! note The parent tag must already exist prior to calling this method. Arguments: label: Desired label of the tag - tag labels cannot be repeated. color: Hex color string. A random color will be generated if no color is specified. parent: The label of the parent tag if desired (include capitals in the label if it exists). sort: The desired sort type of the tag. Valid integer values are present in the [sort dictionary](tags.md#sort-dictionary). The default sort value will be by 'project' Returns: A dictionary containing all the fields necessary to create a tag remotely. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Tag label already exists. ValueError: Parent tag does not exist. ValueError: The hex string color inputted is invalid. !!! example ```python tag_name = 'Books' # The name for our tag parent_name = 'Productivity' # The desired parent tag -> this should already exist. color_code = '#1387c4' sort_type = 1 # Sort by `dueDate` tag_object = client.tag.builder(tag_name, parent=parent_name, color=color_code, sort=sort_type) ``` ??? success \"Result\" The required fields to create a tag object are created and returned in a dictionary. ```python {'label': 'Fiction', 'color': '#1387c4', 'parent': 'books', 'sortType': 'dueDate', 'name': 'fiction'} ``` \"\"\" # Perform checks return self . _check_fields ( label , color = color , parent_label = parent , sort = sort ) color ( self , label , color ) \u00b6 Change the color of a tag. For batch changing colors, see update . Parameters: Name Type Description Default label str The label of the tag to be changed. required color str The new desired hex color string. required Returns: Type Description dict The updated tag dictionary object. Exceptions: Type Description TypeError If label or color are not strings. ValueError If the tag label does not exist. ValueError If color is not a valid hex color string. RuntimeError If changing the color was not successful. Changing a Tag's Color # Lets assume that we have a tag named \"Movies\" that we want to change the color for. new_color = '#134397' movies_updated = client . tag . color ( 'Movies' , new_color ) Result The updated tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#134397' , 'etag' : 'wwb49yfr' } Before After Source code in managers/tags.py @logged_in def color ( self , label : str , color : str ) -> dict : \"\"\" Change the color of a tag. For batch changing colors, see [update][managers.tags.TagsManager.update]. Arguments: label: The label of the tag to be changed. color: The new desired hex color string. Returns: The updated tag dictionary object. Raises: TypeError: If `label` or `color` are not strings. ValueError: If the tag `label` does not exist. ValueError: If `color` is not a valid hex color string. RuntimeError: If changing the color was not successful. !!! example \"Changing a Tag's Color\" ```python # Lets assume that we have a tag named \"Movies\" that we want to change the color for. new_color = '#134397' movies_updated = client.tag.color('Movies', new_color) ``` ??? success \"Result\" The updated tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#134397', 'etag': 'wwb49yfr'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104661749-0eda7d00-567e-11eb-836f-3a8851bcf9a5.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104661860-55c87280-567e-11eb-93b5-054fa4f1104a.png) \"\"\" if not isinstance ( label , str ) or not isinstance ( color , str ): raise TypeError ( 'Label and Color Must Be Strings' ) # Get the object label = label . lower () obj = self . _client . get_by_fields ( name = label , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Update\" ) # Check the color if not check_hex_color ( color ): raise ValueError ( f \"Hex Color String ' { color } ' Is Not Valid\" ) obj [ 'color' ] = color # Set the color url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]]) create ( self , label , color = 'random' , parent = None , sort = None ) \u00b6 Creates a tag remotely. Supports single tag creation or batch tag creation. Tip Allows creation with a label that may normally not be allowed by TickTick for tags. Normal TickTick excluded characters are: \\ / \" # : * ? < > | Space Parameters: Name Type Description Default label str or list Single Tag (str) : The desired label of the tag. Tag labels cannot be repeated. Multiple Tags (list) : A list of tag objects created using the builder method. required color str Hex color string. A random color will be generated if no color is specified. 'random' parent str The label of the parent tag if desired (include capitals in if it exists). None sort int The desired sort type of the tag. Valid integer values are present in the sort dictionary . The default sort value will be by 'project' None Returns: Type Description dict or list Single Tag (dict) : The created tag object dictionary. Multiple Tags (list) : A list of the created tag object dictionaries. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Tag label already exists. ValueError Parent tag does not exist. ValueError The hex string color inputted is invalid. RuntimeError The tag(s) could not be created. Single Tag Just A Label tag = client . tag . create ( 'Fun' ) Result The tag object dictionary is returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#9b69f3' , 'etag' : '7fc8zb58' } Our tag is created. Specify a Color A random color can be generated using generate_hex_color . However, just not specifying a color will automatically generate a random color (as seen in the previous tab) You can always specify the color that you want. tag = client . tag . create ( 'Fun' , color = '#86bb6d' ) Result The tag object dictionary is returned and our project is created with the color specified. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#86bb6d' , 'etag' : '8bzzdws3' } Specifying a Parent Tag Tags can be nested one level. To create a tag that is nested, include the label of the parent tag. The parent tag should already exist. tag = client . tag . create ( 'Fun' , parent = 'Hobbies' ) Result The tag object dictionary is returned and our tag is created nested under the parent tag. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#d2a6e4' , 'etag' : 'nauticx1' , 'parent' : 'hobbies' } Before After Sort Type You can specify the sort type of the created tag using integer values from the sort dictionary . tag = client . tag . create ( 'Fun' , sort = 2 ) # Sort by `title` Result The tag object dictionary is returned and our tag has the specified sort type. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'title' , 'color' : '#e7e7ba' , 'etag' : 'n4k3pezc' } Multiple Tag Creation (batch) To create multiple tags, build the tag objects first using the builder method. Pass in a list of the project objects to create them remotely. parent_tag = client . tag . create ( 'Hobbies' ) # Create a parent tag. # We will create tag objects using builder that will be nested under the parent tag fun_tag = client . tag . builder ( 'Fun' , sort = 2 , parent = 'Hobbies' ) read_tag = client . tag . builder ( 'Read' , color = '#d2a6e4' , parent = 'Hobbies' ) movie_tag = client . tag . builder ( 'Movies' , parent = 'Hobbies' ) # Create the tags tag_list = [ fun_tag , read_tag , movie_tag ] created_tags = client . tag . create ( tag_list ) Result The tag object dictionaries are returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'title' , 'color' : '#172d1c' , 'etag' : '1tceclp4' , 'parent' : 'hobbies' }, { 'name' : 'read' , 'label' : 'Read' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#d2a6e4' , 'etag' : 'ykdem8dg' , 'parent' : 'hobbies' }, { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#94a5f8' , 'etag' : 'o0nifkbv' , 'parent' : 'hobbies' }] Source code in managers/tags.py @logged_in def create ( self , label , color : str = 'random' , parent : str = None , sort : int = None ): \"\"\" Creates a tag remotely. Supports single tag creation or batch tag creation. !!! tip Allows creation with a label that may normally not be allowed by `TickTick` for tags. Normal `TickTick` excluded characters are: \\\\ / \" # : * ? < > | Space Arguments: label (str or list): **Single Tag (str)**: The desired label of the tag. Tag labels cannot be repeated. **Multiple Tags (list)**: A list of tag objects created using the [builder][managers.tags.TagsManager.builder] method. color: Hex color string. A random color will be generated if no color is specified. parent: The label of the parent tag if desired (include capitals in if it exists). sort: The desired sort type of the tag. Valid integer values are present in the [sort dictionary](tags.md#sort-dictionary). The default sort value will be by 'project' Returns: dict or list: **Single Tag (dict)**: The created tag object dictionary. **Multiple Tags (list)**: A list of the created tag object dictionaries. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Tag label already exists. ValueError: Parent tag does not exist. ValueError: The hex string color inputted is invalid. RuntimeError: The tag(s) could not be created. !!! example \"Single Tag\" === \"Just A Label\" ```python tag = client.tag.create('Fun') ``` ??? success \"Result\" The tag object dictionary is returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#9b69f3', 'etag': '7fc8zb58'} ``` Our tag is created. ![image](https://user-images.githubusercontent.com/56806733/104658773-5bbb5500-5678-11eb-9d44-27214203d70e.png) === \"Specify a Color\" A random color can be generated using [generate_hex_color][helpers.hex_color.generate_hex_color]. However, just not specifying a color will automatically generate a random color (as seen in the previous tab) You can always specify the color that you want. ```python tag = client.tag.create('Fun', color='#86bb6d') ``` ??? success \"Result\" The tag object dictionary is returned and our project is created with the color specified. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#86bb6d', 'etag': '8bzzdws3'} ``` ![image](https://user-images.githubusercontent.com/56806733/104659184-0c295900-5679-11eb-9f3c-2cd154c0500c.png) === \"Specifying a Parent Tag\" Tags can be nested one level. To create a tag that is nested, include the label of the parent tag. The parent tag should already exist. ```python tag = client.tag.create('Fun', parent='Hobbies') ``` ??? success \"Result\" The tag object dictionary is returned and our tag is created nested under the parent tag. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#d2a6e4', 'etag': 'nauticx1', 'parent': 'hobbies'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104659785-24e63e80-567a-11eb-9a62-01ebca55e649.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104659814-33ccf100-567a-11eb-8dca-c91aea68b4c7.png) === \"Sort Type\" You can specify the sort type of the created tag using integer values from the [sort dictionary](#sort-dictionary). ```python tag = client.tag.create('Fun', sort=2) # Sort by `title` ``` ??? success \"Result\" The tag object dictionary is returned and our tag has the specified sort type. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'title', 'color': '#e7e7ba', 'etag': 'n4k3pezc'} ``` ![image](https://user-images.githubusercontent.com/56806733/104660156-e4d38b80-567a-11eb-8c61-8fb874a515a2.png) !!! example \"Multiple Tag Creation (batch)\" To create multiple tags, build the tag objects first using the [builder][managers.projects.ProjectManager.builder] method. Pass in a list of the project objects to create them remotely. ```python parent_tag = client.tag.create('Hobbies') # Create a parent tag. # We will create tag objects using builder that will be nested under the parent tag fun_tag = client.tag.builder('Fun', sort=2, parent='Hobbies') read_tag = client.tag.builder('Read', color='#d2a6e4', parent='Hobbies') movie_tag = client.tag.builder('Movies', parent='Hobbies') # Create the tags tag_list = [fun_tag, read_tag, movie_tag] created_tags = client.tag.create(tag_list) ``` ??? success \"Result\" The tag object dictionaries are returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'title', 'color': '#172d1c', 'etag': '1tceclp4', 'parent': 'hobbies'}, {'name': 'read', 'label': 'Read', 'sortOrder': 0, 'sortType': 'project', 'color': '#d2a6e4', 'etag': 'ykdem8dg', 'parent': 'hobbies'}, {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#94a5f8', 'etag': 'o0nifkbv', 'parent': 'hobbies'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104660625-cb7f0f00-567b-11eb-8649-68646870ccfa.png) \"\"\" batch = False # Bool signifying batch create or not if isinstance ( label , list ): # Batch tag creation triggered obj = label # Assuming all correct objects batch = True else : if not isinstance ( label , str ): raise TypeError ( 'Required Positional Argument Must Be A String or List of Tag Objects' ) # Create a single object obj = self . builder ( label = label , color = color , parent = parent , sort = sort ) if not batch : obj = [ obj ] url = self . _client . BASE_URL + 'batch/tag' payload = { 'add' : obj } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if not batch : return self . _client . get_by_etag ( self . _client . parse_etag ( response ), search = 'tags' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'name' ] for x in obj ] # Tag names are in order items = [ '' ] * len ( obj ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here actual_etag = etag [ tag ] # Get the actual etag found = self . _client . get_by_etag ( actual_etag , search = 'tags' ) items [ index ] = found # Place at the correct index if len ( items ) == 1 : return items [ 0 ] else : return items delete ( self , label ) \u00b6 Delete tag(s). Supports single tag deletion and \"mock\" batch tag deletion. Info Batch deleting for tags is not supported by TickTick. However, passing in a list of labels to delete will \"mock\" batch deleting - but individual requests will have to be made for each deletion. Parameters: Name Type Description Default label str or list Single Tag (str) : The label of the tag. Multiple Tags (list) : A list of tag label strings. required Returns: Type Description dict or list Single Tag (dict) : The dictionary object of the deleted tag. Multiple Tags (list) : The dictionary objects of the deleted tags in a list. Exceptions: Type Description TypeError If label is not a string or list. ValueError If a label does not exist. RuntimeError If the tag could not be deleted successfully. Tag Deletion Single Tag Deletion Deleting a single tag requires passing in the label string of the tag. # Lets delete a tag named \"Fun\" delete_tag = client . tag . delete ( \"Fun\" ) Result The dictionary object of the deleted tag returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 3298534883328 , 'sortType' : 'project' , 'color' : '#A9949E' , 'etag' : '32balm5l' } Before \"Fun\" Tag Exists After \"Fun\" Tag Does Not Exist Multiple Tag Deletion Deleting multiple tags requires passing the label strings of the tags in a list. # Lets delete tags named \"Fun\", \"Movies\", and \"Hobbies\" delete_labels = [ \"Fun\" , \"Movies\" , \"Hobbies\" ] deleted_tags = client . tag . delete ( delete_labels ) Result The dictionary object of the deleted tags returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 3848290697216 , 'sortType' : 'project' , 'color' : '#FFD966' , 'etag' : '56aa6dva' }, { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : - 2748779069440 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 's0czro3e' }, { 'name' : 'hobbies' , 'label' : 'Hobbies' , 'sortOrder' : - 2199023255552 , 'sortType' : 'project' , 'color' : '#ABA6B5' , 'etag' : 'shu2xbvq' }] Before All three tags exist. After All three tags don't exist. Source code in managers/tags.py @logged_in def delete ( self , label ): \"\"\" Delete tag(s). Supports single tag deletion and \"mock\" batch tag deletion. !!! info Batch deleting for tags is not supported by TickTick. However, passing in a list of labels to delete will \"mock\" batch deleting - but individual requests will have to be made for each deletion. Arguments: label (str or list): **Single Tag (str)**: The label of the tag. **Multiple Tags (list)**: A list of tag label strings. Returns: dict or list: **Single Tag (dict)**: The dictionary object of the deleted tag. **Multiple Tags (list)**: The dictionary objects of the deleted tags in a list. Raises: TypeError: If `label` is not a string or list. ValueError: If a label does not exist. RuntimeError: If the tag could not be deleted successfully. !!! example \"Tag Deletion\" === \"Single Tag Deletion\" Deleting a single tag requires passing in the label string of the tag. ```python # Lets delete a tag named \"Fun\" delete_tag = client.tag.delete(\"Fun\") ``` ??? success \"Result\" The dictionary object of the deleted tag returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': -3298534883328, 'sortType': 'project', 'color': '#A9949E', 'etag': '32balm5l'} ``` **Before** \"Fun\" Tag Exists ![image](https://user-images.githubusercontent.com/56806733/104668024-2c164800-568c-11eb-853e-5b7eba1f4528.png) **After** \"Fun\" Tag Does Not Exist ![image](https://user-images.githubusercontent.com/56806733/104667768-ac887900-568b-11eb-9bfb-597c752e4c3b.png) === \"Multiple Tag Deletion\" Deleting multiple tags requires passing the label strings of the tags in a list. ```python # Lets delete tags named \"Fun\", \"Movies\", and \"Hobbies\" delete_labels = [\"Fun\", \"Movies\", \"Hobbies\"] deleted_tags = client.tag.delete(delete_labels) ``` ??? success \"Result\" The dictionary object of the deleted tags returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': -3848290697216, 'sortType': 'project', 'color': '#FFD966', 'etag': '56aa6dva'}, {'name': 'movies', 'label': 'Movies', 'sortOrder': -2748779069440, 'sortType': 'dueDate', 'color': '#134397', 'etag': 's0czro3e'}, {'name': 'hobbies', 'label': 'Hobbies', 'sortOrder': -2199023255552, 'sortType': 'project', 'color': '#ABA6B5', 'etag': 'shu2xbvq'}] ``` **Before** All three tags exist. ![image](https://user-images.githubusercontent.com/56806733/104668135-61bb3100-568c-11eb-8707-314deb42cd1d.png) **After** All three tags don't exist. ![image](https://user-images.githubusercontent.com/56806733/104668185-7b5c7880-568c-11eb-8da0-aaee68d53500.png) \"\"\" # Determine if the tag exists if not isinstance ( label , str ) and not isinstance ( label , list ): raise TypeError ( 'Label Must Be A String or List Of Strings' ) url = self . _client . BASE_URL + 'tag' if isinstance ( label , str ): label = [ label ] # If a singular string we are going to add it to a list objects = [] for lbl in label : if not isinstance ( lbl , str ): raise TypeError ( f \"' { lbl } ' Must Be A String\" ) lbl = lbl . lower () tag_obj = self . _client . get_by_fields ( name = lbl , search = 'tags' ) # Get the tag object if not tag_obj : raise ValueError ( f \"Tag ' { lbl } ' Does Not Exist To Delete\" ) # We can assume that only one tag has the name params = { 'name' : tag_obj [ 'name' ] } response = self . _client . http_delete ( url , params = params , cookies = self . _client . cookies ) # Find the tag in the tags list and delete it, then return the deleted object objects . append ( self . _client . delete_from_local_state ( search = 'tags' , etag = tag_obj [ 'etag' ])) self . _client . sync () if len ( objects ) == 1 : return objects [ 0 ] else : return objects merge ( self , label , merged ) \u00b6 Merges the tasks of the passed tags into the argument merged and deletes all the tags except merged Args can be individual label strings, or a list of strings Parameters: Name Type Description Default label str or list Single Tag (str) : The label string of the tag to merge. Multiple Tags (list) : The label strings of the tags to merge in a list. required merged str The label of the tag that will remain after the merge. required Returns: Type Description dict The tag dictionary object that remains after the merge. Exceptions: Type Description TypeError If merged is not a str or if label is not a str or list. ValueError If any of the labels do not exist. RuntimeError If the merge could not be successfully completed. Merging Tags Merging Two Tags Merging two tags requires the label of the tag that you want kept after the merge, and the label of the tag that will be merged. Lets assume that we have two tags: \"Work\" and \"School\". I want to merge the tag \"School\" into \"Work\". What should happen is that any tasks that are tagged \"School\", will be updated to have the tag \"Work\", and the \"School\" tag will be deleted. merged_tags = client . tag . merge ( \"School\" , \"Work\" ) Result The tag that remains after the merge is returned. { 'name' : 'work' , 'label' : 'Work' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#3876E4' , 'etag' : 'eeh8zrup' } Before \"School\" has two tasks that have it's tag. \"Work\" has no tasks. After \"School\" has been deleted. The tasks that used to be tagged with \"School\" are now tagged with \"Work\". Merging Three Or More Tags Merging multiple tags into a single tag requires passing the labels of the tags to merge in a list. Lets assume that we have three tags: \"Work\", \"School\", and \"Hobbies\" . I want to merge the tag \"School\" and the tag \"Hobbies\" into \"Work\". What should happen is that any tasks that are tagged with \"School\" or \"Hobbies\", will be updated to have the tag \"Work\", and the \"School\" and \"Hobbies\" tags will be deleted. merge_tags = [ \"School\" , \"Hobbies\" ] result = client . tag . merge ( merge_tags , \"Work\" ) Result The tag that remains after the merge is returned. { 'name' : 'work' , 'label' : 'Work' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#3876E4' , 'etag' : 'ke23lp06' } Before \"School\" has two tasks. \"Hobbies\" has two tasks. \"Work\" has one task. After \"Work\" has five tasks now, and the tags \"School\" and \"Hobbies\" have been deleted. Source code in managers/tags.py @logged_in def merge ( self , label , merged : str ): \"\"\" Merges the tasks of the passed tags into the argument `merged` and deletes all the tags except `merged` Args can be individual label strings, or a list of strings Arguments: label (str or list): **Single Tag (str)**: The label string of the tag to merge. **Multiple Tags (list)**: The label strings of the tags to merge in a list. merged: The label of the tag that will remain after the merge. Returns: dict: The tag dictionary object that remains after the merge. Raises: TypeError: If `merged` is not a str or if `label` is not a str or list. ValueError: If any of the labels do not exist. RuntimeError: If the merge could not be successfully completed. !!! example \"Merging Tags\" === \"Merging Two Tags\" Merging two tags requires the label of the tag that you want kept after the merge, and the label of the tag that will be merged. Lets assume that we have two tags: \"Work\" and \"School\". I want to merge the tag \"School\" into \"Work\". What should happen is that any tasks that are tagged \"School\", will be updated to have the tag \"Work\", and the \"School\" tag will be deleted. ```python merged_tags = client.tag.merge(\"School\", \"Work\") ``` ??? success \"Result\" The tag that remains after the merge is returned. ```python {'name': 'work', 'label': 'Work', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#3876E4', 'etag': 'eeh8zrup'} ``` **Before** \"School\" has two tasks that have it's tag. ![image](https://user-images.githubusercontent.com/56806733/104680244-45c38980-56a4-11eb-968d-884160c77247.png) \"Work\" has no tasks. ![image](https://user-images.githubusercontent.com/56806733/104680366-90dd9c80-56a4-11eb-975f-5e769e9ea491.png) **After** \"School\" has been deleted. The tasks that used to be tagged with \"School\" are now tagged with \"Work\". ![image](https://user-images.githubusercontent.com/56806733/104680576-0c3f4e00-56a5-11eb-9536-ef3a7fcf20ec.png) === \"Merging Three Or More Tags\" Merging multiple tags into a single tag requires passing the labels of the tags to merge in a list. Lets assume that we have three tags: \"Work\", \"School\", and \"Hobbies\" . I want to merge the tag \"School\" and the tag \"Hobbies\" into \"Work\". What should happen is that any tasks that are tagged with \"School\" or \"Hobbies\", will be updated to have the tag \"Work\", and the \"School\" and \"Hobbies\" tags will be deleted. ```python merge_tags = [\"School\", \"Hobbies\"] result = client.tag.merge(merge_tags, \"Work\") ``` ??? success \"Result\" The tag that remains after the merge is returned. ```python {'name': 'work', 'label': 'Work', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#3876E4', 'etag': 'ke23lp06'} ``` **Before** \"School\" has two tasks. ![image](https://user-images.githubusercontent.com/56806733/104681135-7ad0db80-56a6-11eb-81dd-03e4a151cfd9.png) \"Hobbies\" has two tasks. ![image](https://user-images.githubusercontent.com/56806733/104681104-67257500-56a6-11eb-99b0-57bbb876a59e.png) \"Work\" has one task. ![image](https://user-images.githubusercontent.com/56806733/104681164-89b78e00-56a6-11eb-99a8-c85ef418d2a0.png) **After** \"Work\" has five tasks now, and the tags \"School\" and \"Hobbies\" have been deleted. ![image](https://user-images.githubusercontent.com/56806733/104681239-b7043c00-56a6-11eb-9b45-5522b9c69cb0.png) \"\"\" # Make sure merged is a string if not isinstance ( merged , str ): raise ValueError ( 'Merged Must Be A String' ) # Make sure label is a string or list if not isinstance ( label , str ) and not isinstance ( label , list ): raise ValueError ( f \"Label must be a string or a list.\" ) # Lowercase merged merged = merged . lower () # Make sure merged exists kept_obj = self . _client . get_by_fields ( name = merged , search = 'tags' ) if not kept_obj : raise ValueError ( f \"Kept Tag ' { merged } ' Does Not Exist To Merge\" ) merge_queue = [] # Verify all args are valid, and add them to a list if isinstance ( label , str ): string = label . lower () # Make sure it exists retrieved = self . _client . get_by_fields ( name = string , search = 'tags' ) if not retrieved : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Merge\" ) merge_queue . append ( retrieved ) else : for item in label : # Loop through the items in the list and check items are a string and exist # Make sure the item is a string if not isinstance ( item , str ): raise ValueError ( f \"Item ' { item } ' Must Be A String\" ) string = item . lower () # Make sure it exists found = self . _client . get_by_fields ( name = string , search = 'tags' ) if not found : raise ValueError ( f \"Tag ' { item } ' Does Not Exist To Merge\" ) merge_queue . append ( found ) for labels in merge_queue : # Merge url = self . _client . BASE_URL + 'tag/merge' payload = { 'name' : labels [ 'name' ], 'newName' : kept_obj [ 'name' ] } self . _client . http_put ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () return kept_obj nesting ( self , child , parent ) \u00b6 Update tag nesting. Move an already created tag to be nested underneath a parent tag - or ungroup an already nested tag. Nesting Tags More Than One Level Does Not Work Example Nesting Explanation Parent Tag -> Level Zero Child Tag 1 -> Level One: This is the most nesting that is allowed by TickTick for tags. Child Tag 2 -> Level Two: Not allowed Parameters: Name Type Description Default child str Label of the tag to become the child required parent str Label of the tag that will become the parent. required Returns: Type Description dict The updated tag object dictionary. Exceptions: Type Description TypeError If child and parent are not strings ValueError If child does not exist to update. ValueError If parent does not exist. RuntimeError If setting the parent was unsuccessful. Nesting Nesting A Tag To nest a tag underneath another tag, pass in the labels of the child and parent. # Lets assume that we have a tag named \"Movies\" # We have another tag named \"Hobbies\" that we want to make the parent to \"Movies\" child = \"Movies\" parent = \"Hobbies\" nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'ee34aft9' , 'parent' : 'hobbies' } Before After Changing The Parent Of An Already Nested Tag If the tag is already nested, changing the parent is still no different. # We have a tag named \"Movies\" that is already nested underneath \"Hobbies\" # We want to nest \"Movies\" underneath the tag \"Fun\" instead. child = \"Movies\" parent = \"Fun\" nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : '91qpuq71' , 'parent' : 'fun' } Before After Un-grouping A Child Tag If the tag is nested and you want to ungroup it, pass in None for parent . # We have a tag named \"Movies\" that is nested underneath \"Fun\" # We don't want to have \"Movies\" nested anymore. child = \"Movies\" parent = None nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'jcoc94p6' } Before After Source code in managers/tags.py @logged_in def nesting ( self , child : str , parent : str ) -> dict : \"\"\" Update tag nesting. Move an already created tag to be nested underneath a parent tag - or ungroup an already nested tag. !!! warning \"Nesting Tags More Than One Level Does Not Work\" !!! example === \"Nesting Explanation\" ```md Parent Tag -> Level Zero Child Tag 1 -> Level One: This is the most nesting that is allowed by TickTick for tags. Child Tag 2 -> Level Two: Not allowed ``` Arguments: child: Label of the tag to become the child parent: Label of the tag that will become the parent. Returns: The updated tag object dictionary. Raises: TypeError: If `child` and `parent` are not strings ValueError: If `child` does not exist to update. ValueError: If `parent` does not exist. RuntimeError: If setting the parent was unsuccessful. !!! example \"Nesting\" === \"Nesting A Tag\" To nest a tag underneath another tag, pass in the labels of the child and parent. ```python # Lets assume that we have a tag named \"Movies\" # We have another tag named \"Hobbies\" that we want to make the parent to \"Movies\" child = \"Movies\" parent = \"Hobbies\" nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'ee34aft9', 'parent': 'hobbies'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104665300-da6abf00-5685-11eb-947f-889187cec008.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104665366-f706f700-5685-11eb-93eb-9316befec5fc.png) === \"Changing The Parent Of An Already Nested Tag\" If the tag is already nested, changing the parent is still no different. ```python # We have a tag named \"Movies\" that is already nested underneath \"Hobbies\" # We want to nest \"Movies\" underneath the tag \"Fun\" instead. child = \"Movies\" parent = \"Fun\" nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': '91qpuq71', 'parent': 'fun'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104665599-ab088200-5686-11eb-8b36-5ee873289db7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104665821-35e97c80-5687-11eb-8098-426816970f3e.png) === \"Un-grouping A Child Tag\" If the tag is nested and you want to ungroup it, pass in `None` for `parent`. ```python # We have a tag named \"Movies\" that is nested underneath \"Fun\" # We don't want to have \"Movies\" nested anymore. child = \"Movies\" parent = None nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'jcoc94p6'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104666038-be681d00-5687-11eb-8490-83c370977267.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104666080-dcce1880-5687-11eb-9ca8-5abcdb4109ba.png) \"\"\" if not isinstance ( child , str ): raise TypeError ( 'Inputs Must Be Strings' ) if parent is not None : if not isinstance ( parent , str ): raise TypeError ( 'Inputs Must Be Strings' ) # Get the object child = child . lower () obj = self . _client . get_by_fields ( name = child , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { child } ' Does Not Exist To Update\" ) # Four Cases # Case 1: No Parent -> Want a Parent # Case 2: No Parent -> Doesn't Want a Parent # Case 3: Has Parent -> Wants a Different Parent # Case 4: Has Parent -> Doesn't Want a Parent # Case 1: Determine if the object has a parent try : if obj [ 'parent' ]: # It has a parent if parent is not None : # Case 3 # check if the parent is already the same, if it is just return if obj [ 'parent' ] == parent . lower (): return obj else : new_p = parent . lower () obj [ 'parent' ] = new_p else : new_p = obj [ 'parent' ] # Case 4 obj [ 'parent' ] = '' elif obj [ 'parent' ] is None : raise ValueError ( 'Parent Does Not Exist' ) except KeyError : # It does not have a parent if parent is not None : # Wants a different parent new_p = parent . lower () # -> Case 1 obj [ 'parent' ] = new_p else : # Doesn't want a parent -> Case 2 return obj # We don't have to do anything if no parent and doesn't want a parent # Have to find the project pobj = self . _client . get_by_fields ( name = new_p , search = 'tags' ) if not pobj : raise ValueError ( f \"Tag ' { parent } ' Does Not Exist To Set As Parent\" ) url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ pobj , obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]], search = 'tags' ) rename ( self , old , new ) \u00b6 Renames a tag. Parameters: Name Type Description Default old str Current label of the tag to be changed. required new str Desired new label of the tag. required Returns: Type Description dict The tag object with the updated label. Exceptions: Type Description TypeError If old and new are not strings. ValueError If the old tag label does not exist. ValueError If the new tag label already exists. RuntimeError If the renaming was unsuccessful. Changing a Tag's Label Pass in the current label of the tag, and the desired new label of the tag. # Lets assume that we have a tag that already exists named \"Movie\" old_label = \"Movie\" new_label = \"Movies\" updated_tag = client . tag . rename ( old_label , new_label ) Result The updated tag object dictionary is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#134397' , 'etag' : 'qer1jygy' } Before After Source code in managers/tags.py @logged_in def rename ( self , old : str , new : str ) -> dict : \"\"\" Renames a tag. Arguments: old: Current label of the tag to be changed. new: Desired new label of the tag. Returns: The tag object with the updated label. Raises: TypeError: If `old` and `new` are not strings. ValueError: If the `old` tag label does not exist. ValueError: If the `new` tag label already exists. RuntimeError: If the renaming was unsuccessful. !!! example \"Changing a Tag's Label\" Pass in the current label of the tag, and the desired new label of the tag. ```python # Lets assume that we have a tag that already exists named \"Movie\" old_label = \"Movie\" new_label = \"Movies\" updated_tag = client.tag.rename(old_label, new_label) ``` ??? success \"Result\" The updated tag object dictionary is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#134397', 'etag': 'qer1jygy'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104661255-fcac0f00-567c-11eb-9f10-69af8b50e0b4.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104661299-19e0dd80-567d-11eb-825f-758d83178295.png) \"\"\" # Check that both old and new are strings if not isinstance ( old , str ) or not isinstance ( new , str ): raise TypeError ( 'Old and New Must Be Strings' ) # Make sure the old tag exists old = old . lower () # Check if the tag object exists obj = self . _client . get_by_fields ( name = old , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { old } ' Does Not Exist To Rename\" ) # Make sure the new tag does not exist temp_new = new . lower () # Check if the tag object exists found = self . _client . get_by_fields ( name = temp_new , search = 'tags' ) if found : raise ValueError ( f \"Name ' { new } ' Already Exists -> Cannot Duplicate Name\" ) url = self . _client . BASE_URL + 'tag/rename' payload = { 'name' : obj [ 'name' ], 'newName' : new } response = self . _client . http_put ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () # Response from TickTick does not return the new etag of the object, we must find it ourselves new_obj = self . _client . get_by_fields ( name = temp_new , search = 'tags' ) # Return the etag of the updated object return self . _client . get_by_etag ( new_obj [ 'etag' ], search = 'tags' ) sorting ( self , label , sort ) \u00b6 Change the sort type of a tag. For batch changing sort types, see update . Parameters: Name Type Description Default label str The label of the tag to be changed. required sort int The new sort type specified by an integer 0-3. See sort dictionary . required Returns: Type Description dict The updated tag dictionary object. Exceptions: Type Description TypeError If label is not a string or if sort is not an int. ValueError If the tag label does not exist. RuntimeError If the updating was unsuccessful. Changing the Sort Type # Lets assume that we have a tag named \"Movies\" with the sort type \"project\" changed_sort_type = client . tag . sorting ( \"Movies\" , 1 ) # Sort by 'dueDate' Result The updated task dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'fflj8iy0' } Before After Source code in managers/tags.py @logged_in def sorting ( self , label : str , sort : int ) -> dict : \"\"\" Change the sort type of a tag. For batch changing sort types, see [update][managers.tags.TagsManager.update]. Arguments: label: The label of the tag to be changed. sort: The new sort type specified by an integer 0-3. See [sort dictionary](tags.md#sort-dictionary). Returns: The updated tag dictionary object. Raises: TypeError: If `label` is not a string or if `sort` is not an int. ValueError: If the tag `label` does not exist. RuntimeError: If the updating was unsuccessful. !!! example \"Changing the Sort Type\" ```python # Lets assume that we have a tag named \"Movies\" with the sort type \"project\" changed_sort_type = client.tag.sorting(\"Movies\", 1) # Sort by 'dueDate' ``` ??? success \"Result\" The updated task dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'fflj8iy0'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104663625-3f241a80-5682-11eb-93a7-73d280c59b3e.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104663663-5531db00-5682-11eb-9440-5673a70840b4.png) \"\"\" if not isinstance ( label , str ) or not isinstance ( sort , int ): raise TypeError ( 'Label Must Be A String and Sort Must Be An Int' ) # Get the object label = label . lower () obj = self . _client . get_by_fields ( name = label , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Update\" ) sort = self . _sort_string_value ( sort ) # Get the sort string for the value obj [ 'sortType' ] = sort # set the object field url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]]) update ( self , obj ) \u00b6 Generic update method. Supports single and batch tag update. Important Updating tag properties like parent and renaming tags must be completed through their respective class methods to work: nesting and renaming . These updates use different endpoints to the traditional updating. Important You are able to batch update sorting and color of tag objects through this method. If you only need to update single tags, it is recommended you use the class methods: sorting and color Info More information on Tag Object properties here Parameters: Name Type Description Default obj dict or list Single Tag (dict) : The tag dictionary object to update. Multiple Tags (list) : The tag dictionaries to update in a list. required Returns: Type Description dict or list Single Tag (dict) : The updated tag dictionary object. Multiple Tags (list) : The updated tag dictionaries in a list. Exceptions: Type Description TypeError If obj is not a dict or list. RuntimeError If the updating was unsuccessful. Updating Tags Single Tag Update Change a field directly in the task object then pass it to the method. See above for more information about what can actually be successfully changed through this method. # Lets say we have a tag named \"Fun\" that we want to change the color of. # We can change the color by updating the field directly. fun_tag = client . get_by_fields ( label = 'Fun' , search = 'tags' ) # Get the tag object new_color = '#d00000' fun_tag [ 'color' ] = new_color # Change the color updated_fun_tag = client . tag . update ( fun_tag ) # Pass the object to update. Result The updated tag dictionary object is returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#d00000' , 'etag' : 'i85c8ijo' } Before After Multiple Tag Update Changing the fields is the same as with updating a single tag, except you will need to pass the objects in a list to the method. # Lets update the colors for three tags: \"Fun\", \"Hobbies\", and \"Productivity\" fun_tag = client . get_by_fields ( label = \"Fun\" , search = 'tags' ) hobbies_tag = client . get_by_fields ( label = \"Hobbies\" , search = 'tags' ) productivity_tag = client . get_by_fields ( label = \"Productivity\" , search = 'tags' ) fun_color_new = \"#951a63\" hobbies_color_new = \"#0f8a1f\" productivity_color_new = \"#493293\" # Change the fields directly fun_tag [ 'color' ] = fun_color_new hobbies_tag [ 'color' ] = hobbies_color_new productivity_tag [ 'color' ] = productivity_color_new # The objects must be passed in a list update_tag_list = [ fun_tag , hobbies_tag , productivity_tag ] updated_tags = client . tag . update ( update_tag_list ) Result The updated task dictionary objects are returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 1099511627776 , 'sortType' : 'project' , 'color' : '#951a63' , 'etag' : 'n543ajq2' }, { 'name' : 'hobbies' , 'label' : 'Hobbies' , 'sortOrder' : - 549755813888 , 'sortType' : 'project' , 'color' : '#0f8a1f' , 'etag' : 'j4nspkg4' }, { 'name' : 'productivity' , 'label' : 'Productivity' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#493293' , 'etag' : '34qz9bzq' }] Before After Source code in managers/tags.py @logged_in def update ( self , obj ): \"\"\" Generic update method. Supports single and batch tag update. !!! important Updating tag properties like `parent` and renaming tags must be completed through their respective class methods to work: [nesting][managers.tags.TagsManager.nesting] and [renaming][managers.tags.TagsManager.rename]. These updates use different endpoints to the traditional updating. !!! important You are able to batch update sorting and color of tag objects through this method. If you only need to update single tags, it is recommended you use the class methods: [sorting][managers.tags.TagsManager.sorting] and [color][managers.tags.TagsManager.color] !!! info More information on Tag Object properties [here](tags.md#example-ticktick-tag-dictionary) Arguments: obj (dict or list): **Single Tag (dict)**: The tag dictionary object to update. **Multiple Tags (list)**: The tag dictionaries to update in a list. Returns: dict or list: **Single Tag (dict)**: The updated tag dictionary object. **Multiple Tags (list)**: The updated tag dictionaries in a list. Raises: TypeError: If `obj` is not a dict or list. RuntimeError: If the updating was unsuccessful. !!! example \"Updating Tags\" === \"Single Tag Update\" Change a field directly in the task object then pass it to the method. See above for more information about what can actually be successfully changed through this method. ```python # Lets say we have a tag named \"Fun\" that we want to change the color of. # We can change the color by updating the field directly. fun_tag = client.get_by_fields(label='Fun', search='tags') # Get the tag object new_color = '#d00000' fun_tag['color'] = new_color # Change the color updated_fun_tag = client.tag.update(fun_tag) # Pass the object to update. ``` ??? success \"Result\" The updated tag dictionary object is returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#d00000', 'etag': 'i85c8ijo'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104669635-4aca0e00-568f-11eb-8bc6-9572a432b623.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104669824-ac8a7800-568f-11eb-93d6-ac40235bcd3f.png) === \"Multiple Tag Update\" Changing the fields is the same as with updating a single tag, except you will need to pass the objects in a list to the method. ```python # Lets update the colors for three tags: \"Fun\", \"Hobbies\", and \"Productivity\" fun_tag = client.get_by_fields(label=\"Fun\", search='tags') hobbies_tag = client.get_by_fields(label=\"Hobbies\", search='tags') productivity_tag = client.get_by_fields(label=\"Productivity\", search='tags') fun_color_new = \"#951a63\" hobbies_color_new = \"#0f8a1f\" productivity_color_new = \"#493293\" # Change the fields directly fun_tag['color'] = fun_color_new hobbies_tag['color'] = hobbies_color_new productivity_tag['color'] = productivity_color_new # The objects must be passed in a list update_tag_list = [fun_tag, hobbies_tag, productivity_tag] updated_tags = client.tag.update(update_tag_list) ``` ??? success \"Result\" The updated task dictionary objects are returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': -1099511627776, 'sortType': 'project', 'color': '#951a63', 'etag': 'n543ajq2'}, {'name': 'hobbies', 'label': 'Hobbies', 'sortOrder': -549755813888, 'sortType': 'project', 'color': '#0f8a1f', 'etag': 'j4nspkg4'}, {'name': 'productivity', 'label': 'Productivity', 'sortOrder': 0, 'sortType': 'project', 'color': '#493293', 'etag': '34qz9bzq'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104670498-cd070200-5690-11eb-9fdd-0287fa6c7e7b.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104670531-dc864b00-5690-11eb-844a-899031335922.png) \"\"\" batch = False # Bool signifying batch create or not if isinstance ( obj , list ): # Batch tag creation triggered obj_list = obj # Assuming all correct objects batch = True else : if not isinstance ( obj , dict ): raise TypeError ( 'Required Positional Argument Must Be A Dict or List of Tag Objects' ) if not batch : obj_list = [ obj ] url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : obj_list } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if not batch : return self . _client . get_by_etag ( self . _client . parse_etag ( response ), search = 'tags' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'name' ] for x in obj_list ] # Tag names are in order items = [ '' ] * len ( obj_list ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here actual_etag = etag [ tag ] # Get the actual etag found = self . _client . get_by_etag ( actual_etag , search = 'tags' ) items [ index ] = found # Place at the correct index return items","title":"Tags"},{"location":"usage/tags/#example-ticktick-tag-dictionary","text":"Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values name The lowercase of label 'books' str N/A label The uppercase of name 'Books' str N/A sortOrder A sort ID relative to other tags. 2748779069440 int N/A sortType Sort type of the tag dueDate str dueDate , project , title , priority color Hex color code string #4AA6EF str N/A etag Etag identifier. 'ji35exmv' str N/A parent name field of the parent tag 'friends' str N/A { 'name' : 'test' , 'label' : 'Test' , 'sortOrder' : 2748779069440 , 'sortType' : 'project' , 'color' : '#4AA6EF' , 'etag' : 'zxdvlhqd' , 'parent' : 'friends' }","title":"Example TickTick Tag Dictionary"},{"location":"usage/tags/#sort-dictionary","text":"SORT_DICTIONARY The sort dictionary maps integers to the different sort types possible for tags. It is a public member called SORT_DICTIONARY available through the tag public member of the TickTickClient instance. Descriptions Value Sort Type 0 'project' 1 'dueDate' 2 'title' 3 'priority'","title":"Sort Dictionary"},{"location":"usage/tags/#managers.tags.TagsManager","text":"Handles all interactions for tags.","title":"TagsManager"},{"location":"usage/tags/#managers.tags.TagsManager.builder","text":"Creates and returns a local tag object. Helper method for create to make batch creating projects easier. Note The parent tag must already exist prior to calling this method. Parameters: Name Type Description Default label str Desired label of the tag - tag labels cannot be repeated. required color str Hex color string. A random color will be generated if no color is specified. 'random' parent str The label of the parent tag if desired (include capitals in the label if it exists). None sort int The desired sort type of the tag. Valid integer values are present in the sort dictionary . The default sort value will be by 'project' None Returns: Type Description dict A dictionary containing all the fields necessary to create a tag remotely. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Tag label already exists. ValueError Parent tag does not exist. ValueError The hex string color inputted is invalid. Example tag_name = 'Books' # The name for our tag parent_name = 'Productivity' # The desired parent tag -> this should already exist. color_code = '#1387c4' sort_type = 1 # Sort by `dueDate` tag_object = client . tag . builder ( tag_name , parent = parent_name , color = color_code , sort = sort_type ) Result The required fields to create a tag object are created and returned in a dictionary. { 'label' : 'Fiction' , 'color' : '#1387c4' , 'parent' : 'books' , 'sortType' : 'dueDate' , 'name' : 'fiction' } Source code in managers/tags.py def builder ( self , label : str , color : str = 'random' , parent : str = None , sort : int = None ) -> dict : \"\"\" Creates and returns a local tag object. Helper method for [create][managers.tags.TagsManager.create] to make batch creating projects easier. !!! note The parent tag must already exist prior to calling this method. Arguments: label: Desired label of the tag - tag labels cannot be repeated. color: Hex color string. A random color will be generated if no color is specified. parent: The label of the parent tag if desired (include capitals in the label if it exists). sort: The desired sort type of the tag. Valid integer values are present in the [sort dictionary](tags.md#sort-dictionary). The default sort value will be by 'project' Returns: A dictionary containing all the fields necessary to create a tag remotely. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Tag label already exists. ValueError: Parent tag does not exist. ValueError: The hex string color inputted is invalid. !!! example ```python tag_name = 'Books' # The name for our tag parent_name = 'Productivity' # The desired parent tag -> this should already exist. color_code = '#1387c4' sort_type = 1 # Sort by `dueDate` tag_object = client.tag.builder(tag_name, parent=parent_name, color=color_code, sort=sort_type) ``` ??? success \"Result\" The required fields to create a tag object are created and returned in a dictionary. ```python {'label': 'Fiction', 'color': '#1387c4', 'parent': 'books', 'sortType': 'dueDate', 'name': 'fiction'} ``` \"\"\" # Perform checks return self . _check_fields ( label , color = color , parent_label = parent , sort = sort )","title":"builder()"},{"location":"usage/tags/#managers.tags.TagsManager.color","text":"Change the color of a tag. For batch changing colors, see update . Parameters: Name Type Description Default label str The label of the tag to be changed. required color str The new desired hex color string. required Returns: Type Description dict The updated tag dictionary object. Exceptions: Type Description TypeError If label or color are not strings. ValueError If the tag label does not exist. ValueError If color is not a valid hex color string. RuntimeError If changing the color was not successful. Changing a Tag's Color # Lets assume that we have a tag named \"Movies\" that we want to change the color for. new_color = '#134397' movies_updated = client . tag . color ( 'Movies' , new_color ) Result The updated tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#134397' , 'etag' : 'wwb49yfr' } Before After Source code in managers/tags.py @logged_in def color ( self , label : str , color : str ) -> dict : \"\"\" Change the color of a tag. For batch changing colors, see [update][managers.tags.TagsManager.update]. Arguments: label: The label of the tag to be changed. color: The new desired hex color string. Returns: The updated tag dictionary object. Raises: TypeError: If `label` or `color` are not strings. ValueError: If the tag `label` does not exist. ValueError: If `color` is not a valid hex color string. RuntimeError: If changing the color was not successful. !!! example \"Changing a Tag's Color\" ```python # Lets assume that we have a tag named \"Movies\" that we want to change the color for. new_color = '#134397' movies_updated = client.tag.color('Movies', new_color) ``` ??? success \"Result\" The updated tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#134397', 'etag': 'wwb49yfr'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104661749-0eda7d00-567e-11eb-836f-3a8851bcf9a5.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104661860-55c87280-567e-11eb-93b5-054fa4f1104a.png) \"\"\" if not isinstance ( label , str ) or not isinstance ( color , str ): raise TypeError ( 'Label and Color Must Be Strings' ) # Get the object label = label . lower () obj = self . _client . get_by_fields ( name = label , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Update\" ) # Check the color if not check_hex_color ( color ): raise ValueError ( f \"Hex Color String ' { color } ' Is Not Valid\" ) obj [ 'color' ] = color # Set the color url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]])","title":"color()"},{"location":"usage/tags/#managers.tags.TagsManager.create","text":"Creates a tag remotely. Supports single tag creation or batch tag creation. Tip Allows creation with a label that may normally not be allowed by TickTick for tags. Normal TickTick excluded characters are: \\ / \" # : * ? < > | Space Parameters: Name Type Description Default label str or list Single Tag (str) : The desired label of the tag. Tag labels cannot be repeated. Multiple Tags (list) : A list of tag objects created using the builder method. required color str Hex color string. A random color will be generated if no color is specified. 'random' parent str The label of the parent tag if desired (include capitals in if it exists). None sort int The desired sort type of the tag. Valid integer values are present in the sort dictionary . The default sort value will be by 'project' None Returns: Type Description dict or list Single Tag (dict) : The created tag object dictionary. Multiple Tags (list) : A list of the created tag object dictionaries. Exceptions: Type Description TypeError If any of the types of the arguments are wrong. ValueError Tag label already exists. ValueError Parent tag does not exist. ValueError The hex string color inputted is invalid. RuntimeError The tag(s) could not be created. Single Tag Just A Label tag = client . tag . create ( 'Fun' ) Result The tag object dictionary is returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#9b69f3' , 'etag' : '7fc8zb58' } Our tag is created. Specify a Color A random color can be generated using generate_hex_color . However, just not specifying a color will automatically generate a random color (as seen in the previous tab) You can always specify the color that you want. tag = client . tag . create ( 'Fun' , color = '#86bb6d' ) Result The tag object dictionary is returned and our project is created with the color specified. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#86bb6d' , 'etag' : '8bzzdws3' } Specifying a Parent Tag Tags can be nested one level. To create a tag that is nested, include the label of the parent tag. The parent tag should already exist. tag = client . tag . create ( 'Fun' , parent = 'Hobbies' ) Result The tag object dictionary is returned and our tag is created nested under the parent tag. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#d2a6e4' , 'etag' : 'nauticx1' , 'parent' : 'hobbies' } Before After Sort Type You can specify the sort type of the created tag using integer values from the sort dictionary . tag = client . tag . create ( 'Fun' , sort = 2 ) # Sort by `title` Result The tag object dictionary is returned and our tag has the specified sort type. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'title' , 'color' : '#e7e7ba' , 'etag' : 'n4k3pezc' } Multiple Tag Creation (batch) To create multiple tags, build the tag objects first using the builder method. Pass in a list of the project objects to create them remotely. parent_tag = client . tag . create ( 'Hobbies' ) # Create a parent tag. # We will create tag objects using builder that will be nested under the parent tag fun_tag = client . tag . builder ( 'Fun' , sort = 2 , parent = 'Hobbies' ) read_tag = client . tag . builder ( 'Read' , color = '#d2a6e4' , parent = 'Hobbies' ) movie_tag = client . tag . builder ( 'Movies' , parent = 'Hobbies' ) # Create the tags tag_list = [ fun_tag , read_tag , movie_tag ] created_tags = client . tag . create ( tag_list ) Result The tag object dictionaries are returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 0 , 'sortType' : 'title' , 'color' : '#172d1c' , 'etag' : '1tceclp4' , 'parent' : 'hobbies' }, { 'name' : 'read' , 'label' : 'Read' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#d2a6e4' , 'etag' : 'ykdem8dg' , 'parent' : 'hobbies' }, { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#94a5f8' , 'etag' : 'o0nifkbv' , 'parent' : 'hobbies' }] Source code in managers/tags.py @logged_in def create ( self , label , color : str = 'random' , parent : str = None , sort : int = None ): \"\"\" Creates a tag remotely. Supports single tag creation or batch tag creation. !!! tip Allows creation with a label that may normally not be allowed by `TickTick` for tags. Normal `TickTick` excluded characters are: \\\\ / \" # : * ? < > | Space Arguments: label (str or list): **Single Tag (str)**: The desired label of the tag. Tag labels cannot be repeated. **Multiple Tags (list)**: A list of tag objects created using the [builder][managers.tags.TagsManager.builder] method. color: Hex color string. A random color will be generated if no color is specified. parent: The label of the parent tag if desired (include capitals in if it exists). sort: The desired sort type of the tag. Valid integer values are present in the [sort dictionary](tags.md#sort-dictionary). The default sort value will be by 'project' Returns: dict or list: **Single Tag (dict)**: The created tag object dictionary. **Multiple Tags (list)**: A list of the created tag object dictionaries. Raises: TypeError: If any of the types of the arguments are wrong. ValueError: Tag label already exists. ValueError: Parent tag does not exist. ValueError: The hex string color inputted is invalid. RuntimeError: The tag(s) could not be created. !!! example \"Single Tag\" === \"Just A Label\" ```python tag = client.tag.create('Fun') ``` ??? success \"Result\" The tag object dictionary is returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#9b69f3', 'etag': '7fc8zb58'} ``` Our tag is created. ![image](https://user-images.githubusercontent.com/56806733/104658773-5bbb5500-5678-11eb-9d44-27214203d70e.png) === \"Specify a Color\" A random color can be generated using [generate_hex_color][helpers.hex_color.generate_hex_color]. However, just not specifying a color will automatically generate a random color (as seen in the previous tab) You can always specify the color that you want. ```python tag = client.tag.create('Fun', color='#86bb6d') ``` ??? success \"Result\" The tag object dictionary is returned and our project is created with the color specified. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#86bb6d', 'etag': '8bzzdws3'} ``` ![image](https://user-images.githubusercontent.com/56806733/104659184-0c295900-5679-11eb-9f3c-2cd154c0500c.png) === \"Specifying a Parent Tag\" Tags can be nested one level. To create a tag that is nested, include the label of the parent tag. The parent tag should already exist. ```python tag = client.tag.create('Fun', parent='Hobbies') ``` ??? success \"Result\" The tag object dictionary is returned and our tag is created nested under the parent tag. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'project', 'color': '#d2a6e4', 'etag': 'nauticx1', 'parent': 'hobbies'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104659785-24e63e80-567a-11eb-9a62-01ebca55e649.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104659814-33ccf100-567a-11eb-8dca-c91aea68b4c7.png) === \"Sort Type\" You can specify the sort type of the created tag using integer values from the [sort dictionary](#sort-dictionary). ```python tag = client.tag.create('Fun', sort=2) # Sort by `title` ``` ??? success \"Result\" The tag object dictionary is returned and our tag has the specified sort type. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'title', 'color': '#e7e7ba', 'etag': 'n4k3pezc'} ``` ![image](https://user-images.githubusercontent.com/56806733/104660156-e4d38b80-567a-11eb-8c61-8fb874a515a2.png) !!! example \"Multiple Tag Creation (batch)\" To create multiple tags, build the tag objects first using the [builder][managers.projects.ProjectManager.builder] method. Pass in a list of the project objects to create them remotely. ```python parent_tag = client.tag.create('Hobbies') # Create a parent tag. # We will create tag objects using builder that will be nested under the parent tag fun_tag = client.tag.builder('Fun', sort=2, parent='Hobbies') read_tag = client.tag.builder('Read', color='#d2a6e4', parent='Hobbies') movie_tag = client.tag.builder('Movies', parent='Hobbies') # Create the tags tag_list = [fun_tag, read_tag, movie_tag] created_tags = client.tag.create(tag_list) ``` ??? success \"Result\" The tag object dictionaries are returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': 0, 'sortType': 'title', 'color': '#172d1c', 'etag': '1tceclp4', 'parent': 'hobbies'}, {'name': 'read', 'label': 'Read', 'sortOrder': 0, 'sortType': 'project', 'color': '#d2a6e4', 'etag': 'ykdem8dg', 'parent': 'hobbies'}, {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#94a5f8', 'etag': 'o0nifkbv', 'parent': 'hobbies'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104660625-cb7f0f00-567b-11eb-8649-68646870ccfa.png) \"\"\" batch = False # Bool signifying batch create or not if isinstance ( label , list ): # Batch tag creation triggered obj = label # Assuming all correct objects batch = True else : if not isinstance ( label , str ): raise TypeError ( 'Required Positional Argument Must Be A String or List of Tag Objects' ) # Create a single object obj = self . builder ( label = label , color = color , parent = parent , sort = sort ) if not batch : obj = [ obj ] url = self . _client . BASE_URL + 'batch/tag' payload = { 'add' : obj } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if not batch : return self . _client . get_by_etag ( self . _client . parse_etag ( response ), search = 'tags' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'name' ] for x in obj ] # Tag names are in order items = [ '' ] * len ( obj ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here actual_etag = etag [ tag ] # Get the actual etag found = self . _client . get_by_etag ( actual_etag , search = 'tags' ) items [ index ] = found # Place at the correct index if len ( items ) == 1 : return items [ 0 ] else : return items","title":"create()"},{"location":"usage/tags/#managers.tags.TagsManager.delete","text":"Delete tag(s). Supports single tag deletion and \"mock\" batch tag deletion. Info Batch deleting for tags is not supported by TickTick. However, passing in a list of labels to delete will \"mock\" batch deleting - but individual requests will have to be made for each deletion. Parameters: Name Type Description Default label str or list Single Tag (str) : The label of the tag. Multiple Tags (list) : A list of tag label strings. required Returns: Type Description dict or list Single Tag (dict) : The dictionary object of the deleted tag. Multiple Tags (list) : The dictionary objects of the deleted tags in a list. Exceptions: Type Description TypeError If label is not a string or list. ValueError If a label does not exist. RuntimeError If the tag could not be deleted successfully. Tag Deletion Single Tag Deletion Deleting a single tag requires passing in the label string of the tag. # Lets delete a tag named \"Fun\" delete_tag = client . tag . delete ( \"Fun\" ) Result The dictionary object of the deleted tag returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 3298534883328 , 'sortType' : 'project' , 'color' : '#A9949E' , 'etag' : '32balm5l' } Before \"Fun\" Tag Exists After \"Fun\" Tag Does Not Exist Multiple Tag Deletion Deleting multiple tags requires passing the label strings of the tags in a list. # Lets delete tags named \"Fun\", \"Movies\", and \"Hobbies\" delete_labels = [ \"Fun\" , \"Movies\" , \"Hobbies\" ] deleted_tags = client . tag . delete ( delete_labels ) Result The dictionary object of the deleted tags returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 3848290697216 , 'sortType' : 'project' , 'color' : '#FFD966' , 'etag' : '56aa6dva' }, { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : - 2748779069440 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 's0czro3e' }, { 'name' : 'hobbies' , 'label' : 'Hobbies' , 'sortOrder' : - 2199023255552 , 'sortType' : 'project' , 'color' : '#ABA6B5' , 'etag' : 'shu2xbvq' }] Before All three tags exist. After All three tags don't exist. Source code in managers/tags.py @logged_in def delete ( self , label ): \"\"\" Delete tag(s). Supports single tag deletion and \"mock\" batch tag deletion. !!! info Batch deleting for tags is not supported by TickTick. However, passing in a list of labels to delete will \"mock\" batch deleting - but individual requests will have to be made for each deletion. Arguments: label (str or list): **Single Tag (str)**: The label of the tag. **Multiple Tags (list)**: A list of tag label strings. Returns: dict or list: **Single Tag (dict)**: The dictionary object of the deleted tag. **Multiple Tags (list)**: The dictionary objects of the deleted tags in a list. Raises: TypeError: If `label` is not a string or list. ValueError: If a label does not exist. RuntimeError: If the tag could not be deleted successfully. !!! example \"Tag Deletion\" === \"Single Tag Deletion\" Deleting a single tag requires passing in the label string of the tag. ```python # Lets delete a tag named \"Fun\" delete_tag = client.tag.delete(\"Fun\") ``` ??? success \"Result\" The dictionary object of the deleted tag returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': -3298534883328, 'sortType': 'project', 'color': '#A9949E', 'etag': '32balm5l'} ``` **Before** \"Fun\" Tag Exists ![image](https://user-images.githubusercontent.com/56806733/104668024-2c164800-568c-11eb-853e-5b7eba1f4528.png) **After** \"Fun\" Tag Does Not Exist ![image](https://user-images.githubusercontent.com/56806733/104667768-ac887900-568b-11eb-9bfb-597c752e4c3b.png) === \"Multiple Tag Deletion\" Deleting multiple tags requires passing the label strings of the tags in a list. ```python # Lets delete tags named \"Fun\", \"Movies\", and \"Hobbies\" delete_labels = [\"Fun\", \"Movies\", \"Hobbies\"] deleted_tags = client.tag.delete(delete_labels) ``` ??? success \"Result\" The dictionary object of the deleted tags returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': -3848290697216, 'sortType': 'project', 'color': '#FFD966', 'etag': '56aa6dva'}, {'name': 'movies', 'label': 'Movies', 'sortOrder': -2748779069440, 'sortType': 'dueDate', 'color': '#134397', 'etag': 's0czro3e'}, {'name': 'hobbies', 'label': 'Hobbies', 'sortOrder': -2199023255552, 'sortType': 'project', 'color': '#ABA6B5', 'etag': 'shu2xbvq'}] ``` **Before** All three tags exist. ![image](https://user-images.githubusercontent.com/56806733/104668135-61bb3100-568c-11eb-8707-314deb42cd1d.png) **After** All three tags don't exist. ![image](https://user-images.githubusercontent.com/56806733/104668185-7b5c7880-568c-11eb-8da0-aaee68d53500.png) \"\"\" # Determine if the tag exists if not isinstance ( label , str ) and not isinstance ( label , list ): raise TypeError ( 'Label Must Be A String or List Of Strings' ) url = self . _client . BASE_URL + 'tag' if isinstance ( label , str ): label = [ label ] # If a singular string we are going to add it to a list objects = [] for lbl in label : if not isinstance ( lbl , str ): raise TypeError ( f \"' { lbl } ' Must Be A String\" ) lbl = lbl . lower () tag_obj = self . _client . get_by_fields ( name = lbl , search = 'tags' ) # Get the tag object if not tag_obj : raise ValueError ( f \"Tag ' { lbl } ' Does Not Exist To Delete\" ) # We can assume that only one tag has the name params = { 'name' : tag_obj [ 'name' ] } response = self . _client . http_delete ( url , params = params , cookies = self . _client . cookies ) # Find the tag in the tags list and delete it, then return the deleted object objects . append ( self . _client . delete_from_local_state ( search = 'tags' , etag = tag_obj [ 'etag' ])) self . _client . sync () if len ( objects ) == 1 : return objects [ 0 ] else : return objects","title":"delete()"},{"location":"usage/tags/#managers.tags.TagsManager.merge","text":"Merges the tasks of the passed tags into the argument merged and deletes all the tags except merged Args can be individual label strings, or a list of strings Parameters: Name Type Description Default label str or list Single Tag (str) : The label string of the tag to merge. Multiple Tags (list) : The label strings of the tags to merge in a list. required merged str The label of the tag that will remain after the merge. required Returns: Type Description dict The tag dictionary object that remains after the merge. Exceptions: Type Description TypeError If merged is not a str or if label is not a str or list. ValueError If any of the labels do not exist. RuntimeError If the merge could not be successfully completed. Merging Tags Merging Two Tags Merging two tags requires the label of the tag that you want kept after the merge, and the label of the tag that will be merged. Lets assume that we have two tags: \"Work\" and \"School\". I want to merge the tag \"School\" into \"Work\". What should happen is that any tasks that are tagged \"School\", will be updated to have the tag \"Work\", and the \"School\" tag will be deleted. merged_tags = client . tag . merge ( \"School\" , \"Work\" ) Result The tag that remains after the merge is returned. { 'name' : 'work' , 'label' : 'Work' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#3876E4' , 'etag' : 'eeh8zrup' } Before \"School\" has two tasks that have it's tag. \"Work\" has no tasks. After \"School\" has been deleted. The tasks that used to be tagged with \"School\" are now tagged with \"Work\". Merging Three Or More Tags Merging multiple tags into a single tag requires passing the labels of the tags to merge in a list. Lets assume that we have three tags: \"Work\", \"School\", and \"Hobbies\" . I want to merge the tag \"School\" and the tag \"Hobbies\" into \"Work\". What should happen is that any tasks that are tagged with \"School\" or \"Hobbies\", will be updated to have the tag \"Work\", and the \"School\" and \"Hobbies\" tags will be deleted. merge_tags = [ \"School\" , \"Hobbies\" ] result = client . tag . merge ( merge_tags , \"Work\" ) Result The tag that remains after the merge is returned. { 'name' : 'work' , 'label' : 'Work' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#3876E4' , 'etag' : 'ke23lp06' } Before \"School\" has two tasks. \"Hobbies\" has two tasks. \"Work\" has one task. After \"Work\" has five tasks now, and the tags \"School\" and \"Hobbies\" have been deleted. Source code in managers/tags.py @logged_in def merge ( self , label , merged : str ): \"\"\" Merges the tasks of the passed tags into the argument `merged` and deletes all the tags except `merged` Args can be individual label strings, or a list of strings Arguments: label (str or list): **Single Tag (str)**: The label string of the tag to merge. **Multiple Tags (list)**: The label strings of the tags to merge in a list. merged: The label of the tag that will remain after the merge. Returns: dict: The tag dictionary object that remains after the merge. Raises: TypeError: If `merged` is not a str or if `label` is not a str or list. ValueError: If any of the labels do not exist. RuntimeError: If the merge could not be successfully completed. !!! example \"Merging Tags\" === \"Merging Two Tags\" Merging two tags requires the label of the tag that you want kept after the merge, and the label of the tag that will be merged. Lets assume that we have two tags: \"Work\" and \"School\". I want to merge the tag \"School\" into \"Work\". What should happen is that any tasks that are tagged \"School\", will be updated to have the tag \"Work\", and the \"School\" tag will be deleted. ```python merged_tags = client.tag.merge(\"School\", \"Work\") ``` ??? success \"Result\" The tag that remains after the merge is returned. ```python {'name': 'work', 'label': 'Work', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#3876E4', 'etag': 'eeh8zrup'} ``` **Before** \"School\" has two tasks that have it's tag. ![image](https://user-images.githubusercontent.com/56806733/104680244-45c38980-56a4-11eb-968d-884160c77247.png) \"Work\" has no tasks. ![image](https://user-images.githubusercontent.com/56806733/104680366-90dd9c80-56a4-11eb-975f-5e769e9ea491.png) **After** \"School\" has been deleted. The tasks that used to be tagged with \"School\" are now tagged with \"Work\". ![image](https://user-images.githubusercontent.com/56806733/104680576-0c3f4e00-56a5-11eb-9536-ef3a7fcf20ec.png) === \"Merging Three Or More Tags\" Merging multiple tags into a single tag requires passing the labels of the tags to merge in a list. Lets assume that we have three tags: \"Work\", \"School\", and \"Hobbies\" . I want to merge the tag \"School\" and the tag \"Hobbies\" into \"Work\". What should happen is that any tasks that are tagged with \"School\" or \"Hobbies\", will be updated to have the tag \"Work\", and the \"School\" and \"Hobbies\" tags will be deleted. ```python merge_tags = [\"School\", \"Hobbies\"] result = client.tag.merge(merge_tags, \"Work\") ``` ??? success \"Result\" The tag that remains after the merge is returned. ```python {'name': 'work', 'label': 'Work', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#3876E4', 'etag': 'ke23lp06'} ``` **Before** \"School\" has two tasks. ![image](https://user-images.githubusercontent.com/56806733/104681135-7ad0db80-56a6-11eb-81dd-03e4a151cfd9.png) \"Hobbies\" has two tasks. ![image](https://user-images.githubusercontent.com/56806733/104681104-67257500-56a6-11eb-99b0-57bbb876a59e.png) \"Work\" has one task. ![image](https://user-images.githubusercontent.com/56806733/104681164-89b78e00-56a6-11eb-99a8-c85ef418d2a0.png) **After** \"Work\" has five tasks now, and the tags \"School\" and \"Hobbies\" have been deleted. ![image](https://user-images.githubusercontent.com/56806733/104681239-b7043c00-56a6-11eb-9b45-5522b9c69cb0.png) \"\"\" # Make sure merged is a string if not isinstance ( merged , str ): raise ValueError ( 'Merged Must Be A String' ) # Make sure label is a string or list if not isinstance ( label , str ) and not isinstance ( label , list ): raise ValueError ( f \"Label must be a string or a list.\" ) # Lowercase merged merged = merged . lower () # Make sure merged exists kept_obj = self . _client . get_by_fields ( name = merged , search = 'tags' ) if not kept_obj : raise ValueError ( f \"Kept Tag ' { merged } ' Does Not Exist To Merge\" ) merge_queue = [] # Verify all args are valid, and add them to a list if isinstance ( label , str ): string = label . lower () # Make sure it exists retrieved = self . _client . get_by_fields ( name = string , search = 'tags' ) if not retrieved : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Merge\" ) merge_queue . append ( retrieved ) else : for item in label : # Loop through the items in the list and check items are a string and exist # Make sure the item is a string if not isinstance ( item , str ): raise ValueError ( f \"Item ' { item } ' Must Be A String\" ) string = item . lower () # Make sure it exists found = self . _client . get_by_fields ( name = string , search = 'tags' ) if not found : raise ValueError ( f \"Tag ' { item } ' Does Not Exist To Merge\" ) merge_queue . append ( found ) for labels in merge_queue : # Merge url = self . _client . BASE_URL + 'tag/merge' payload = { 'name' : labels [ 'name' ], 'newName' : kept_obj [ 'name' ] } self . _client . http_put ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () return kept_obj","title":"merge()"},{"location":"usage/tags/#managers.tags.TagsManager.nesting","text":"Update tag nesting. Move an already created tag to be nested underneath a parent tag - or ungroup an already nested tag. Nesting Tags More Than One Level Does Not Work Example Nesting Explanation Parent Tag -> Level Zero Child Tag 1 -> Level One: This is the most nesting that is allowed by TickTick for tags. Child Tag 2 -> Level Two: Not allowed Parameters: Name Type Description Default child str Label of the tag to become the child required parent str Label of the tag that will become the parent. required Returns: Type Description dict The updated tag object dictionary. Exceptions: Type Description TypeError If child and parent are not strings ValueError If child does not exist to update. ValueError If parent does not exist. RuntimeError If setting the parent was unsuccessful. Nesting Nesting A Tag To nest a tag underneath another tag, pass in the labels of the child and parent. # Lets assume that we have a tag named \"Movies\" # We have another tag named \"Hobbies\" that we want to make the parent to \"Movies\" child = \"Movies\" parent = \"Hobbies\" nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'ee34aft9' , 'parent' : 'hobbies' } Before After Changing The Parent Of An Already Nested Tag If the tag is already nested, changing the parent is still no different. # We have a tag named \"Movies\" that is already nested underneath \"Hobbies\" # We want to nest \"Movies\" underneath the tag \"Fun\" instead. child = \"Movies\" parent = \"Fun\" nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : '91qpuq71' , 'parent' : 'fun' } Before After Un-grouping A Child Tag If the tag is nested and you want to ungroup it, pass in None for parent . # We have a tag named \"Movies\" that is nested underneath \"Fun\" # We don't want to have \"Movies\" nested anymore. child = \"Movies\" parent = None nesting_update = client . tag . nesting ( child , parent ) Result The updated child tag dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'jcoc94p6' } Before After Source code in managers/tags.py @logged_in def nesting ( self , child : str , parent : str ) -> dict : \"\"\" Update tag nesting. Move an already created tag to be nested underneath a parent tag - or ungroup an already nested tag. !!! warning \"Nesting Tags More Than One Level Does Not Work\" !!! example === \"Nesting Explanation\" ```md Parent Tag -> Level Zero Child Tag 1 -> Level One: This is the most nesting that is allowed by TickTick for tags. Child Tag 2 -> Level Two: Not allowed ``` Arguments: child: Label of the tag to become the child parent: Label of the tag that will become the parent. Returns: The updated tag object dictionary. Raises: TypeError: If `child` and `parent` are not strings ValueError: If `child` does not exist to update. ValueError: If `parent` does not exist. RuntimeError: If setting the parent was unsuccessful. !!! example \"Nesting\" === \"Nesting A Tag\" To nest a tag underneath another tag, pass in the labels of the child and parent. ```python # Lets assume that we have a tag named \"Movies\" # We have another tag named \"Hobbies\" that we want to make the parent to \"Movies\" child = \"Movies\" parent = \"Hobbies\" nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'ee34aft9', 'parent': 'hobbies'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104665300-da6abf00-5685-11eb-947f-889187cec008.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104665366-f706f700-5685-11eb-93eb-9316befec5fc.png) === \"Changing The Parent Of An Already Nested Tag\" If the tag is already nested, changing the parent is still no different. ```python # We have a tag named \"Movies\" that is already nested underneath \"Hobbies\" # We want to nest \"Movies\" underneath the tag \"Fun\" instead. child = \"Movies\" parent = \"Fun\" nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': '91qpuq71', 'parent': 'fun'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104665599-ab088200-5686-11eb-8b36-5ee873289db7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104665821-35e97c80-5687-11eb-8098-426816970f3e.png) === \"Un-grouping A Child Tag\" If the tag is nested and you want to ungroup it, pass in `None` for `parent`. ```python # We have a tag named \"Movies\" that is nested underneath \"Fun\" # We don't want to have \"Movies\" nested anymore. child = \"Movies\" parent = None nesting_update = client.tag.nesting(child, parent) ``` ??? success \"Result\" The updated child tag dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'jcoc94p6'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104666038-be681d00-5687-11eb-8490-83c370977267.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104666080-dcce1880-5687-11eb-9ca8-5abcdb4109ba.png) \"\"\" if not isinstance ( child , str ): raise TypeError ( 'Inputs Must Be Strings' ) if parent is not None : if not isinstance ( parent , str ): raise TypeError ( 'Inputs Must Be Strings' ) # Get the object child = child . lower () obj = self . _client . get_by_fields ( name = child , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { child } ' Does Not Exist To Update\" ) # Four Cases # Case 1: No Parent -> Want a Parent # Case 2: No Parent -> Doesn't Want a Parent # Case 3: Has Parent -> Wants a Different Parent # Case 4: Has Parent -> Doesn't Want a Parent # Case 1: Determine if the object has a parent try : if obj [ 'parent' ]: # It has a parent if parent is not None : # Case 3 # check if the parent is already the same, if it is just return if obj [ 'parent' ] == parent . lower (): return obj else : new_p = parent . lower () obj [ 'parent' ] = new_p else : new_p = obj [ 'parent' ] # Case 4 obj [ 'parent' ] = '' elif obj [ 'parent' ] is None : raise ValueError ( 'Parent Does Not Exist' ) except KeyError : # It does not have a parent if parent is not None : # Wants a different parent new_p = parent . lower () # -> Case 1 obj [ 'parent' ] = new_p else : # Doesn't want a parent -> Case 2 return obj # We don't have to do anything if no parent and doesn't want a parent # Have to find the project pobj = self . _client . get_by_fields ( name = new_p , search = 'tags' ) if not pobj : raise ValueError ( f \"Tag ' { parent } ' Does Not Exist To Set As Parent\" ) url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ pobj , obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]], search = 'tags' )","title":"nesting()"},{"location":"usage/tags/#managers.tags.TagsManager.rename","text":"Renames a tag. Parameters: Name Type Description Default old str Current label of the tag to be changed. required new str Desired new label of the tag. required Returns: Type Description dict The tag object with the updated label. Exceptions: Type Description TypeError If old and new are not strings. ValueError If the old tag label does not exist. ValueError If the new tag label already exists. RuntimeError If the renaming was unsuccessful. Changing a Tag's Label Pass in the current label of the tag, and the desired new label of the tag. # Lets assume that we have a tag that already exists named \"Movie\" old_label = \"Movie\" new_label = \"Movies\" updated_tag = client . tag . rename ( old_label , new_label ) Result The updated tag object dictionary is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#134397' , 'etag' : 'qer1jygy' } Before After Source code in managers/tags.py @logged_in def rename ( self , old : str , new : str ) -> dict : \"\"\" Renames a tag. Arguments: old: Current label of the tag to be changed. new: Desired new label of the tag. Returns: The tag object with the updated label. Raises: TypeError: If `old` and `new` are not strings. ValueError: If the `old` tag label does not exist. ValueError: If the `new` tag label already exists. RuntimeError: If the renaming was unsuccessful. !!! example \"Changing a Tag's Label\" Pass in the current label of the tag, and the desired new label of the tag. ```python # Lets assume that we have a tag that already exists named \"Movie\" old_label = \"Movie\" new_label = \"Movies\" updated_tag = client.tag.rename(old_label, new_label) ``` ??? success \"Result\" The updated tag object dictionary is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'project', 'color': '#134397', 'etag': 'qer1jygy'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104661255-fcac0f00-567c-11eb-9f10-69af8b50e0b4.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104661299-19e0dd80-567d-11eb-825f-758d83178295.png) \"\"\" # Check that both old and new are strings if not isinstance ( old , str ) or not isinstance ( new , str ): raise TypeError ( 'Old and New Must Be Strings' ) # Make sure the old tag exists old = old . lower () # Check if the tag object exists obj = self . _client . get_by_fields ( name = old , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { old } ' Does Not Exist To Rename\" ) # Make sure the new tag does not exist temp_new = new . lower () # Check if the tag object exists found = self . _client . get_by_fields ( name = temp_new , search = 'tags' ) if found : raise ValueError ( f \"Name ' { new } ' Already Exists -> Cannot Duplicate Name\" ) url = self . _client . BASE_URL + 'tag/rename' payload = { 'name' : obj [ 'name' ], 'newName' : new } response = self . _client . http_put ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () # Response from TickTick does not return the new etag of the object, we must find it ourselves new_obj = self . _client . get_by_fields ( name = temp_new , search = 'tags' ) # Return the etag of the updated object return self . _client . get_by_etag ( new_obj [ 'etag' ], search = 'tags' )","title":"rename()"},{"location":"usage/tags/#managers.tags.TagsManager.sorting","text":"Change the sort type of a tag. For batch changing sort types, see update . Parameters: Name Type Description Default label str The label of the tag to be changed. required sort int The new sort type specified by an integer 0-3. See sort dictionary . required Returns: Type Description dict The updated tag dictionary object. Exceptions: Type Description TypeError If label is not a string or if sort is not an int. ValueError If the tag label does not exist. RuntimeError If the updating was unsuccessful. Changing the Sort Type # Lets assume that we have a tag named \"Movies\" with the sort type \"project\" changed_sort_type = client . tag . sorting ( \"Movies\" , 1 ) # Sort by 'dueDate' Result The updated task dictionary object is returned. { 'name' : 'movies' , 'label' : 'Movies' , 'sortOrder' : 0 , 'sortType' : 'dueDate' , 'color' : '#134397' , 'etag' : 'fflj8iy0' } Before After Source code in managers/tags.py @logged_in def sorting ( self , label : str , sort : int ) -> dict : \"\"\" Change the sort type of a tag. For batch changing sort types, see [update][managers.tags.TagsManager.update]. Arguments: label: The label of the tag to be changed. sort: The new sort type specified by an integer 0-3. See [sort dictionary](tags.md#sort-dictionary). Returns: The updated tag dictionary object. Raises: TypeError: If `label` is not a string or if `sort` is not an int. ValueError: If the tag `label` does not exist. RuntimeError: If the updating was unsuccessful. !!! example \"Changing the Sort Type\" ```python # Lets assume that we have a tag named \"Movies\" with the sort type \"project\" changed_sort_type = client.tag.sorting(\"Movies\", 1) # Sort by 'dueDate' ``` ??? success \"Result\" The updated task dictionary object is returned. ```python {'name': 'movies', 'label': 'Movies', 'sortOrder': 0, 'sortType': 'dueDate', 'color': '#134397', 'etag': 'fflj8iy0'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104663625-3f241a80-5682-11eb-93a7-73d280c59b3e.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104663663-5531db00-5682-11eb-9440-5673a70840b4.png) \"\"\" if not isinstance ( label , str ) or not isinstance ( sort , int ): raise TypeError ( 'Label Must Be A String and Sort Must Be An Int' ) # Get the object label = label . lower () obj = self . _client . get_by_fields ( name = label , search = 'tags' ) if not obj : raise ValueError ( f \"Tag ' { label } ' Does Not Exist To Update\" ) sort = self . _sort_string_value ( sort ) # Get the sort string for the value obj [ 'sortType' ] = sort # set the object field url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : [ obj ] } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () return self . _client . get_by_etag ( response [ 'id2etag' ][ obj [ 'name' ]])","title":"sorting()"},{"location":"usage/tags/#managers.tags.TagsManager.update","text":"Generic update method. Supports single and batch tag update. Important Updating tag properties like parent and renaming tags must be completed through their respective class methods to work: nesting and renaming . These updates use different endpoints to the traditional updating. Important You are able to batch update sorting and color of tag objects through this method. If you only need to update single tags, it is recommended you use the class methods: sorting and color Info More information on Tag Object properties here Parameters: Name Type Description Default obj dict or list Single Tag (dict) : The tag dictionary object to update. Multiple Tags (list) : The tag dictionaries to update in a list. required Returns: Type Description dict or list Single Tag (dict) : The updated tag dictionary object. Multiple Tags (list) : The updated tag dictionaries in a list. Exceptions: Type Description TypeError If obj is not a dict or list. RuntimeError If the updating was unsuccessful. Updating Tags Single Tag Update Change a field directly in the task object then pass it to the method. See above for more information about what can actually be successfully changed through this method. # Lets say we have a tag named \"Fun\" that we want to change the color of. # We can change the color by updating the field directly. fun_tag = client . get_by_fields ( label = 'Fun' , search = 'tags' ) # Get the tag object new_color = '#d00000' fun_tag [ 'color' ] = new_color # Change the color updated_fun_tag = client . tag . update ( fun_tag ) # Pass the object to update. Result The updated tag dictionary object is returned. { 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : 2199023255552 , 'sortType' : 'project' , 'color' : '#d00000' , 'etag' : 'i85c8ijo' } Before After Multiple Tag Update Changing the fields is the same as with updating a single tag, except you will need to pass the objects in a list to the method. # Lets update the colors for three tags: \"Fun\", \"Hobbies\", and \"Productivity\" fun_tag = client . get_by_fields ( label = \"Fun\" , search = 'tags' ) hobbies_tag = client . get_by_fields ( label = \"Hobbies\" , search = 'tags' ) productivity_tag = client . get_by_fields ( label = \"Productivity\" , search = 'tags' ) fun_color_new = \"#951a63\" hobbies_color_new = \"#0f8a1f\" productivity_color_new = \"#493293\" # Change the fields directly fun_tag [ 'color' ] = fun_color_new hobbies_tag [ 'color' ] = hobbies_color_new productivity_tag [ 'color' ] = productivity_color_new # The objects must be passed in a list update_tag_list = [ fun_tag , hobbies_tag , productivity_tag ] updated_tags = client . tag . update ( update_tag_list ) Result The updated task dictionary objects are returned in a list. [{ 'name' : 'fun' , 'label' : 'Fun' , 'sortOrder' : - 1099511627776 , 'sortType' : 'project' , 'color' : '#951a63' , 'etag' : 'n543ajq2' }, { 'name' : 'hobbies' , 'label' : 'Hobbies' , 'sortOrder' : - 549755813888 , 'sortType' : 'project' , 'color' : '#0f8a1f' , 'etag' : 'j4nspkg4' }, { 'name' : 'productivity' , 'label' : 'Productivity' , 'sortOrder' : 0 , 'sortType' : 'project' , 'color' : '#493293' , 'etag' : '34qz9bzq' }] Before After Source code in managers/tags.py @logged_in def update ( self , obj ): \"\"\" Generic update method. Supports single and batch tag update. !!! important Updating tag properties like `parent` and renaming tags must be completed through their respective class methods to work: [nesting][managers.tags.TagsManager.nesting] and [renaming][managers.tags.TagsManager.rename]. These updates use different endpoints to the traditional updating. !!! important You are able to batch update sorting and color of tag objects through this method. If you only need to update single tags, it is recommended you use the class methods: [sorting][managers.tags.TagsManager.sorting] and [color][managers.tags.TagsManager.color] !!! info More information on Tag Object properties [here](tags.md#example-ticktick-tag-dictionary) Arguments: obj (dict or list): **Single Tag (dict)**: The tag dictionary object to update. **Multiple Tags (list)**: The tag dictionaries to update in a list. Returns: dict or list: **Single Tag (dict)**: The updated tag dictionary object. **Multiple Tags (list)**: The updated tag dictionaries in a list. Raises: TypeError: If `obj` is not a dict or list. RuntimeError: If the updating was unsuccessful. !!! example \"Updating Tags\" === \"Single Tag Update\" Change a field directly in the task object then pass it to the method. See above for more information about what can actually be successfully changed through this method. ```python # Lets say we have a tag named \"Fun\" that we want to change the color of. # We can change the color by updating the field directly. fun_tag = client.get_by_fields(label='Fun', search='tags') # Get the tag object new_color = '#d00000' fun_tag['color'] = new_color # Change the color updated_fun_tag = client.tag.update(fun_tag) # Pass the object to update. ``` ??? success \"Result\" The updated tag dictionary object is returned. ```python {'name': 'fun', 'label': 'Fun', 'sortOrder': 2199023255552, 'sortType': 'project', 'color': '#d00000', 'etag': 'i85c8ijo'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104669635-4aca0e00-568f-11eb-8bc6-9572a432b623.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104669824-ac8a7800-568f-11eb-93d6-ac40235bcd3f.png) === \"Multiple Tag Update\" Changing the fields is the same as with updating a single tag, except you will need to pass the objects in a list to the method. ```python # Lets update the colors for three tags: \"Fun\", \"Hobbies\", and \"Productivity\" fun_tag = client.get_by_fields(label=\"Fun\", search='tags') hobbies_tag = client.get_by_fields(label=\"Hobbies\", search='tags') productivity_tag = client.get_by_fields(label=\"Productivity\", search='tags') fun_color_new = \"#951a63\" hobbies_color_new = \"#0f8a1f\" productivity_color_new = \"#493293\" # Change the fields directly fun_tag['color'] = fun_color_new hobbies_tag['color'] = hobbies_color_new productivity_tag['color'] = productivity_color_new # The objects must be passed in a list update_tag_list = [fun_tag, hobbies_tag, productivity_tag] updated_tags = client.tag.update(update_tag_list) ``` ??? success \"Result\" The updated task dictionary objects are returned in a list. ```python [{'name': 'fun', 'label': 'Fun', 'sortOrder': -1099511627776, 'sortType': 'project', 'color': '#951a63', 'etag': 'n543ajq2'}, {'name': 'hobbies', 'label': 'Hobbies', 'sortOrder': -549755813888, 'sortType': 'project', 'color': '#0f8a1f', 'etag': 'j4nspkg4'}, {'name': 'productivity', 'label': 'Productivity', 'sortOrder': 0, 'sortType': 'project', 'color': '#493293', 'etag': '34qz9bzq'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104670498-cd070200-5690-11eb-9fdd-0287fa6c7e7b.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104670531-dc864b00-5690-11eb-844a-899031335922.png) \"\"\" batch = False # Bool signifying batch create or not if isinstance ( obj , list ): # Batch tag creation triggered obj_list = obj # Assuming all correct objects batch = True else : if not isinstance ( obj , dict ): raise TypeError ( 'Required Positional Argument Must Be A Dict or List of Tag Objects' ) if not batch : obj_list = [ obj ] url = self . _client . BASE_URL + 'batch/tag' payload = { 'update' : obj_list } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if not batch : return self . _client . get_by_etag ( self . _client . parse_etag ( response ), search = 'tags' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'name' ] for x in obj_list ] # Tag names are in order items = [ '' ] * len ( obj_list ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here actual_etag = etag [ tag ] # Get the actual etag found = self . _client . get_by_etag ( actual_etag , search = 'tags' ) items [ index ] = found # Place at the correct index return items","title":"update()"},{"location":"usage/tasks/","text":"Info Task methods are accessed through the task public member of your TickTickClient instance. # Assumes that 'client' is the name that references the TickTickClient instance. task = client . task . method () Question About Logging In or Other Functionality Available? API and Important Information Tip All supported methods are documented below with usage examples, take a look! All usage examples assume that client is the name referencing the TickTickClient instance Important! The datetime module must be imported to use dates. First Way: import datetime date = datetime . datetime ( 2021 , 1 , 1 ) Second Way: from datetime import datetime date = datetime ( 2021 , 1 , 1 ) Example TickTick Task Dictionary \u00b6 Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the task '5ffe93f3b04b35082bbce7b0' str N/A projectId The project ID for the task '5ffe96c88f08237f3d16fa57' str N/A sortOrder A sort ID relative to other tasks in the Project -1099511627776 int Lower sortOrder == Higher Position title The name of the task 'Deposit Funds' str N/A content Text that will go underneath the title of the object. 'This is a description\" str N/A desc N/A '' str N/A startDate The start date or time for the object. '2021-01-12T08:00:00.000+0000' str N/A dueDate The end date for the object. '2021-01-12T08:00:00.000+0000' str N/A timeZone Time zone for the object 'America/Los_Angeles' str N/A isFloating If the object should keep the same time regardless of change in time zone. False bool N/A isAllDay Specifies if the task has a specific time/duration. True bool N/A reminders Reminders for the task [{'id': '5ffe9ebcb04b35082bbce88f', 'trigger': 'TRIGGER:P0DT9H0M0S'}] list N/A repeatFirstDate First repeat date '2021-01-12T08:00:00.000+0000' str N/A exDate N/A [] list N/A priority Priority value 1 int 0 = None, 1 = Low, 3 = Med, 5 = High status Whether the task is complete or not 0 int 0 = Not Complete, 2 = Complete items If the task is a CHECKLIST - item dictionaries are stored in this list. [] list N/A progress Progress amount. 70 int 0-100 modifiedTime Time last modified. '2021-01-13T07:18:21.000+0000' str N/A deleted If the task is deleted. 0 int N/A createdTime Creation time. 2021-01-13T06:32:19.000+0000 str N/A etag Etag identifier. 'ji35exmv' str N/A creator Creator identifier. 447666584 int N/A tags Name of the tags in a list. ['friends', 'party'] list The tags will be lowercase. pomodoroSummaries Pomodoro summary for the task. [{'userId': 447666584, 'count': 1, 'estimatedPomo': 0, 'duration': 25}] list N/A focusSummaries Focus summary for the task. [{'userId': 447666584, 'pomoCount': 1, 'estimatedPomo': 0, 'estimatedDuration': 0, 'pomoDuration': 1500, 'stopwatchDuration': 0}] list N/A columnId If in a project with kanban view, this identifies which section it is in. '11b745ecab9f0799bf53eb70' str N/A childIds The ID's of any subtasks. ['5ffe97edb04b35082bbce832'] list N/A kind Determines if the task has a normal description, or item list description. 'TEXT' str 'TEXT' or 'CHECKLIST' { 'id' : '5ffe93f3b04b35082bbce7b0' , 'projectId' : '5ffe96c88f08237f3d16fa57' , 'sortOrder' : - 1099511627776 , 'title' : 'Deposit Funds' , 'content' : '' , 'desc' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 1 , 'status' : 0 , 'items' : [{ 'id' : '5ffe972eb04b35082bbce831' , 'status' : 0 , 'title' : 'Hellooo' , 'sortOrder' : 0 , 'startDate' : None , 'isAllDay' : False , 'timeZone' : 'America/Los_Angeles' , 'snoozeReminderTime' : None , 'completedTime' : None }], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:49:17.508+0000' , 'etag' : 'ji35exmv' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:19.000+0000' , 'creator' : 447666584 , 'tags' : [ 'friends' , 'party' ], 'pomodoroSummaries' : [], 'columnId' : '11b745ecab9f0799bf53eb70' , 'childIds' : [ '5ffe97edb04b35082bbce832' ], 'kind' : 'CHECKLIST' } TaskManager \u00b6 Handles all interactions for tasks. builder ( self , name , start = None , end = None , priority = 'none' , project = None , tags = None , content = '' , tz = None ) \u00b6 Builds a local task object with the passed fields. Performs proper error checking. This function serves as a helper for batch creating tasks in create . Parameters: Name Type Description Default name str Any string is valid. required start datetime Desired start time. None end datetime Desired end time. None priority str For a priority other than 'none': 'low', 'medium', 'high'. 'none' project str The id of the list (project) you want the task to be created in. The default will be your inbox. None tags list Single string for the label of the tag, or a list of strings of labels for many tags. None content str Desired text to go into the 'Description' field in the task. '' tz str Timezone string if you want to make your task for a timezone other than the timezone linked to your TickTick account. None Returns: Type Description dict A dictionary containing the proper fields needed for task creation. Exceptions: Type Description TypeError If any of the parameter types do not match as specified in the parameters table. Example start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = [ 'Party' , 'Friends' , 'Food' ] task = client . task . builder ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag ) Result A dictionary object containing the appropriate fields is returned. { 'startDate' : '2022-07-05T21:30:00+0000' , 'dueDate' : '2022-07-06T06:30:00+0000' , 'isAllDay' : False , 'timeZone' : 'America/Los_Angeles' , 'title' : \"Molly's Birthday\" , 'priority' : 3 , 'projectId' : 'inbox115781412' , 'tags' : [ 'Party' , 'Friends' , 'Food' ], 'content' : \"Be there at two and don't forget the snacks\" } Source code in managers/tasks.py @logged_in def builder ( self , name : str , start = None , end = None , priority : str = 'none' , project : str = None , tags : list = None , content : str = '' , tz : str = None ) -> dict : \"\"\" Builds a local task object with the passed fields. Performs proper error checking. This function serves as a helper for batch creating tasks in [`create`][managers.tasks.TaskManager.create]. Arguments: name: Any string is valid. start (datetime): Desired start time. end (datetime): Desired end time. priority: For a priority other than 'none': 'low', 'medium', 'high'. project: The id of the list (project) you want the task to be created in. The default will be your inbox. tags: Single string for the label of the tag, or a list of strings of labels for many tags. content: Desired text to go into the 'Description' field in the task. tz: Timezone string if you want to make your task for a timezone other than the timezone linked to your TickTick account. Returns: A dictionary containing the proper fields needed for task creation. Raises: TypeError: If any of the parameter types do not match as specified in the parameters table. !!! example ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = ['Party', 'Friends', 'Food'] task = client.task.builder(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag) ``` ??? success \"Result\" A dictionary object containing the appropriate fields is returned. ```python {'startDate': '2022-07-05T21:30:00+0000', 'dueDate': '2022-07-06T06:30:00+0000', 'isAllDay': False, 'timeZone': 'America/Los_Angeles', 'title': \"Molly's Birthday\", 'priority': 3, 'projectId': 'inbox115781412', 'tags': ['Party', 'Friends', 'Food'], 'content': \"Be there at two and don't forget the snacks\"} ``` \"\"\" return self . _task_field_checks ( task_name = name , priority = priority , project = project , tags = tags , content = content , start_date = start , end_date = end , time_zone = tz ) complete ( self , ids ) \u00b6 Marks the task(s) as complete. Supports single task completion and batch task completion. Parameters: Name Type Description Default ids str or list Single Task (str) : The ID string of the task. Multiple Tasks (list) : A list of ID strings for the tasks. required Returns: Type Description dict or list Single Task (dict) : The dictionary of the completed task. Multiple Tasks (list) : A list of dictionaries for the completed tasks. Exceptions: Type Description TypeError If ids is not a string or list. ValueError If ids is not a task that exists. RuntimeError If completing was unsuccessful. Task Completing Single Task Completion Pass the ID string of the task to complete. # Lets assume that we have a task named \"Go To Dentist\" that we want to mark as complete. dentist_task = client . get_by_fields ( title = 'Go To Dentist' , search = 'tasks' ) complete_task = client . task . complete ( dentist_task [ 'id' ]) # Pass the ID of the object Result The task is completed and the dictionary object returned. { 'id' : '5fff5009b04b355792c79397' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 99230924406784 , 'title' : 'Go To Dentist' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T19:56:11.000+0000' , 'etag' : 'djiiqso6' , 'deleted' : 0 , 'createdTime' : '2021-01-13T19:54:49.000+0000' , 'creator' : 6147345572 , 'kind' : 'TEXT' } Before After Multiple Tasks Completion Pass a list of ID strings to complete the tasks. # Lets assume that we have a task named \"Go To Dentist\" and a task named \"Go To Store\" dentist_task = client . get_by_fields ( title = 'Go To Dentist' , search = 'tasks' ) store_task = client . get_by_fields ( title = 'Go To Store' , search = 'tasks' ) ids = [ dentist_task [ 'id' ], store_task [ 'id' ]] completed_tasks = client . task . complete ( ids ) Result The tasks are completed and the dictionary objects returned in a list. [{ 'id' : '5fff5009b04b355792c79397' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 99230924406784 , 'title' : 'Go To Dentist' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2021-01-13T19:57:00.285+0000' , 'completedUserId' : 115781412 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T19:56:11.000+0000' , 'etag' : 'qq9drp8d' , 'deleted' : 0 , 'createdTime' : '2021-01-13T19:54:49.000+0000' , 'creator' : 215414317 , 'kind' : 'TEXT' }, { 'id' : '5fff51f3b04b355792c793e6' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 100330436034560 , 'title' : 'Go To Store' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T20:02:59.000+0000' , 'etag' : 'be8m3g3x' , 'deleted' : 0 , 'createdTime' : '2021-01-13T20:02:59.000+0000' , 'creator' : 215414317 , 'tags' : [], 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py @logged_in def complete ( self , ids ): \"\"\" Marks the task(s) as complete. Supports single task completion and batch task completion. Arguments: ids (str or list): **Single Task (str)**: The ID string of the task. **Multiple Tasks (list)**: A list of ID strings for the tasks. Returns: dict or list: **Single Task (dict)**: The dictionary of the completed task. **Multiple Tasks (list)**: A list of dictionaries for the completed tasks. Raises: TypeError: If `ids` is not a string or list. ValueError: If `ids` is not a task that exists. RuntimeError: If completing was unsuccessful. !!! example \"Task Completing\" === \"Single Task Completion\" Pass the ID string of the task to complete. ```python # Lets assume that we have a task named \"Go To Dentist\" that we want to mark as complete. dentist_task = client.get_by_fields(title='Go To Dentist', search='tasks') complete_task = client.task.complete(dentist_task['id']) # Pass the ID of the object ``` ??? success \"Result\" The task is completed and the dictionary object returned. ```python {'id': '5fff5009b04b355792c79397', 'projectId': 'inbox115781412', 'sortOrder': -99230924406784, 'title': 'Go To Dentist', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T19:56:11.000+0000', 'etag': 'djiiqso6', 'deleted': 0, 'createdTime': '2021-01-13T19:54:49.000+0000', 'creator': 6147345572, 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104503673-39510b00-5596-11eb-88df-88eeee9ab4b0.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104504069-c4ca9c00-5596-11eb-96c9-5698e19989ea.png) === \"Multiple Tasks Completion\" Pass a list of ID strings to complete the tasks. ```python # Lets assume that we have a task named \"Go To Dentist\" and a task named \"Go To Store\" dentist_task = client.get_by_fields(title='Go To Dentist', search='tasks') store_task = client.get_by_fields(title='Go To Store', search='tasks') ids = [dentist_task['id'], store_task['id']] completed_tasks = client.task.complete(ids) ``` ??? success \"Result\" The tasks are completed and the dictionary objects returned in a list. ```python [{'id': '5fff5009b04b355792c79397', 'projectId': 'inbox115781412', 'sortOrder': -99230924406784, 'title': 'Go To Dentist', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2021-01-13T19:57:00.285+0000', 'completedUserId': 115781412, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T19:56:11.000+0000', 'etag': 'qq9drp8d', 'deleted': 0, 'createdTime': '2021-01-13T19:54:49.000+0000', 'creator': 215414317, 'kind': 'TEXT'}, {'id': '5fff51f3b04b355792c793e6', 'projectId': 'inbox115781412', 'sortOrder': -100330436034560, 'title': 'Go To Store', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T20:02:59.000+0000', 'etag': 'be8m3g3x', 'deleted': 0, 'createdTime': '2021-01-13T20:02:59.000+0000', 'creator': 215414317, 'tags': [], 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104504451-4f130000-5597-11eb-9f92-386a6be10ca6.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104504511-6a7e0b00-5597-11eb-9855-c4edce01713b.png) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( \"Ids Must Be A String Or List Of Ids\" ) tasks = [] if isinstance ( ids , str ): task = self . _client . get_by_fields ( id = ids , search = 'tasks' ) if not task : raise ValueError ( 'The Task Does Not Exist To Mark As Complete' ) task [ 'status' ] = 2 # Complete tasks . append ( task ) else : for id in ids : task = self . _client . get_by_fields ( id = id , search = 'tasks' ) if not task : raise ValueError ( f \"'Task Id ' { id } ' Does Not Exist'\" ) task [ 'status' ] = 2 # Complete tasks . append ( task ) url = self . _client . BASE_URL + 'batch/task' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( tasks ) == 1 : return tasks [ 0 ] else : return tasks create ( self , name , start = None , end = None , priority = 'none' , project = None , tags = None , content = '' , tz = None ) \u00b6 Create a task. This method supports single and batch task creation. Parameters: Name Type Description Default name str Any string is valid. required start datetime Desired start time. None end datetime Desired end time. None priority str For a priority other than 'none': 'low', 'medium', 'high'. 'none' project str The id of the list (project) you want the task to be created in. The default will be your inbox. None tags list Single string for the label of the tag, or a list of strings of labels for many tags. None content str Desired text to go into the 'Description' field in the task. '' tz str Timezone string if you want to make your task for a timezone other than the timezone linked to your TickTick account. None Returns: Type Description dict Dictionary of created task object. Exceptions: Type Description TypeError If any of the parameter types do not match as specified in the parameters table. RunTimeError If the task could not be created successfully. Create A Single Task Creating a single task is simple - specify whatever parameters you want directly. Creating a single task will return the dictionary object of the created task. Just a Name title = \"Molly's Birthday\" task = client . task . create ( title ) Result Priority Priorities can be changed using the following strings: 'none' : Grey 'low' : Blue 'medium' : Yellow 'high' : Red title = \"Molly's Birthday\" task = client . task . create ( title , priority = 'medium' ) Result All Day Date An all day task is specified by using a datetime object without any hours, minutes, or seconds. You can pass your datetime object using either start or end for all day tasks. date = datetime ( 2022 , 7 , 5 ) # 7/5/2022 title = \"Molly's Birthday\" task = client . task . create ( title , start = date , priority = 'medium' ) Result Specific Duration A specific duration can be set by using datetime objects and specifying both the start and end times. start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' ) Result Content Content can be any string you want. Use escape sequences for newlines, tabs, etc. start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember ) Result Tags Single Tag : A single tag can be passed as a simple string for the name. The tag will be created if it doesn't already exist. start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = 'Party' task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag ) Result Multiple Tags : Multiple tags can be added to a task by including all the desired tag names in a list. start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = [ 'Party' , 'Friends' , 'Food' ] task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag ) Result Different Time Zone To create the task for a different time zone pass in a time zone string. Time Zone Help start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = [ 'Party' , 'Friends' , 'Food' ] timezone = 'America/Costa_Rica' # Notice the time zone in the result image task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag , tz = timezone ) Result Different Project Info To create your task inside of a different project other than your inbox, pass in the ID corresponding to the project that you want. Note Your project must exist before the creation of the task. # Lets assume that we have a project that is already created and named 'Birthday's' project_obj = client . get_by_fields ( name = \"Birthday's\" , search = 'projects' ) # Get the list (project) object birthdays_id = project_obj [ 'id' ] # Obtain the id of the object start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = [ 'Party' , 'Friends' , 'Food' ] task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag , project = birthdays_id ) Result Creating Multiple Tasks At Once (Batch) Creating multiple tasks is also simple, however we have to create the individual task objects before passing them to the create method. This is efficient on resources if you need to create multiple tasks at a single time since the same amount of requests will be required no matter how many tasks are being created at once. This is accomplished using the builder method. Create the task objects with builder and pass the objects you want to create in a list to the create method. If the creation was successful, the created tasks will be returned in the same order as the input in a list. All parameters supported with creating a single task are supported here as well. # Create three tasks in the inbox task1 = client . task . builder ( 'Hello I Am Task 1' ) task2 = client . task . builder ( 'Hello I Am Task 2' ) task3 = client . task . builder ( 'Hello I Am Task 3' ) task_objs = [ task1 , task2 , task3 ] created_tasks = client . task . create ( task_objs ) Result Source code in managers/tasks.py @logged_in def create ( self , name : str , start = None , end = None , priority : str = 'none' , project : str = None , tags : list = None , content : str = '' , tz : str = None , ) -> dict : \"\"\" Create a task. This method supports single and batch task creation. Arguments: name: Any string is valid. start (datetime): Desired start time. end (datetime): Desired end time. priority: For a priority other than 'none': 'low', 'medium', 'high'. project: The id of the list (project) you want the task to be created in. The default will be your inbox. tags: Single string for the label of the tag, or a list of strings of labels for many tags. content: Desired text to go into the 'Description' field in the task. tz: Timezone string if you want to make your task for a timezone other than the timezone linked to your TickTick account. Returns: Dictionary of created task object. Raises: TypeError: If any of the parameter types do not match as specified in the parameters table. RunTimeError: If the task could not be created successfully. !!! example \"Create A Single Task\" Creating a single task is simple - specify whatever parameters you want directly. Creating a single task will return the dictionary object of the created task. === \"Just a Name\" ```python title = \"Molly's Birthday\" task = client.task.create(title) ``` ??? success \"Result\" [![task-just-name.png](https://i.postimg.cc/TPDkqYwC/task-just-name.png)](https://postimg.cc/069d9v7w) === \"Priority\" Priorities can be changed using the following strings: - 'none' : <span style=\"color:grey\"> *Grey* </span> - 'low' : <span style=\"color:Blue\"> *Blue* </span> - 'medium' : <span style=\"color:#f5c71a\"> *Yellow* </span> - 'high' : <span style=\"color:Red\"> *Red* </span> ```python title = \"Molly's Birthday\" task = client.task.create(title, priority = 'medium') ``` ??? success \"Result\" [![task-priority.png](https://i.postimg.cc/QdrvMyqF/task-priority.png)](https://postimg.cc/ZCVw7j2m) === \"All Day Date\" An all day task is specified by using a `datetime` object without any hours, minutes, or seconds. You can pass your datetime object using either `start` or `end` for all day tasks. ```python date = datetime(2022, 7, 5) # 7/5/2022 title = \"Molly's Birthday\" task = client.task.create(title, start=date, priority='medium') ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![start-date.png](https://i.postimg.cc/PfQwcLF0/start-date.png)](https://postimg.cc/Lhh5gsSV) === \"Specific Duration\" A specific duration can be set by using `datetime` objects and specifying both the start and end times. ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" task = client.task.create(title, start=start_time, end=end_time, priority='medium') ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![duration2.png](https://i.postimg.cc/5tzHmjC7/duration2.png)](https://postimg.cc/xk0TffgM) === \"Content\" Content can be any string you want. Use escape sequences for newlines, tabs, etc. ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember) ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![content2.png](https://i.postimg.cc/285VK0WB/content2.png)](https://postimg.cc/SjwSX7Dy) === \"Tags\" **_Single Tag_:** A single tag can be passed as a simple string for the name. The tag will be created if it doesn't already exist. ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = 'Party' task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag) ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![tags1.png](https://i.postimg.cc/Y9ppmSfm/tags1.png)](https://postimg.cc/t1M0KpcX) **_Multiple Tags_:** Multiple tags can be added to a task by including all the desired tag names in a list. ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = ['Party', 'Friends', 'Food'] task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag) ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![tags2.png](https://i.postimg.cc/7PtxfwCf/tags2.png)](https://postimg.cc/3WpMqMFT) === \"Different Time Zone\" To create the task for a different time zone pass in a time zone string. [Time Zone Help](/usage/helpers/#time-zones) ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = ['Party', 'Friends', 'Food'] timezone = 'America/Costa_Rica' # Notice the time zone in the result image task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag, tz=timezone) ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![tz1.png](https://i.postimg.cc/dtrvVdGV/tz1.png)](https://postimg.cc/BXSRhjhr) === \"Different Project\" !!! info To create your task inside of a different [project](projects.md) other than your inbox, pass in the ID corresponding to the [project](projects.md) that you want. !!! note Your [project](projects.md) must exist before the creation of the task. ```python # Lets assume that we have a project that is already created and named 'Birthday's' project_obj = client.get_by_fields(name=\"Birthday's\", search='projects') # Get the list (project) object birthdays_id = project_obj['id'] # Obtain the id of the object start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = ['Party', 'Friends', 'Food'] task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag, project=birthdays_id) ``` ??? success \"Result\" [![different-list1.png](https://i.postimg.cc/ncN4vXR5/different-list1.png)](https://postimg.cc/1fcVS3Zc) --- [![different-list2.png](https://i.postimg.cc/Mpz8WmVb/different-list2.png)](https://postimg.cc/0bX4nmtb) !!! example \"Creating Multiple Tasks At Once (Batch)\" Creating multiple tasks is also simple, however we have to create the individual task objects before passing them to the `create` method. This is efficient on resources if you need to create multiple tasks at a single time since the same amount of requests will be required no matter how many tasks are being created at once. This is accomplished using the [`builder`][managers.tasks.TaskManager.builder] method. Create the task objects with [`builder`][managers.tasks.TaskManager.builder] and pass the objects you want to create in a list to the create method. If the creation was successful, the created tasks will be returned in the same order as the input in a list. All parameters supported with creating a single task are supported here as well. ```python # Create three tasks in the inbox task1 = client.task.builder('Hello I Am Task 1') task2 = client.task.builder('Hello I Am Task 2') task3 = client.task.builder('Hello I Am Task 3') task_objs = [task1, task2, task3] created_tasks = client.task.create(task_objs) ``` ??? success \"Result\" [![batch-task.png](https://i.postimg.cc/J0tq8nQW/batch-task.png)](https://postimg.cc/GTwYJbNM) \"\"\" if isinstance ( name , list ): # If task name is a list, we will batch create objects obj = name batch = True # Get task object elif isinstance ( name , str ): batch = False obj = self . builder ( name = name , start = start , end = end , priority = priority , project = project , tags = tags , content = content , tz = tz ) obj = [ obj ] else : raise TypeError ( f \"Required Positional Argument Must Be A String or List of Task Objects\" ) tag_list = [] for o in obj : for tag in o [ 'tags' ]: if self . _client . get_by_fields ( label = tag , search = 'tags' ): continue # Dont create the tag if it already exists tag_obj = self . _client . tag . builder ( tag ) same = False for objs in tag_list : if objs [ 'label' ] == tag_obj [ 'label' ]: same = True if not same : tag_list . append ( tag_obj ) # Batch create the tags if tag_list : tags = self . _client . tag . create ( tag_list ) if not batch : # For a single task we will just send it to the update return self . _client . task . update ( obj ) else : # We are going to create a unique identifier and append it to content. # We will be able to distinguish which task is which by this identifier # Once we find the tasks, we will make one more call to update to remove the # Identifier from the content string. ids = [] for task in obj : identifier = str ( uuid . uuid4 ()) # Identifier ids . append ( identifier ) task [ 'content' ] += identifier # Append the identifier onto the end of it url = self . _client . BASE_URL + 'batch/task' payload = { 'add' : obj } response = self . _client . session . post ( url , json = payload , cookies = self . _client . cookies ) if response . status_code != 200 and response . status_code != 500 : raise RuntimeError ( 'Could Not Complete Request' ) self . _client . sync () # We will find the tasks by their identifiers update_list = [ '' ] * len ( obj ) if batch : for tsk in self . _client . state [ 'tasks' ][:: - 1 ]: # Task List if len ( ids ) == 0 : break id = 0 for id in range ( len ( ids )): try : if ids [ id ] in tsk [ 'content' ]: tsk [ 'content' ] = tsk [ 'content' ] . replace ( ids [ id ], '' ) update_list [ id ] = tsk del ids [ id ] break except : break return self . _client . task . update ( update_list ) delete ( self , ids ) \u00b6 Deletes task(s). Supports single task deletion, and batch task deletion. Tip If a parent task is deleted - the children will remain (unlike normal parent task deletion in TickTick ) Parameters: Name Type Description Default ids str or list Single Task (str) : ID string of the task to be deleted. Multiple Tasks (list) : List of ID strings for the tasks to be deleted. required Returns: Type Description dict or list Single Task (dict) : Dictionary object of the deleted task. Multiple Tasks (list) : List of dictionary objects for the deleted tasks. Exceptions: Type Description TypeError If ids is not a string or list. ValueError If ids does not exist. RuntimeError If the deletion was unsuccessful. Task Deletion Single Task Deletion Pass the ID of the string to be deleted. # Lets assume that our task is named \"Dentist\" and it's in our inbox. task = client . get_by_fields ( title = \"Dentist\" , projectId = client . inbox_id , search = 'tasks' ) deleted_task = client . task . delete ( task [ 'id' ]) Result The deleted task object is returned. { 'id' : '5ffead3cb04b35082bbced71' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 2199023255552 , 'title' : 'Dentist' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T08:20:12.000+0000' , 'etag' : 'tijkifu0' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:20:12.000+0000' , 'creator' : 73561212 , 'tags' : [], 'kind' : 'TEXT' } Before After Multiple Task Deletion Pass a list of ID strings for the tasks to be deleted. # Lets assume we have two tasks we want to delete from our inbox - \"Dentist\" and \"Read\" dentist = client . get_by_fields ( title = \"Dentist\" , projectId = client . inbox_id , search = 'tasks' ) read = client . get_by_fields ( title = \"Read\" , projectId = client . inbox_id , search = 'tasks' ) id_list = [ dentist [ 'id' ], read [ 'id' ]] deleted_task = client . task . delete ( id_list ) Result A list of the deleted tasks is returned. [{ 'id' : '5ffeae528f081003f32cb661' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 1099511627776 , 'title' : 'Dentist' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:24:50.334+0000' , 'etag' : 'fwsrqx4j' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:24:50.340+0000' , 'creator' : 115781412 , 'kind' : 'TEXT' }, { 'id' : '5ffeae528f081003f32cb664' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 2199023255552 , 'title' : 'Read' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:24:50.603+0000' , 'etag' : '1sje21ao' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:24:50.609+0000' , 'creator' : 115781412 , 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py @logged_in def delete ( self , ids ): \"\"\" Deletes task(s). Supports single task deletion, and batch task deletion. !!! tip If a parent task is deleted - the children will remain (unlike normal parent task deletion in `TickTick`) Arguments: ids (str or list): **Single Task (str)**: ID string of the task to be deleted. **Multiple Tasks (list)**: List of ID strings for the tasks to be deleted. Returns: dict or list: **Single Task (dict)**: Dictionary object of the deleted task. **Multiple Tasks (list)**: List of dictionary objects for the deleted tasks. Raises: TypeError: If `ids` is not a string or list. ValueError: If `ids` does not exist. RuntimeError: If the deletion was unsuccessful. !!! example \"Task Deletion\" === \"Single Task Deletion\" Pass the ID of the string to be deleted. ```python # Lets assume that our task is named \"Dentist\" and it's in our inbox. task = client.get_by_fields(title=\"Dentist\", projectId=client.inbox_id, search='tasks') deleted_task = client.task.delete(task['id']) ``` ??? success \"Result\" The deleted task object is returned. ```python {'id': '5ffead3cb04b35082bbced71', 'projectId': 'inbox115781412', 'sortOrder': -2199023255552, 'title': 'Dentist', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T08:20:12.000+0000', 'etag': 'tijkifu0', 'deleted': 0, 'createdTime': '2021-01-13T08:20:12.000+0000', 'creator': 73561212, 'tags': [], 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104425305-615c5200-5535-11eb-93fa-3184b5d679b7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104425375-76d17c00-5535-11eb-9e12-3af1cf727957.png) === \"Multiple Task Deletion\" Pass a list of ID strings for the tasks to be deleted. ```python # Lets assume we have two tasks we want to delete from our inbox - \"Dentist\" and \"Read\" dentist = client.get_by_fields(title=\"Dentist\", projectId=client.inbox_id, search='tasks') read = client.get_by_fields(title=\"Read\", projectId=client.inbox_id, search='tasks') id_list = [dentist['id'], read['id']] deleted_task = client.task.delete(id_list) ``` ??? success \"Result\" A list of the deleted tasks is returned. ```python [{'id': '5ffeae528f081003f32cb661', 'projectId': 'inbox115781412', 'sortOrder': -1099511627776, 'title': 'Dentist', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:24:50.334+0000', 'etag': 'fwsrqx4j', 'deleted': 0, 'createdTime': '2021-01-13T08:24:50.340+0000', 'creator': 115781412, 'kind': 'TEXT'}, {'id': '5ffeae528f081003f32cb664', 'projectId': 'inbox115781412', 'sortOrder': -2199023255552, 'title': 'Read', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:24:50.603+0000', 'etag': '1sje21ao', 'deleted': 0, 'createdTime': '2021-01-13T08:24:50.609+0000', 'creator': 115781412, 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104425633-c4e67f80-5535-11eb-9735-bea3db63e0ab.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104425375-76d17c00-5535-11eb-9e12-3af1cf727957.png) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) tasks = [] if isinstance ( ids , str ): task = self . _client . get_by_fields ( id = ids , search = 'tasks' ) if not task : raise ValueError ( f \"Task ' { ids } ' Does Not Exist To Delete\" ) task = { 'projectId' : task [ 'projectId' ], 'taskId' : ids } tasks = [ task ] else : for id in ids : task = self . _client . get_by_fields ( id = id , search = 'tasks' ) if not task : raise ValueError ( f \"'Task Id ' { id } ' Does Not Exist'\" ) task = { 'projectId' : task [ 'projectId' ], 'taskId' : id } tasks . append ( task ) url = self . _client . BASE_URL + 'batch/task' payload = { 'delete' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) return_list = [] if len ( tasks ) == 1 : return_list . append ( self . _client . get_by_id ( ids , search = 'tasks' )) else : for item in tasks : o = self . _client . get_by_id ( item [ 'taskId' ], search = 'tasks' ) return_list . append ( o ) self . _client . sync () if len ( return_list ) == 1 : return return_list [ 0 ] return return_list get_completed ( self , start , end = None , full = True , tz = None ) \u00b6 Obtains all completed tasks from the given start date and end date. Note There is a limit of 100 items for the request Parameters: Name Type Description Default start datetime Start time datetime object. required end datetime End time datetime object. None full bool Boolean specifying whether hours, minutes, and seconds are to be taken into account for the query. True tz str String specifying a specific time zone, however this will default to your accounts normal time zone. None Returns: Type Description list A list containing all the completed tasks based on the times. Exceptions: Type Description TypeError If the proper types are not used. ValueError If start occurs after end. KeyError If the time zone string passed is not a valid time zone string. RuntimeError If getting the tasks is unsuccessful. Getting Completed Tasks Completed Tasks In A Single Day Getting the tasks for a full, complete day requires passing in the datetime object corresponding to the day that you want. # Get the tasks for 1/11/2021 tasks = client . task . get_completed ( datetime ( 2021 , 1 , 11 )) Result The list of completed tasks is returned. [{ 'id' : '5ffca35f4c201114702a0607' , 'projectId' : '004847faa60015487be444cb' , 'sortOrder' : - 50027779063826 , 'title' : 'Shoulders and Arms' , 'content' : '' , 'desc' : '' , 'startDate' : '2021-01-11T08:00:00.000+0000' , 'dueDate' : '2021-01-11T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'repeatFlag' : '' , 'exDate' : [], 'completedTime' : '2021-01-11T23:25:46.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-11T23:25:41.000+0000' , 'etag' : '6hlk4e8t' , 'deleted' : 0 , 'createdTime' : '2021-01-11T19:13:35.000+0000' , 'creator' : 185769383 , 'tags' : [ 'fitness' ], 'commentCount' : 0 , 'pomodoroSummaries' : [{ 'userId' : 185769383 , 'count' : 0 , 'estimatedPomo' : 0 , 'duration' : 0 }], 'focusSummaries' : [{ 'userId' : 185769383 , 'pomoCount' : 0 , 'estimatedPomo' : 0 , 'estimatedDuration' : 0 , 'pomoDuration' : 0 , 'stopwatchDuration' : 3720 }], 'kind' : 'TEXT' }] Completed Tasks Over A Range Of Days Getting the tasks for a range of days requires passing in datetime objects for the start day, and the end day that you want. # Get the tasks between 8/7/18 and 8/10/18 start = datetime ( 2018 , 8 , 7 ) end = datetime ( 2018 , 8 , 10 ) tasks = client . task . get_completed ( start , end ) Result Completed tasks in a list are returned. [{ 'id' : '5ffffebab04b355792c79e38' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 7696581394432 , 'title' : 'Ride Bike' , 'content' : '' , 'startDate' : '2021-01-14T08:00:00.000+0000' , 'dueDate' : '2021-01-14T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2018-08-09T07:20:11.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T08:21:01.000+0000' , 'etag' : 'mhjyig4y' , 'deleted' : 0 , 'createdTime' : '2021-01-14T08:20:10.000+0000' , 'creator' : 185769383 , 'kind' : 'TEXT' }, { 'id' : '5ffffeaab04b355792c79d89' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 6597069766656 , 'title' : 'Read Book' , 'content' : '' , 'startDate' : '2021-01-14T08:00:00.000+0000' , 'dueDate' : '2021-01-14T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2018-08-08T07:20:12.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T08:20:46.000+0000' , 'etag' : 'tzd4coms' , 'deleted' : 0 , 'createdTime' : '2021-01-14T08:19:54.000+0000' , 'creator' : 185769383 , 'kind' : 'TEXT' }] Completed Tasks Over A Specific Duration Of Time You can also get completed tasks that were completed in a specific time duration. Include specific hours, minutes, and seconds for the datetime objects, and specify full to be false -> meaning that the specific times will be put into effect. # Get the tasks completed between 12PM and 5PM on 12/15/2020 start = datetime ( 2020 , 12 , 15 , 12 ) # 12PM 12/15/2020 end = datetime ( 2020 , 12 , 15 , 17 ) # 5PM 12/15/2020 tasks = client . task . get_completed ( start , end , full = False ) Source code in managers/tasks.py @logged_in def get_completed ( self , start , end = None , full : bool = True , tz : str = None ) -> list : \"\"\" Obtains all completed tasks from the given start date and end date. !!! note There is a limit of 100 items for the request Arguments: start (datetime): Start time datetime object. end (datetime): End time datetime object. full: Boolean specifying whether hours, minutes, and seconds are to be taken into account for the query. tz: String specifying a specific time zone, however this will default to your accounts normal time zone. Returns: A list containing all the completed tasks based on the times. Raises: TypeError: If the proper types are not used. ValueError: If start occurs after end. KeyError: If the time zone string passed is not a valid time zone string. RuntimeError: If getting the tasks is unsuccessful. !!! example \"Getting Completed Tasks\" === \"Completed Tasks In A Single Day\" Getting the tasks for a full, complete day requires passing in the datetime object corresponding to the day that you want. ```python # Get the tasks for 1/11/2021 tasks = client.task.get_completed(datetime(2021, 1, 11)) ``` ??? success \"Result\" The list of completed tasks is returned. ```python [{'id': '5ffca35f4c201114702a0607', 'projectId': '004847faa60015487be444cb', 'sortOrder': -50027779063826, 'title': 'Shoulders and Arms', 'content': '', 'desc': '', 'startDate': '2021-01-11T08:00:00.000+0000', 'dueDate': '2021-01-11T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'repeatFlag': '', 'exDate': [], 'completedTime': '2021-01-11T23:25:46.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-11T23:25:41.000+0000', 'etag': '6hlk4e8t', 'deleted': 0, 'createdTime': '2021-01-11T19:13:35.000+0000', 'creator': 185769383, 'tags': ['fitness'], 'commentCount': 0, 'pomodoroSummaries': [{'userId': 185769383, 'count': 0, 'estimatedPomo': 0, 'duration': 0}], 'focusSummaries': [{'userId': 185769383, 'pomoCount': 0, 'estimatedPomo': 0, 'estimatedDuration': 0, 'pomoDuration': 0, 'stopwatchDuration': 3720}], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104562952-e1e68580-55fd-11eb-9e09-f432caa8616b.png) === \"Completed Tasks Over A Range Of Days\" Getting the tasks for a range of days requires passing in datetime objects for the start day, and the end day that you want. ```python # Get the tasks between 8/7/18 and 8/10/18 start = datetime(2018, 8, 7) end = datetime(2018, 8, 10) tasks = client.task.get_completed(start, end) ``` ??? success \"Result\" Completed tasks in a list are returned. ```python [{'id': '5ffffebab04b355792c79e38', 'projectId': 'inbox115781412', 'sortOrder': -7696581394432, 'title': 'Ride Bike', 'content': '', 'startDate': '2021-01-14T08:00:00.000+0000', 'dueDate': '2021-01-14T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2018-08-09T07:20:11.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T08:21:01.000+0000', 'etag': 'mhjyig4y', 'deleted': 0, 'createdTime': '2021-01-14T08:20:10.000+0000', 'creator': 185769383, 'kind': 'TEXT'}, {'id': '5ffffeaab04b355792c79d89', 'projectId': 'inbox115781412', 'sortOrder': -6597069766656, 'title': 'Read Book', 'content': '', 'startDate': '2021-01-14T08:00:00.000+0000', 'dueDate': '2021-01-14T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2018-08-08T07:20:12.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T08:20:46.000+0000', 'etag': 'tzd4coms', 'deleted': 0, 'createdTime': '2021-01-14T08:19:54.000+0000', 'creator': 185769383, 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104563478-8c5ea880-55fe-11eb-9bcf-91bc44c02083.png) === \"Completed Tasks Over A Specific Duration Of Time\" You can also get completed tasks that were completed in a specific time duration. Include specific hours, minutes, and seconds for the datetime objects, and specify `full` to be false -> meaning that the specific times will be put into effect. ```python # Get the tasks completed between 12PM and 5PM on 12/15/2020 start = datetime(2020, 12, 15, 12) # 12PM 12/15/2020 end = datetime(2020, 12, 15, 17) # 5PM 12/15/2020 tasks = client.task.get_completed(start, end, full=False) ``` \"\"\" url = self . _client . BASE_URL + 'project/all/completed' if tz is None : tz = self . _client . time_zone if not isinstance ( start , datetime . datetime ): raise TypeError ( 'Start Must Be A Datetime Object' ) if not isinstance ( end , datetime . datetime ) and end is not None : raise TypeError ( 'End Must Be A Datetime Object' ) # Handles case when start_date occurs after end_date if end is not None and start > end : raise ValueError ( 'Invalid Date Range: Start Date Occurs After End Date' ) # Handles invalid timezone argument if tz not in pytz . all_timezones_set : raise KeyError ( 'Invalid Time Zone' ) # Single Day Entry if end is None : start = datetime . datetime ( start . year , start . month , start . day , 0 , 0 , 0 ) end = datetime . datetime ( start . year , start . month , start . day , 23 , 59 , 59 ) # Multi DAy -> Full Day Entry elif full is True and end is not None : start = datetime . datetime ( start . year , start . month , start . day , 0 , 0 , 0 ) end = datetime . datetime ( end . year , end . month , end . day , 23 , 59 , 59 ) # Convert Local Time to UTC time based off the time_zone string specified start = convert_local_time_to_utc ( start , tz ) end = convert_local_time_to_utc ( end , tz ) parameters = { 'from' : start . strftime ( DATE_FORMAT ), 'to' : end . strftime ( DATE_FORMAT ), 'limit' : 100 } response = self . _client . http_get ( url , params = parameters , cookies = self . _client . cookies ) return response get_from_project ( self , project ) \u00b6 Obtains the tasks that are contained in the project. Parameters: Name Type Description Default project str ID string of the project to get the tasks from. required Returns: Type Description dict or list Single Task In Project (dict) : The single task object dictionary. Multiple Tasks In Project (list) : A list of task object dictionaries. No Tasks Found (list) : Empty list. Exceptions: Type Description ValueError If the project ID does not exist. Getting Uncompleted Tasks From The Inbox tasks = client . task . get_from_project ( client . inbox_id ) Result See Returns for the different return values based on the amount of tasks present in the project. [{ 'id' : '5ffe93efb04b35082bbce7af' , 'projectId' : 'inbox115781412' , 'sortOrder' : 2199023255552 , 'title' : 'Go To Library' , 'content' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:32:15.000+0000' , 'etag' : 'kkh0w1jk' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:15.000+0000' , 'creator' : 447666584 , 'tags' : [], 'kind' : 'TEXT' }, { 'id' : '5ffe93f3b04b35082bbce7b0' , 'projectId' : 'inbox115781412' , 'sortOrder' : 1099511627776 , 'title' : 'Deposit Funds' , 'content' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:32:19.000+0000' , 'etag' : 'w4hj21wf' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:19.000+0000' , 'creator' : 447666584 , 'tags' : [], 'kind' : 'TEXT' }] Source code in managers/tasks.py @logged_in def get_from_project ( self , project : str ): \"\"\" Obtains the tasks that are contained in the project. Arguments: project: ID string of the project to get the tasks from. Returns: dict or list: **Single Task In Project (dict)**: The single task object dictionary. **Multiple Tasks In Project (list)**: A list of task object dictionaries. **No Tasks Found (list)**: Empty list. Raises: ValueError: If the project ID does not exist. !!! example \"Getting Uncompleted Tasks From The Inbox\" ```python tasks = client.task.get_from_project(client.inbox_id) ``` ??? success \"Result\" See `Returns` for the different return values based on the amount of tasks present in the project. ```python [{'id': '5ffe93efb04b35082bbce7af', 'projectId': 'inbox115781412', 'sortOrder': 2199023255552, 'title': 'Go To Library', 'content': '', 'startDate': '2021-01-12T08:00:00.000+0000', 'dueDate': '2021-01-12T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T06:32:15.000+0000', 'etag': 'kkh0w1jk', 'deleted': 0, 'createdTime': '2021-01-13T06:32:15.000+0000', 'creator': 447666584, 'tags': [], 'kind': 'TEXT'}, {'id': '5ffe93f3b04b35082bbce7b0', 'projectId': 'inbox115781412', 'sortOrder': 1099511627776, 'title': 'Deposit Funds', 'content': '', 'startDate': '2021-01-12T08:00:00.000+0000', 'dueDate': '2021-01-12T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T06:32:19.000+0000', 'etag': 'w4hj21wf', 'deleted': 0, 'createdTime': '2021-01-13T06:32:19.000+0000', 'creator': 447666584, 'tags': [], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104415494-f86ddd80-5526-11eb-8b84-75bf3886ba46.png) \"\"\" # Make sure the project exists if project != self . _client . inbox_id : obj = self . _client . get_by_fields ( id = project , search = 'projects' ) if not obj : raise ValueError ( f \"List Id ' { project } ' Does Not Exist\" ) # Get the list of tasks that share the project id tasks = self . _client . get_by_fields ( projectId = project , search = 'tasks' ) if isinstance ( tasks , dict ): return [ tasks ] else : return tasks make_subtask ( self , obj , parent ) \u00b6 Makes the passed task(s) sub-tasks to the parent task. Important All of the tasks should already be created prior to using this method. Furthermore, the tasks should already be present in the same project as the parent task. Parameters: Name Type Description Default obj dict Single Sub-Task (dict) : The task object dictionary. Multiple Sub-Tasks (list) : A list of task object dictionaries. required parent str The ID of the task that will be the parent task. required Returns: Type Description dict Single Sub-Task (dict) : Created sub-task dictionary. Multiple Sub-Tasks (list) : List of created sub-task dictionaries. Exceptions: Type Description TypeError obj must be a dictionary or list of dictionaries. parent must be a string. ValueError If parent task doesn't exist. ValueError If obj does not share the same project as parent. RuntimeError If the creation was unsuccessful. Creating Sub-Tasks Single Sub-Task Creation Pass the task object that will be made a sub-task to the parent with the passed ID. # Lets make a task in our inbox named \"Read\" with a sub-task \"50 Pages\" read_task = client . task . create ( 'Read' ) pages_task = client . task . create ( '50 pages' ) now_subtask = client . task . make_subtask ( pages_task , read_task [ 'id' ]) Result The dictionary of the sub-task is returned. { 'id' : '5ffff4968f08af50b4654c6b' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 3298534883328 , 'title' : '50 pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:37:36.487+0000' , 'etag' : 'xv5cjzoz' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:36:54.751+0000' , 'creator' : 115781412 , 'parentId' : '5ffff4968f08af50b4654c62' , 'kind' : 'TEXT' } Before After Multiple Sub-Task Creation Pass all the tasks you want to make sub-tasks in a list. # Lets make a task in our inbox named \"Read\" with a sub-tasks \"50 Pages\", \"100 Pages\", and \"200 Pages\" read_task = client . task . create ( \"Read\" ) # Lets batch create our sub-tasks fifty_pages = client . task . builder ( '50 Pages' ) hundred_pages = client . task . builder ( '100 Pages' ) two_hundred_pages = client . task . builder ( '200 Pages' ) page_tasks = client . task . create ([ fifty_pages , hundred_pages , two_hundred_pages ]) # Make the page tasks sub-tasks to read_task subtasks = client . task . make_subtask ( page_tasks , read_task [ 'id' ]) Result A list of the sub-tasks is returned. [{ 'id' : '5ffff6348f082c11cc0da84d' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '50 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.032+0000' , 'etag' : 'avqm3u6o' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:48.858+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }, { 'id' : '5ffff6348f082c11cc0da84e' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '100 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.035+0000' , 'etag' : '6295mmmu' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:49.286+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }, { 'id' : '5ffff6348f082c11cc0da84f' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '200 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.038+0000' , 'etag' : 'du59zwck' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:49.315+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py @logged_in def make_subtask ( self , obj , parent : str ): \"\"\" Makes the passed task(s) sub-tasks to the parent task. !!! note \"Important\" All of the tasks should already be created prior to using this method. Furthermore, the tasks should already be present in the same project as the parent task. Arguments: obj (dict): **Single Sub-Task (dict)**: The task object dictionary. **Multiple Sub-Tasks (list)**: A list of task object dictionaries. parent (str): The ID of the task that will be the parent task. Returns: dict: **Single Sub-Task (dict)**: Created sub-task dictionary. **Multiple Sub-Tasks (list)**: List of created sub-task dictionaries. Raises: TypeError: `obj` must be a dictionary or list of dictionaries. `parent` must be a string. ValueError: If `parent` task doesn't exist. ValueError: If `obj` does not share the same project as parent. RuntimeError: If the creation was unsuccessful. !!! example \"Creating Sub-Tasks\" === \"Single Sub-Task Creation\" Pass the task object that will be made a sub-task to the parent with the passed ID. ```python # Lets make a task in our inbox named \"Read\" with a sub-task \"50 Pages\" read_task = client.task.create('Read') pages_task = client.task.create('50 pages') now_subtask = client.task.make_subtask(pages_task, read_task['id']) ``` ??? success \"Result\" The dictionary of the sub-task is returned. ```python {'id': '5ffff4968f08af50b4654c6b', 'projectId': 'inbox115781412', 'sortOrder': -3298534883328, 'title': '50 pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:37:36.487+0000', 'etag': 'xv5cjzoz', 'deleted': 0, 'createdTime': '2021-01-14T07:36:54.751+0000', 'creator': 115781412, 'parentId': '5ffff4968f08af50b4654c62', 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104558809-4272c400-55f8-11eb-8c55-e2f77c9d1ac8.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104558849-55859400-55f8-11eb-9692-c3e01aa73233.png) === \"Multiple Sub-Task Creation\" Pass all the tasks you want to make sub-tasks in a list. ```python # Lets make a task in our inbox named \"Read\" with a sub-tasks \"50 Pages\", \"100 Pages\", and \"200 Pages\" read_task = client.task.create(\"Read\") # Lets batch create our sub-tasks fifty_pages = client.task.builder('50 Pages') hundred_pages = client.task.builder('100 Pages') two_hundred_pages = client.task.builder('200 Pages') page_tasks = client.task.create([fifty_pages, hundred_pages, two_hundred_pages]) # Make the page tasks sub-tasks to read_task subtasks = client.task.make_subtask(page_tasks, read_task['id']) ``` ??? success \"Result\" A list of the sub-tasks is returned. ```python [{'id': '5ffff6348f082c11cc0da84d', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '50 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.032+0000', 'etag': 'avqm3u6o', 'deleted': 0, 'createdTime': '2021-01-14T07:43:48.858+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}, {'id': '5ffff6348f082c11cc0da84e', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '100 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.035+0000', 'etag': '6295mmmu', 'deleted': 0, 'createdTime': '2021-01-14T07:43:49.286+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}, {'id': '5ffff6348f082c11cc0da84f', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '200 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.038+0000', 'etag': 'du59zwck', 'deleted': 0, 'createdTime': '2021-01-14T07:43:49.315+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104559418-36d3cd00-55f9-11eb-9004-177671a92474.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104559535-64207b00-55f9-11eb-84cf-ca4f989ea075.png) \"\"\" if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( 'obj must be a dictionary or list of dictionaries' ) if not isinstance ( parent , str ): raise TypeError ( 'parent must be a string' ) if isinstance ( obj , dict ): obj = [ obj ] parent_obj = self . _client . get_by_id ( search = 'tasks' , obj_id = parent ) if not parent_obj : raise ValueError ( \"Parent task must exist before creating sub-tasks\" ) ids = [] # Go through obj and if the projects are different make them the same as parent for o in obj : if o [ 'projectId' ] != parent_obj [ 'projectId' ]: raise ValueError ( \"All tasks must be in the same project as the parent\" ) ids . append ( o [ 'id' ]) subtasks = [] for i in ids : # Create the object dictionaries for setting the subtask temp = { 'parentId' : parent , 'projectId' : parent_obj [ 'projectId' ], 'taskId' : i } subtasks . append ( temp ) url = self . _client . BASE_URL + 'batch/taskParent' response = self . _client . http_post ( url , json = subtasks , cookies = self . _client . cookies ) self . _client . sync () # Find and return the updated child objects subtasks = [] for task_id in ids : subtasks . append ( self . _client . get_by_id ( task_id , search = 'tasks' )) if len ( subtasks ) == 1 : return subtasks [ 0 ] # Return just the dictionary object if its a single task else : return subtasks move ( self , obj , new ) \u00b6 Moves task(s) from their current project to the new project. It will move the specified tasks with obj to the new project. Important If moving multiple tasks, they must all be from the same project. Parameters: Name Type Description Default obj dict or list Single Task (dict) : Pass the single task dictionary object to move. Multiple Tasks (list) : Pass a list of task dictionary objects to move. required new str The ID string of the project that the task(s) should be moved to. required Returns: Type Description dict or list Single Task (dict) : Returns the dictionary of the moved task. Multiple Tasks (list) : Returns a list of dictionaries for the moved tasks. Exceptions: Type Description TypeError If obj is not a dict or list or if new is not a str. ValueError For multiple tasks, if the projects are not all the same. ValueError If the new project does not exist. RuntimeError If the task(s) could not be successfully moved. Move Examples Moving A Single Task Pass in the task object, and the ID of the project the task should be moved to. # Lets assume that we have a task 'Read' that exists in a project named \"Work\" # Lets move that task to the inbox read_task = client . get_by_fields ( title = 'Read' , search = 'tasks' ) move_read_task = client . task . move ( read_task , client . inbox_id ) Result The dictionary object of the moved task is returned. { 'id' : '5fffed61b04b355792c799a8' , 'projectId' : 'inbox115781412' , 'sortOrder' : 0 , 'title' : 'Read' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:08:15.875+0000' , 'etag' : 'twrmcr55' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:06:09.000+0000' , 'creator' : 47593756 , 'tags' : [], 'kind' : 'TEXT' } Before After Moving Multiple Tasks Pass in the task objects in a list, and the ID of the project that tasks should be moved to. Again, the tasks in the list should all be from the same project. # Lets move two tasks: 'Read' and 'Write' that exist in a project named \"Work\" # Lets move the tasks to another project named \"Hobbies\" that already exists. hobbies_project = client . get_by_fields ( name = 'Hobbies' , search = 'projects' ) hobbies_id = hobbies_project [ 'id' ] # Id of the hobbies project read_task = client . get_by_fields ( title = 'Read' , search = 'tasks' ) write_task = client . get_by_fields ( title = 'Write' , search = 'tasks' ) move_tasks = client . task . move ([ read_task , write_task ], hobbies_id ) # Task objects in a list Result The tasks that were moved are returned in a list. [{ 'id' : '5ffff003b04b355792c799d3' , 'projectId' : '5fffeff68f08654c982c141a' , 'sortOrder' : 0 , 'title' : 'Read' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:19:28.595+0000' , 'etag' : 'co8jfqyn' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:17:23.000+0000' , 'creator' : 768495743 , 'kind' : 'TEXT' }, { 'id' : '5ffff004b04b355792c799d4' , 'projectId' : '5fffeff68f08654c982c141a' , 'sortOrder' : 0 , 'title' : 'Write' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:19:28.596+0000' , 'etag' : '5unkf7xg' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:17:24.000+0000' , 'creator' : 768495743 , 'tags' : [], 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py @logged_in def move ( self , obj , new : str ): \"\"\" Moves task(s) from their current project to the new project. It will move the specified tasks with `obj` to the new project. !!! important If moving multiple tasks, they must all be from the same project. Arguments: obj (dict or list): **Single Task (dict)**: Pass the single task dictionary object to move. **Multiple Tasks (list)**: Pass a list of task dictionary objects to move. new: The ID string of the project that the task(s) should be moved to. Returns: dict or list: **Single Task (dict)**: Returns the dictionary of the moved task. **Multiple Tasks (list)**: Returns a list of dictionaries for the moved tasks. Raises: TypeError: If `obj` is not a dict or list or if `new` is not a str. ValueError: For multiple tasks, if the projects are not all the same. ValueError: If the new project does not exist. RuntimeError: If the task(s) could not be successfully moved. !!! example \"Move Examples\" === \"Moving A Single Task\" Pass in the task object, and the ID of the project the task should be moved to. ```python # Lets assume that we have a task 'Read' that exists in a project named \"Work\" # Lets move that task to the inbox read_task = client.get_by_fields(title='Read', search='tasks') move_read_task = client.task.move(read_task, client.inbox_id) ``` ??? success \"Result\" The dictionary object of the moved task is returned. ```python {'id': '5fffed61b04b355792c799a8', 'projectId': 'inbox115781412', 'sortOrder': 0, 'title': 'Read', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:08:15.875+0000', 'etag': 'twrmcr55', 'deleted': 0, 'createdTime': '2021-01-14T07:06:09.000+0000', 'creator': 47593756, 'tags': [], 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104556170-f1f96780-55f3-11eb-9a35-aecc3beea105.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104556336-46044c00-55f4-11eb-98c1-4cffcf4bd006.png) === \"Moving Multiple Tasks\" Pass in the task objects in a list, and the ID of the project that tasks should be moved to. Again, the tasks in the list should all be from the same project. ```python # Lets move two tasks: 'Read' and 'Write' that exist in a project named \"Work\" # Lets move the tasks to another project named \"Hobbies\" that already exists. hobbies_project = client.get_by_fields(name='Hobbies', search='projects') hobbies_id = hobbies_project['id'] # Id of the hobbies project read_task = client.get_by_fields(title='Read', search='tasks') write_task = client.get_by_fields(title='Write', search='tasks') move_tasks = client.task.move([read_task, write_task], hobbies_id) # Task objects in a list ``` ??? success \"Result\" The tasks that were moved are returned in a list. ```python [{'id': '5ffff003b04b355792c799d3', 'projectId': '5fffeff68f08654c982c141a', 'sortOrder': 0, 'title': 'Read', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:19:28.595+0000', 'etag': 'co8jfqyn', 'deleted': 0, 'createdTime': '2021-01-14T07:17:23.000+0000', 'creator': 768495743, 'kind': 'TEXT'}, {'id': '5ffff004b04b355792c799d4', 'projectId': '5fffeff68f08654c982c141a', 'sortOrder': 0, 'title': 'Write', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:19:28.596+0000', 'etag': '5unkf7xg', 'deleted': 0, 'createdTime': '2021-01-14T07:17:24.000+0000', 'creator': 768495743, 'tags': [], 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104557103-857f6800-55f5-11eb-8b92-cf51bc159745.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104557388-063e6400-55f6-11eb-8ba4-aa64f3f739bd.png) \"\"\" # Type errors if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( 'obj should be a dict or list of dicts' ) if not isinstance ( new , str ): raise TypeError ( 'new should be a string' ) # Get the parent project if new != self . _client . inbox_id : project = self . _client . get_by_id ( new , search = 'projects' ) if not project : raise ValueError ( 'The ID for the new project does not exist' ) if isinstance ( obj , dict ): obj = [ obj ] # Go through and check that the projects are all the same move_tasks = [] project_id = obj [ 0 ][ 'projectId' ] for task in obj : if task [ 'projectId' ] != project_id : raise ValueError ( 'All the tasks must come from the same project' ) else : move_tasks . append ({ 'fromProjectId' : project_id , 'taskId' : task [ 'id' ], 'toProjectId' : new }) url = self . _client . BASE_URL + 'batch/taskProject' self . _client . http_post ( url , json = move_tasks , cookies = self . _client . cookies ) self . _client . sync () # Return the tasks in the new list ids = [ x [ 'id' ] for x in obj ] return_list = [] for i in ids : return_list . append ( self . _client . get_by_id ( i )) if len ( return_list ) == 1 : return return_list [ 0 ] else : return return_list move_all ( self , old , new ) \u00b6 Moves all the tasks from the old project to the new project. Parameters: Name Type Description Default old str ID of the old project. required new str ID of the new project. required Returns: Type Description list The tasks contained in the new project. Exceptions: Type Description ValueError If either the old or new projects do not exist. RuntimeError If the movement was unsuccessful. Example Lets assume that we have a project named \"School\", and another project named \"Work\". To move all the tasks from \"School\" to \"Work\": # Get the projects school_project = client . get_by_fields ( name = 'School' , search = 'projects' ) work_project = client . get_by_fields ( name = 'Work' , search = 'projects' ) # Call the method moved_tasks = client . task . move_projects ( school_project [ 'id' ], work_project [ 'id' ]) Result The tasks that were moved are returned. [{ 'id' : '5ffea9afe4b062d60dd62aef' , 'projectId' : '5ffea9afe4b062d60dd62aea' , 'sortOrder' : 0 , 'title' : 'Finish documentation for project' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:06:31.407+0000' , 'etag' : 'ogclghmd' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:05:03.901+0000' , 'creator' : 447666584 , 'kind' : 'TEXT' }, { 'id' : '5ffea9b0e4b062d60dd62af4' , 'projectId' : '5ffea9afe4b062d60dd62aea' , 'sortOrder' : 0 , 'title' : 'Call the boss man' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:06:31.409+0000' , 'etag' : '65c73q8i' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:05:04.117+0000' , 'creator' : 447666584 , 'kind' : 'TEXT' }] Before : Two tasks are contained in the \"School\" project After : The two tasks are moved to the 'Work' project Source code in managers/tasks.py @logged_in def move_all ( self , old : str , new : str ) -> list : \"\"\" Moves all the tasks from the old project to the new project. Arguments: old: ID of the old project. new: ID of the new project. Returns: The tasks contained in the new project. Raises: ValueError: If either the old or new projects do not exist. RuntimeError: If the movement was unsuccessful. !!! example Lets assume that we have a project named \"School\", and another project named \"Work\". To move all the tasks from \"School\" to \"Work\": ```python # Get the projects school_project = client.get_by_fields(name='School', search='projects') work_project = client.get_by_fields(name='Work', search='projects') # Call the method moved_tasks = client.task.move_projects(school_project['id'], work_project['id']) ``` ??? success \"Result\" The tasks that were moved are returned. ```python [{'id': '5ffea9afe4b062d60dd62aef', 'projectId': '5ffea9afe4b062d60dd62aea', 'sortOrder': 0, 'title': 'Finish documentation for project', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:06:31.407+0000', 'etag': 'ogclghmd', 'deleted': 0, 'createdTime': '2021-01-13T08:05:03.901+0000', 'creator': 447666584, 'kind': 'TEXT'}, {'id': '5ffea9b0e4b062d60dd62af4', 'projectId': '5ffea9afe4b062d60dd62aea', 'sortOrder': 0, 'title': 'Call the boss man', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:06:31.409+0000', 'etag': '65c73q8i', 'deleted': 0, 'createdTime': '2021-01-13T08:05:04.117+0000', 'creator': 447666584, 'kind': 'TEXT'}] ``` **Before**: Two tasks are contained in the \"School\" project ![image](https://user-images.githubusercontent.com/56806733/104423574-1e997a80-5533-11eb-9417-34c31e603d21.png) **After**: The two tasks are moved to the 'Work' project ![image](https://user-images.githubusercontent.com/56806733/104423710-4a1c6500-5533-11eb-90f3-2c3d024280af.png) \"\"\" # Make sure that old and new id's exist if old != self . _client . inbox_id : old_list = self . _client . get_by_fields ( id = old , search = 'projects' ) if not old_list : raise ValueError ( f \"Project Id ' { old } ' Does Not Exist\" ) if new != self . _client . inbox_id : new_list = self . _client . get_by_fields ( id = new , search = 'projects' ) if not new_list : raise ValueError ( f \"Project Id ' { new } ' Does Not Exist\" ) # Get the tasks from the old list tasks = self . get_from_project ( old ) if not tasks : return tasks # No tasks to move so just return the empty list task_project = [] # List containing all the tasks that will be updated for task in tasks : task_project . append ({ 'fromProjectId' : old , 'taskId' : task [ 'id' ], 'toProjectId' : new }) url = self . _client . BASE_URL + 'batch/taskProject' url2 = self . _client . BASE_URL + 'batch/task' # Make the initial call to move the tasks self . _client . http_post ( url , json = task_project , cookies = self . _client . cookies ) self . _client . sync () # Return the tasks in the new list return self . _client . task . get_from_project ( new ) update ( self , obj ) \u00b6 Updates task(s) remotely. Supports single task update and batch task update. To update a task, change any field in it's dictionary directly then pass to the method. For Help On What Fields Are Present In The Task Dictionaries Example TickTick Task Dictionary Parameters: Name Type Description Default obj dict or list Single Task (dict) : The changed task dictionary object. Multiple Tasks (list) : The changed task dictionary objects in a list. required Returns: Type Description dict or list Single Task (dict) : The updated task dictionary object. Multiple Tasks (list) : The updated task dictionary objects in a list. Exceptions: Type Description TypeError If obj is not a dictionary or list. RuntimeError If the updating was unsuccessful. Formatting Dates Help TickTick uses a certain syntax for their dates. To convert a datetime object to a compatible string to be used for updating dates, see convert_date_to_tick_tick_format Updating Tasks Single Task Update Updating a single task requires changing the task dictionary directly, and then passing the entire object to update . # Lets say we have a task named \"Hang out with Jon\" that we want to rename to \"Call Jon\" jon_task = client . get_by_fields ( title = 'Hang out with Jon' , search = 'tasks' ) # Change the field directly jon_task [ 'title' ] = 'Call Jon' # Pass the entire object to update. updated_jon_task = client . task . update ( jon_task ) Result The updated task dictionary is returned. { 'id' : '5fff566fb04b355792c79417' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 101429947662336 , 'title' : 'Call Jon' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T20:22:07.000+0000' , 'etag' : '5qiug0q2' , 'deleted' : 0 , 'createdTime' : '2021-01-13T20:22:07.000+0000' , 'creator' : 759365027 , 'kind' : 'TEXT' } Before After Multiple Task Update Updating multiple tasks requires changing the task dictionaries directly, and then passing the dictionaries in a list to update . # Lets say we have a task named \"Hang out with Jon\" that we want to rename to \"Call Jon\" jon_task = client . get_by_fields ( title = 'Hang out with Jon' , search = 'tasks' ) # Change the field directly jon_task [ 'title' ] = 'Call Jon' # Lets say we have another task named \"Read Book\" that we want to change the progress to 70%. book_task = client . get_by_fields ( title = 'Read Book' , search = 'tasks' ) # Change the field directly book_task [ 'progress' ] = 70 # Create a list of the objects and pass to update update_tasks = [ jon_task , book_task ] updated = client . task . update ( update_tasks ) Result The updated task dictionaries are returned in a list. [{ 'id' : '5fff566fb04b355792c79417' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 101429947662336 , 'title' : 'Call Jon' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T20:29:56.000+0000' , 'etag' : 'nxahco6u' , 'deleted' : 0 , 'createdTime' : '2021-01-13T20:22:07.000+0000' , 'creator' : 557493756 , 'kind' : 'TEXT' }, { 'id' : '5fff584db04b355792c79430' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 102529459290112 , 'title' : 'Read Book' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 70 , 'modifiedTime' : '2021-01-13T20:30:05.000+0000' , 'etag' : 'hdz5rbcj' , 'deleted' : 0 , 'createdTime' : '2021-01-13T20:30:05.000+0000' , 'creator' : 557493756 , 'kind' : 'TEXT' }] Before After Notice the progress icon located near the date now for \"Read Book\" Source code in managers/tasks.py @logged_in def update ( self , obj ): \"\"\" Updates task(s) remotely. Supports single task update and batch task update. To update a task, change any field in it's dictionary directly then pass to the method. !!! tip \"For Help On What Fields Are Present In The Task Dictionaries\" [Example `TickTick` Task Dictionary](tasks.md#example-ticktick-task-dictionary) Arguments: obj (dict or list): **Single Task (dict)**: The changed task dictionary object. **Multiple Tasks (list)**: The changed task dictionary objects in a list. Returns: dict or list: **Single Task (dict)**: The updated task dictionary object. **Multiple Tasks (list)**: The updated task dictionary objects in a list. Raises: TypeError: If `obj` is not a dictionary or list. RuntimeError: If the updating was unsuccessful. !!! tip \"Formatting Dates Help\" TickTick uses a certain syntax for their dates. To convert a datetime object to a compatible string to be used for updating dates, see [convert_date_to_tick_tick_format][helpers.time_methods.convert_date_to_tick_tick_format] !!! example \"Updating Tasks\" === \"Single Task Update\" Updating a single task requires changing the task dictionary directly, and then passing the entire object to `update`. ```python # Lets say we have a task named \"Hang out with Jon\" that we want to rename to \"Call Jon\" jon_task = client.get_by_fields(title='Hang out with Jon', search='tasks') # Change the field directly jon_task['title'] = 'Call Jon' # Pass the entire object to update. updated_jon_task = client.task.update(jon_task) ``` ??? success \"Result\" The updated task dictionary is returned. ```python {'id': '5fff566fb04b355792c79417', 'projectId': 'inbox115781412', 'sortOrder': -101429947662336, 'title': 'Call Jon', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T20:22:07.000+0000', 'etag': '5qiug0q2', 'deleted': 0, 'createdTime': '2021-01-13T20:22:07.000+0000', 'creator': 759365027, 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104506247-f8f38c00-5599-11eb-9f8e-c4bbb256cf03.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104506300-0e68b600-559a-11eb-952d-ac5d189535b4.png) === \"Multiple Task Update\" Updating multiple tasks requires changing the task dictionaries directly, and then passing the dictionaries in a list to `update`. ```python # Lets say we have a task named \"Hang out with Jon\" that we want to rename to \"Call Jon\" jon_task = client.get_by_fields(title='Hang out with Jon', search='tasks') # Change the field directly jon_task['title'] = 'Call Jon' # Lets say we have another task named \"Read Book\" that we want to change the progress to 70%. book_task = client.get_by_fields(title='Read Book', search='tasks') # Change the field directly book_task['progress'] = 70 # Create a list of the objects and pass to update update_tasks = [jon_task, book_task] updated = client.task.update(update_tasks) ``` ??? success \"Result\" The updated task dictionaries are returned in a list. ```python [{'id': '5fff566fb04b355792c79417', 'projectId': 'inbox115781412', 'sortOrder': -101429947662336, 'title': 'Call Jon', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T20:29:56.000+0000', 'etag': 'nxahco6u', 'deleted': 0, 'createdTime': '2021-01-13T20:22:07.000+0000', 'creator': 557493756, 'kind': 'TEXT'}, {'id': '5fff584db04b355792c79430', 'projectId': 'inbox115781412', 'sortOrder': -102529459290112, 'title': 'Read Book', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 70, 'modifiedTime': '2021-01-13T20:30:05.000+0000', 'etag': 'hdz5rbcj', 'deleted': 0, 'createdTime': '2021-01-13T20:30:05.000+0000', 'creator': 557493756, 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104507072-15dc8f00-559b-11eb-9253-3629e1abc668.png) **After** Notice the progress icon located near the date now for \"Read Book\" ![image](https://user-images.githubusercontent.com/56806733/104507219-4ae8e180-559b-11eb-99bf-f0a018c4ae5c.png) \"\"\" if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Task Objects Must Be A Dictionary or List of Dictionaries.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/task' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'tasks' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'id' ] for x in tasks ] # Tag names are in order items = [ '' ] * len ( tasks ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here found = self . _client . get_by_id ( labels [ index ], search = 'tasks' ) items [ index ] = found # Place at the correct index return items","title":"Tasks"},{"location":"usage/tasks/#example-ticktick-task-dictionary","text":"Members Descriptions It is possible that not all possible fields are present in the table. Property Description Example Value Type Useful Values id The ID of the task '5ffe93f3b04b35082bbce7b0' str N/A projectId The project ID for the task '5ffe96c88f08237f3d16fa57' str N/A sortOrder A sort ID relative to other tasks in the Project -1099511627776 int Lower sortOrder == Higher Position title The name of the task 'Deposit Funds' str N/A content Text that will go underneath the title of the object. 'This is a description\" str N/A desc N/A '' str N/A startDate The start date or time for the object. '2021-01-12T08:00:00.000+0000' str N/A dueDate The end date for the object. '2021-01-12T08:00:00.000+0000' str N/A timeZone Time zone for the object 'America/Los_Angeles' str N/A isFloating If the object should keep the same time regardless of change in time zone. False bool N/A isAllDay Specifies if the task has a specific time/duration. True bool N/A reminders Reminders for the task [{'id': '5ffe9ebcb04b35082bbce88f', 'trigger': 'TRIGGER:P0DT9H0M0S'}] list N/A repeatFirstDate First repeat date '2021-01-12T08:00:00.000+0000' str N/A exDate N/A [] list N/A priority Priority value 1 int 0 = None, 1 = Low, 3 = Med, 5 = High status Whether the task is complete or not 0 int 0 = Not Complete, 2 = Complete items If the task is a CHECKLIST - item dictionaries are stored in this list. [] list N/A progress Progress amount. 70 int 0-100 modifiedTime Time last modified. '2021-01-13T07:18:21.000+0000' str N/A deleted If the task is deleted. 0 int N/A createdTime Creation time. 2021-01-13T06:32:19.000+0000 str N/A etag Etag identifier. 'ji35exmv' str N/A creator Creator identifier. 447666584 int N/A tags Name of the tags in a list. ['friends', 'party'] list The tags will be lowercase. pomodoroSummaries Pomodoro summary for the task. [{'userId': 447666584, 'count': 1, 'estimatedPomo': 0, 'duration': 25}] list N/A focusSummaries Focus summary for the task. [{'userId': 447666584, 'pomoCount': 1, 'estimatedPomo': 0, 'estimatedDuration': 0, 'pomoDuration': 1500, 'stopwatchDuration': 0}] list N/A columnId If in a project with kanban view, this identifies which section it is in. '11b745ecab9f0799bf53eb70' str N/A childIds The ID's of any subtasks. ['5ffe97edb04b35082bbce832'] list N/A kind Determines if the task has a normal description, or item list description. 'TEXT' str 'TEXT' or 'CHECKLIST' { 'id' : '5ffe93f3b04b35082bbce7b0' , 'projectId' : '5ffe96c88f08237f3d16fa57' , 'sortOrder' : - 1099511627776 , 'title' : 'Deposit Funds' , 'content' : '' , 'desc' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 1 , 'status' : 0 , 'items' : [{ 'id' : '5ffe972eb04b35082bbce831' , 'status' : 0 , 'title' : 'Hellooo' , 'sortOrder' : 0 , 'startDate' : None , 'isAllDay' : False , 'timeZone' : 'America/Los_Angeles' , 'snoozeReminderTime' : None , 'completedTime' : None }], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:49:17.508+0000' , 'etag' : 'ji35exmv' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:19.000+0000' , 'creator' : 447666584 , 'tags' : [ 'friends' , 'party' ], 'pomodoroSummaries' : [], 'columnId' : '11b745ecab9f0799bf53eb70' , 'childIds' : [ '5ffe97edb04b35082bbce832' ], 'kind' : 'CHECKLIST' }","title":"Example TickTick Task Dictionary"},{"location":"usage/tasks/#managers.tasks.TaskManager","text":"Handles all interactions for tasks.","title":"TaskManager"},{"location":"usage/tasks/#managers.tasks.TaskManager.builder","text":"Builds a local task object with the passed fields. Performs proper error checking. This function serves as a helper for batch creating tasks in create . Parameters: Name Type Description Default name str Any string is valid. required start datetime Desired start time. None end datetime Desired end time. None priority str For a priority other than 'none': 'low', 'medium', 'high'. 'none' project str The id of the list (project) you want the task to be created in. The default will be your inbox. None tags list Single string for the label of the tag, or a list of strings of labels for many tags. None content str Desired text to go into the 'Description' field in the task. '' tz str Timezone string if you want to make your task for a timezone other than the timezone linked to your TickTick account. None Returns: Type Description dict A dictionary containing the proper fields needed for task creation. Exceptions: Type Description TypeError If any of the parameter types do not match as specified in the parameters table. Example start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = [ 'Party' , 'Friends' , 'Food' ] task = client . task . builder ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag ) Result A dictionary object containing the appropriate fields is returned. { 'startDate' : '2022-07-05T21:30:00+0000' , 'dueDate' : '2022-07-06T06:30:00+0000' , 'isAllDay' : False , 'timeZone' : 'America/Los_Angeles' , 'title' : \"Molly's Birthday\" , 'priority' : 3 , 'projectId' : 'inbox115781412' , 'tags' : [ 'Party' , 'Friends' , 'Food' ], 'content' : \"Be there at two and don't forget the snacks\" } Source code in managers/tasks.py @logged_in def builder ( self , name : str , start = None , end = None , priority : str = 'none' , project : str = None , tags : list = None , content : str = '' , tz : str = None ) -> dict : \"\"\" Builds a local task object with the passed fields. Performs proper error checking. This function serves as a helper for batch creating tasks in [`create`][managers.tasks.TaskManager.create]. Arguments: name: Any string is valid. start (datetime): Desired start time. end (datetime): Desired end time. priority: For a priority other than 'none': 'low', 'medium', 'high'. project: The id of the list (project) you want the task to be created in. The default will be your inbox. tags: Single string for the label of the tag, or a list of strings of labels for many tags. content: Desired text to go into the 'Description' field in the task. tz: Timezone string if you want to make your task for a timezone other than the timezone linked to your TickTick account. Returns: A dictionary containing the proper fields needed for task creation. Raises: TypeError: If any of the parameter types do not match as specified in the parameters table. !!! example ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = ['Party', 'Friends', 'Food'] task = client.task.builder(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag) ``` ??? success \"Result\" A dictionary object containing the appropriate fields is returned. ```python {'startDate': '2022-07-05T21:30:00+0000', 'dueDate': '2022-07-06T06:30:00+0000', 'isAllDay': False, 'timeZone': 'America/Los_Angeles', 'title': \"Molly's Birthday\", 'priority': 3, 'projectId': 'inbox115781412', 'tags': ['Party', 'Friends', 'Food'], 'content': \"Be there at two and don't forget the snacks\"} ``` \"\"\" return self . _task_field_checks ( task_name = name , priority = priority , project = project , tags = tags , content = content , start_date = start , end_date = end , time_zone = tz )","title":"builder()"},{"location":"usage/tasks/#managers.tasks.TaskManager.complete","text":"Marks the task(s) as complete. Supports single task completion and batch task completion. Parameters: Name Type Description Default ids str or list Single Task (str) : The ID string of the task. Multiple Tasks (list) : A list of ID strings for the tasks. required Returns: Type Description dict or list Single Task (dict) : The dictionary of the completed task. Multiple Tasks (list) : A list of dictionaries for the completed tasks. Exceptions: Type Description TypeError If ids is not a string or list. ValueError If ids is not a task that exists. RuntimeError If completing was unsuccessful. Task Completing Single Task Completion Pass the ID string of the task to complete. # Lets assume that we have a task named \"Go To Dentist\" that we want to mark as complete. dentist_task = client . get_by_fields ( title = 'Go To Dentist' , search = 'tasks' ) complete_task = client . task . complete ( dentist_task [ 'id' ]) # Pass the ID of the object Result The task is completed and the dictionary object returned. { 'id' : '5fff5009b04b355792c79397' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 99230924406784 , 'title' : 'Go To Dentist' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T19:56:11.000+0000' , 'etag' : 'djiiqso6' , 'deleted' : 0 , 'createdTime' : '2021-01-13T19:54:49.000+0000' , 'creator' : 6147345572 , 'kind' : 'TEXT' } Before After Multiple Tasks Completion Pass a list of ID strings to complete the tasks. # Lets assume that we have a task named \"Go To Dentist\" and a task named \"Go To Store\" dentist_task = client . get_by_fields ( title = 'Go To Dentist' , search = 'tasks' ) store_task = client . get_by_fields ( title = 'Go To Store' , search = 'tasks' ) ids = [ dentist_task [ 'id' ], store_task [ 'id' ]] completed_tasks = client . task . complete ( ids ) Result The tasks are completed and the dictionary objects returned in a list. [{ 'id' : '5fff5009b04b355792c79397' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 99230924406784 , 'title' : 'Go To Dentist' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2021-01-13T19:57:00.285+0000' , 'completedUserId' : 115781412 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T19:56:11.000+0000' , 'etag' : 'qq9drp8d' , 'deleted' : 0 , 'createdTime' : '2021-01-13T19:54:49.000+0000' , 'creator' : 215414317 , 'kind' : 'TEXT' }, { 'id' : '5fff51f3b04b355792c793e6' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 100330436034560 , 'title' : 'Go To Store' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T20:02:59.000+0000' , 'etag' : 'be8m3g3x' , 'deleted' : 0 , 'createdTime' : '2021-01-13T20:02:59.000+0000' , 'creator' : 215414317 , 'tags' : [], 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py @logged_in def complete ( self , ids ): \"\"\" Marks the task(s) as complete. Supports single task completion and batch task completion. Arguments: ids (str or list): **Single Task (str)**: The ID string of the task. **Multiple Tasks (list)**: A list of ID strings for the tasks. Returns: dict or list: **Single Task (dict)**: The dictionary of the completed task. **Multiple Tasks (list)**: A list of dictionaries for the completed tasks. Raises: TypeError: If `ids` is not a string or list. ValueError: If `ids` is not a task that exists. RuntimeError: If completing was unsuccessful. !!! example \"Task Completing\" === \"Single Task Completion\" Pass the ID string of the task to complete. ```python # Lets assume that we have a task named \"Go To Dentist\" that we want to mark as complete. dentist_task = client.get_by_fields(title='Go To Dentist', search='tasks') complete_task = client.task.complete(dentist_task['id']) # Pass the ID of the object ``` ??? success \"Result\" The task is completed and the dictionary object returned. ```python {'id': '5fff5009b04b355792c79397', 'projectId': 'inbox115781412', 'sortOrder': -99230924406784, 'title': 'Go To Dentist', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T19:56:11.000+0000', 'etag': 'djiiqso6', 'deleted': 0, 'createdTime': '2021-01-13T19:54:49.000+0000', 'creator': 6147345572, 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104503673-39510b00-5596-11eb-88df-88eeee9ab4b0.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104504069-c4ca9c00-5596-11eb-96c9-5698e19989ea.png) === \"Multiple Tasks Completion\" Pass a list of ID strings to complete the tasks. ```python # Lets assume that we have a task named \"Go To Dentist\" and a task named \"Go To Store\" dentist_task = client.get_by_fields(title='Go To Dentist', search='tasks') store_task = client.get_by_fields(title='Go To Store', search='tasks') ids = [dentist_task['id'], store_task['id']] completed_tasks = client.task.complete(ids) ``` ??? success \"Result\" The tasks are completed and the dictionary objects returned in a list. ```python [{'id': '5fff5009b04b355792c79397', 'projectId': 'inbox115781412', 'sortOrder': -99230924406784, 'title': 'Go To Dentist', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2021-01-13T19:57:00.285+0000', 'completedUserId': 115781412, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T19:56:11.000+0000', 'etag': 'qq9drp8d', 'deleted': 0, 'createdTime': '2021-01-13T19:54:49.000+0000', 'creator': 215414317, 'kind': 'TEXT'}, {'id': '5fff51f3b04b355792c793e6', 'projectId': 'inbox115781412', 'sortOrder': -100330436034560, 'title': 'Go To Store', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T20:02:59.000+0000', 'etag': 'be8m3g3x', 'deleted': 0, 'createdTime': '2021-01-13T20:02:59.000+0000', 'creator': 215414317, 'tags': [], 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104504451-4f130000-5597-11eb-9f92-386a6be10ca6.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104504511-6a7e0b00-5597-11eb-9855-c4edce01713b.png) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( \"Ids Must Be A String Or List Of Ids\" ) tasks = [] if isinstance ( ids , str ): task = self . _client . get_by_fields ( id = ids , search = 'tasks' ) if not task : raise ValueError ( 'The Task Does Not Exist To Mark As Complete' ) task [ 'status' ] = 2 # Complete tasks . append ( task ) else : for id in ids : task = self . _client . get_by_fields ( id = id , search = 'tasks' ) if not task : raise ValueError ( f \"'Task Id ' { id } ' Does Not Exist'\" ) task [ 'status' ] = 2 # Complete tasks . append ( task ) url = self . _client . BASE_URL + 'batch/task' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( tasks ) == 1 : return tasks [ 0 ] else : return tasks","title":"complete()"},{"location":"usage/tasks/#managers.tasks.TaskManager.create","text":"Create a task. This method supports single and batch task creation. Parameters: Name Type Description Default name str Any string is valid. required start datetime Desired start time. None end datetime Desired end time. None priority str For a priority other than 'none': 'low', 'medium', 'high'. 'none' project str The id of the list (project) you want the task to be created in. The default will be your inbox. None tags list Single string for the label of the tag, or a list of strings of labels for many tags. None content str Desired text to go into the 'Description' field in the task. '' tz str Timezone string if you want to make your task for a timezone other than the timezone linked to your TickTick account. None Returns: Type Description dict Dictionary of created task object. Exceptions: Type Description TypeError If any of the parameter types do not match as specified in the parameters table. RunTimeError If the task could not be created successfully. Create A Single Task Creating a single task is simple - specify whatever parameters you want directly. Creating a single task will return the dictionary object of the created task. Just a Name title = \"Molly's Birthday\" task = client . task . create ( title ) Result Priority Priorities can be changed using the following strings: 'none' : Grey 'low' : Blue 'medium' : Yellow 'high' : Red title = \"Molly's Birthday\" task = client . task . create ( title , priority = 'medium' ) Result All Day Date An all day task is specified by using a datetime object without any hours, minutes, or seconds. You can pass your datetime object using either start or end for all day tasks. date = datetime ( 2022 , 7 , 5 ) # 7/5/2022 title = \"Molly's Birthday\" task = client . task . create ( title , start = date , priority = 'medium' ) Result Specific Duration A specific duration can be set by using datetime objects and specifying both the start and end times. start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' ) Result Content Content can be any string you want. Use escape sequences for newlines, tabs, etc. start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember ) Result Tags Single Tag : A single tag can be passed as a simple string for the name. The tag will be created if it doesn't already exist. start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = 'Party' task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag ) Result Multiple Tags : Multiple tags can be added to a task by including all the desired tag names in a list. start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = [ 'Party' , 'Friends' , 'Food' ] task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag ) Result Different Time Zone To create the task for a different time zone pass in a time zone string. Time Zone Help start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = [ 'Party' , 'Friends' , 'Food' ] timezone = 'America/Costa_Rica' # Notice the time zone in the result image task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag , tz = timezone ) Result Different Project Info To create your task inside of a different project other than your inbox, pass in the ID corresponding to the project that you want. Note Your project must exist before the creation of the task. # Lets assume that we have a project that is already created and named 'Birthday's' project_obj = client . get_by_fields ( name = \"Birthday's\" , search = 'projects' ) # Get the list (project) object birthdays_id = project_obj [ 'id' ] # Obtain the id of the object start_time = datetime ( 2022 , 7 , 5 , 14 , 30 ) # 7/5/2022 at 2:30 PM end_time = datetime ( 2022 , 7 , 5 , 23 , 30 ) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = [ 'Party' , 'Friends' , 'Food' ] task = client . task . create ( title , start = start_time , end = end_time , priority = 'medium' , content = remember , tags = tag , project = birthdays_id ) Result Creating Multiple Tasks At Once (Batch) Creating multiple tasks is also simple, however we have to create the individual task objects before passing them to the create method. This is efficient on resources if you need to create multiple tasks at a single time since the same amount of requests will be required no matter how many tasks are being created at once. This is accomplished using the builder method. Create the task objects with builder and pass the objects you want to create in a list to the create method. If the creation was successful, the created tasks will be returned in the same order as the input in a list. All parameters supported with creating a single task are supported here as well. # Create three tasks in the inbox task1 = client . task . builder ( 'Hello I Am Task 1' ) task2 = client . task . builder ( 'Hello I Am Task 2' ) task3 = client . task . builder ( 'Hello I Am Task 3' ) task_objs = [ task1 , task2 , task3 ] created_tasks = client . task . create ( task_objs ) Result Source code in managers/tasks.py @logged_in def create ( self , name : str , start = None , end = None , priority : str = 'none' , project : str = None , tags : list = None , content : str = '' , tz : str = None , ) -> dict : \"\"\" Create a task. This method supports single and batch task creation. Arguments: name: Any string is valid. start (datetime): Desired start time. end (datetime): Desired end time. priority: For a priority other than 'none': 'low', 'medium', 'high'. project: The id of the list (project) you want the task to be created in. The default will be your inbox. tags: Single string for the label of the tag, or a list of strings of labels for many tags. content: Desired text to go into the 'Description' field in the task. tz: Timezone string if you want to make your task for a timezone other than the timezone linked to your TickTick account. Returns: Dictionary of created task object. Raises: TypeError: If any of the parameter types do not match as specified in the parameters table. RunTimeError: If the task could not be created successfully. !!! example \"Create A Single Task\" Creating a single task is simple - specify whatever parameters you want directly. Creating a single task will return the dictionary object of the created task. === \"Just a Name\" ```python title = \"Molly's Birthday\" task = client.task.create(title) ``` ??? success \"Result\" [![task-just-name.png](https://i.postimg.cc/TPDkqYwC/task-just-name.png)](https://postimg.cc/069d9v7w) === \"Priority\" Priorities can be changed using the following strings: - 'none' : <span style=\"color:grey\"> *Grey* </span> - 'low' : <span style=\"color:Blue\"> *Blue* </span> - 'medium' : <span style=\"color:#f5c71a\"> *Yellow* </span> - 'high' : <span style=\"color:Red\"> *Red* </span> ```python title = \"Molly's Birthday\" task = client.task.create(title, priority = 'medium') ``` ??? success \"Result\" [![task-priority.png](https://i.postimg.cc/QdrvMyqF/task-priority.png)](https://postimg.cc/ZCVw7j2m) === \"All Day Date\" An all day task is specified by using a `datetime` object without any hours, minutes, or seconds. You can pass your datetime object using either `start` or `end` for all day tasks. ```python date = datetime(2022, 7, 5) # 7/5/2022 title = \"Molly's Birthday\" task = client.task.create(title, start=date, priority='medium') ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![start-date.png](https://i.postimg.cc/PfQwcLF0/start-date.png)](https://postimg.cc/Lhh5gsSV) === \"Specific Duration\" A specific duration can be set by using `datetime` objects and specifying both the start and end times. ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" task = client.task.create(title, start=start_time, end=end_time, priority='medium') ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![duration2.png](https://i.postimg.cc/5tzHmjC7/duration2.png)](https://postimg.cc/xk0TffgM) === \"Content\" Content can be any string you want. Use escape sequences for newlines, tabs, etc. ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember) ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![content2.png](https://i.postimg.cc/285VK0WB/content2.png)](https://postimg.cc/SjwSX7Dy) === \"Tags\" **_Single Tag_:** A single tag can be passed as a simple string for the name. The tag will be created if it doesn't already exist. ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = 'Party' task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag) ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![tags1.png](https://i.postimg.cc/Y9ppmSfm/tags1.png)](https://postimg.cc/t1M0KpcX) **_Multiple Tags_:** Multiple tags can be added to a task by including all the desired tag names in a list. ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = ['Party', 'Friends', 'Food'] task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag) ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![tags2.png](https://i.postimg.cc/7PtxfwCf/tags2.png)](https://postimg.cc/3WpMqMFT) === \"Different Time Zone\" To create the task for a different time zone pass in a time zone string. [Time Zone Help](/usage/helpers/#time-zones) ```python start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = ['Party', 'Friends', 'Food'] timezone = 'America/Costa_Rica' # Notice the time zone in the result image task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag, tz=timezone) ``` ??? success \"Result\" [![start-date-2.png](https://i.postimg.cc/SNctHGpk/start-date-2.png)](https://postimg.cc/2V8wZh6K) --- [![tz1.png](https://i.postimg.cc/dtrvVdGV/tz1.png)](https://postimg.cc/BXSRhjhr) === \"Different Project\" !!! info To create your task inside of a different [project](projects.md) other than your inbox, pass in the ID corresponding to the [project](projects.md) that you want. !!! note Your [project](projects.md) must exist before the creation of the task. ```python # Lets assume that we have a project that is already created and named 'Birthday's' project_obj = client.get_by_fields(name=\"Birthday's\", search='projects') # Get the list (project) object birthdays_id = project_obj['id'] # Obtain the id of the object start_time = datetime(2022, 7, 5, 14, 30) # 7/5/2022 at 2:30 PM end_time = datetime(2022, 7, 5, 23, 30) # 7/5/2022 at 11:30 PM title = \"Molly's Birthday\" remember = \"Be there at two and don't forget the snacks\" tag = ['Party', 'Friends', 'Food'] task = client.task.create(title, start=start_time, end=end_time, priority='medium', content=remember, tags=tag, project=birthdays_id) ``` ??? success \"Result\" [![different-list1.png](https://i.postimg.cc/ncN4vXR5/different-list1.png)](https://postimg.cc/1fcVS3Zc) --- [![different-list2.png](https://i.postimg.cc/Mpz8WmVb/different-list2.png)](https://postimg.cc/0bX4nmtb) !!! example \"Creating Multiple Tasks At Once (Batch)\" Creating multiple tasks is also simple, however we have to create the individual task objects before passing them to the `create` method. This is efficient on resources if you need to create multiple tasks at a single time since the same amount of requests will be required no matter how many tasks are being created at once. This is accomplished using the [`builder`][managers.tasks.TaskManager.builder] method. Create the task objects with [`builder`][managers.tasks.TaskManager.builder] and pass the objects you want to create in a list to the create method. If the creation was successful, the created tasks will be returned in the same order as the input in a list. All parameters supported with creating a single task are supported here as well. ```python # Create three tasks in the inbox task1 = client.task.builder('Hello I Am Task 1') task2 = client.task.builder('Hello I Am Task 2') task3 = client.task.builder('Hello I Am Task 3') task_objs = [task1, task2, task3] created_tasks = client.task.create(task_objs) ``` ??? success \"Result\" [![batch-task.png](https://i.postimg.cc/J0tq8nQW/batch-task.png)](https://postimg.cc/GTwYJbNM) \"\"\" if isinstance ( name , list ): # If task name is a list, we will batch create objects obj = name batch = True # Get task object elif isinstance ( name , str ): batch = False obj = self . builder ( name = name , start = start , end = end , priority = priority , project = project , tags = tags , content = content , tz = tz ) obj = [ obj ] else : raise TypeError ( f \"Required Positional Argument Must Be A String or List of Task Objects\" ) tag_list = [] for o in obj : for tag in o [ 'tags' ]: if self . _client . get_by_fields ( label = tag , search = 'tags' ): continue # Dont create the tag if it already exists tag_obj = self . _client . tag . builder ( tag ) same = False for objs in tag_list : if objs [ 'label' ] == tag_obj [ 'label' ]: same = True if not same : tag_list . append ( tag_obj ) # Batch create the tags if tag_list : tags = self . _client . tag . create ( tag_list ) if not batch : # For a single task we will just send it to the update return self . _client . task . update ( obj ) else : # We are going to create a unique identifier and append it to content. # We will be able to distinguish which task is which by this identifier # Once we find the tasks, we will make one more call to update to remove the # Identifier from the content string. ids = [] for task in obj : identifier = str ( uuid . uuid4 ()) # Identifier ids . append ( identifier ) task [ 'content' ] += identifier # Append the identifier onto the end of it url = self . _client . BASE_URL + 'batch/task' payload = { 'add' : obj } response = self . _client . session . post ( url , json = payload , cookies = self . _client . cookies ) if response . status_code != 200 and response . status_code != 500 : raise RuntimeError ( 'Could Not Complete Request' ) self . _client . sync () # We will find the tasks by their identifiers update_list = [ '' ] * len ( obj ) if batch : for tsk in self . _client . state [ 'tasks' ][:: - 1 ]: # Task List if len ( ids ) == 0 : break id = 0 for id in range ( len ( ids )): try : if ids [ id ] in tsk [ 'content' ]: tsk [ 'content' ] = tsk [ 'content' ] . replace ( ids [ id ], '' ) update_list [ id ] = tsk del ids [ id ] break except : break return self . _client . task . update ( update_list )","title":"create()"},{"location":"usage/tasks/#managers.tasks.TaskManager.delete","text":"Deletes task(s). Supports single task deletion, and batch task deletion. Tip If a parent task is deleted - the children will remain (unlike normal parent task deletion in TickTick ) Parameters: Name Type Description Default ids str or list Single Task (str) : ID string of the task to be deleted. Multiple Tasks (list) : List of ID strings for the tasks to be deleted. required Returns: Type Description dict or list Single Task (dict) : Dictionary object of the deleted task. Multiple Tasks (list) : List of dictionary objects for the deleted tasks. Exceptions: Type Description TypeError If ids is not a string or list. ValueError If ids does not exist. RuntimeError If the deletion was unsuccessful. Task Deletion Single Task Deletion Pass the ID of the string to be deleted. # Lets assume that our task is named \"Dentist\" and it's in our inbox. task = client . get_by_fields ( title = \"Dentist\" , projectId = client . inbox_id , search = 'tasks' ) deleted_task = client . task . delete ( task [ 'id' ]) Result The deleted task object is returned. { 'id' : '5ffead3cb04b35082bbced71' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 2199023255552 , 'title' : 'Dentist' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T08:20:12.000+0000' , 'etag' : 'tijkifu0' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:20:12.000+0000' , 'creator' : 73561212 , 'tags' : [], 'kind' : 'TEXT' } Before After Multiple Task Deletion Pass a list of ID strings for the tasks to be deleted. # Lets assume we have two tasks we want to delete from our inbox - \"Dentist\" and \"Read\" dentist = client . get_by_fields ( title = \"Dentist\" , projectId = client . inbox_id , search = 'tasks' ) read = client . get_by_fields ( title = \"Read\" , projectId = client . inbox_id , search = 'tasks' ) id_list = [ dentist [ 'id' ], read [ 'id' ]] deleted_task = client . task . delete ( id_list ) Result A list of the deleted tasks is returned. [{ 'id' : '5ffeae528f081003f32cb661' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 1099511627776 , 'title' : 'Dentist' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:24:50.334+0000' , 'etag' : 'fwsrqx4j' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:24:50.340+0000' , 'creator' : 115781412 , 'kind' : 'TEXT' }, { 'id' : '5ffeae528f081003f32cb664' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 2199023255552 , 'title' : 'Read' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:24:50.603+0000' , 'etag' : '1sje21ao' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:24:50.609+0000' , 'creator' : 115781412 , 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py @logged_in def delete ( self , ids ): \"\"\" Deletes task(s). Supports single task deletion, and batch task deletion. !!! tip If a parent task is deleted - the children will remain (unlike normal parent task deletion in `TickTick`) Arguments: ids (str or list): **Single Task (str)**: ID string of the task to be deleted. **Multiple Tasks (list)**: List of ID strings for the tasks to be deleted. Returns: dict or list: **Single Task (dict)**: Dictionary object of the deleted task. **Multiple Tasks (list)**: List of dictionary objects for the deleted tasks. Raises: TypeError: If `ids` is not a string or list. ValueError: If `ids` does not exist. RuntimeError: If the deletion was unsuccessful. !!! example \"Task Deletion\" === \"Single Task Deletion\" Pass the ID of the string to be deleted. ```python # Lets assume that our task is named \"Dentist\" and it's in our inbox. task = client.get_by_fields(title=\"Dentist\", projectId=client.inbox_id, search='tasks') deleted_task = client.task.delete(task['id']) ``` ??? success \"Result\" The deleted task object is returned. ```python {'id': '5ffead3cb04b35082bbced71', 'projectId': 'inbox115781412', 'sortOrder': -2199023255552, 'title': 'Dentist', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T08:20:12.000+0000', 'etag': 'tijkifu0', 'deleted': 0, 'createdTime': '2021-01-13T08:20:12.000+0000', 'creator': 73561212, 'tags': [], 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104425305-615c5200-5535-11eb-93fa-3184b5d679b7.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104425375-76d17c00-5535-11eb-9e12-3af1cf727957.png) === \"Multiple Task Deletion\" Pass a list of ID strings for the tasks to be deleted. ```python # Lets assume we have two tasks we want to delete from our inbox - \"Dentist\" and \"Read\" dentist = client.get_by_fields(title=\"Dentist\", projectId=client.inbox_id, search='tasks') read = client.get_by_fields(title=\"Read\", projectId=client.inbox_id, search='tasks') id_list = [dentist['id'], read['id']] deleted_task = client.task.delete(id_list) ``` ??? success \"Result\" A list of the deleted tasks is returned. ```python [{'id': '5ffeae528f081003f32cb661', 'projectId': 'inbox115781412', 'sortOrder': -1099511627776, 'title': 'Dentist', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:24:50.334+0000', 'etag': 'fwsrqx4j', 'deleted': 0, 'createdTime': '2021-01-13T08:24:50.340+0000', 'creator': 115781412, 'kind': 'TEXT'}, {'id': '5ffeae528f081003f32cb664', 'projectId': 'inbox115781412', 'sortOrder': -2199023255552, 'title': 'Read', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:24:50.603+0000', 'etag': '1sje21ao', 'deleted': 0, 'createdTime': '2021-01-13T08:24:50.609+0000', 'creator': 115781412, 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104425633-c4e67f80-5535-11eb-9735-bea3db63e0ab.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104425375-76d17c00-5535-11eb-9e12-3af1cf727957.png) \"\"\" if not isinstance ( ids , str ) and not isinstance ( ids , list ): raise TypeError ( 'Ids Must Be A String or List Of Strings' ) tasks = [] if isinstance ( ids , str ): task = self . _client . get_by_fields ( id = ids , search = 'tasks' ) if not task : raise ValueError ( f \"Task ' { ids } ' Does Not Exist To Delete\" ) task = { 'projectId' : task [ 'projectId' ], 'taskId' : ids } tasks = [ task ] else : for id in ids : task = self . _client . get_by_fields ( id = id , search = 'tasks' ) if not task : raise ValueError ( f \"'Task Id ' { id } ' Does Not Exist'\" ) task = { 'projectId' : task [ 'projectId' ], 'taskId' : id } tasks . append ( task ) url = self . _client . BASE_URL + 'batch/task' payload = { 'delete' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) return_list = [] if len ( tasks ) == 1 : return_list . append ( self . _client . get_by_id ( ids , search = 'tasks' )) else : for item in tasks : o = self . _client . get_by_id ( item [ 'taskId' ], search = 'tasks' ) return_list . append ( o ) self . _client . sync () if len ( return_list ) == 1 : return return_list [ 0 ] return return_list","title":"delete()"},{"location":"usage/tasks/#managers.tasks.TaskManager.get_completed","text":"Obtains all completed tasks from the given start date and end date. Note There is a limit of 100 items for the request Parameters: Name Type Description Default start datetime Start time datetime object. required end datetime End time datetime object. None full bool Boolean specifying whether hours, minutes, and seconds are to be taken into account for the query. True tz str String specifying a specific time zone, however this will default to your accounts normal time zone. None Returns: Type Description list A list containing all the completed tasks based on the times. Exceptions: Type Description TypeError If the proper types are not used. ValueError If start occurs after end. KeyError If the time zone string passed is not a valid time zone string. RuntimeError If getting the tasks is unsuccessful. Getting Completed Tasks Completed Tasks In A Single Day Getting the tasks for a full, complete day requires passing in the datetime object corresponding to the day that you want. # Get the tasks for 1/11/2021 tasks = client . task . get_completed ( datetime ( 2021 , 1 , 11 )) Result The list of completed tasks is returned. [{ 'id' : '5ffca35f4c201114702a0607' , 'projectId' : '004847faa60015487be444cb' , 'sortOrder' : - 50027779063826 , 'title' : 'Shoulders and Arms' , 'content' : '' , 'desc' : '' , 'startDate' : '2021-01-11T08:00:00.000+0000' , 'dueDate' : '2021-01-11T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'repeatFlag' : '' , 'exDate' : [], 'completedTime' : '2021-01-11T23:25:46.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-11T23:25:41.000+0000' , 'etag' : '6hlk4e8t' , 'deleted' : 0 , 'createdTime' : '2021-01-11T19:13:35.000+0000' , 'creator' : 185769383 , 'tags' : [ 'fitness' ], 'commentCount' : 0 , 'pomodoroSummaries' : [{ 'userId' : 185769383 , 'count' : 0 , 'estimatedPomo' : 0 , 'duration' : 0 }], 'focusSummaries' : [{ 'userId' : 185769383 , 'pomoCount' : 0 , 'estimatedPomo' : 0 , 'estimatedDuration' : 0 , 'pomoDuration' : 0 , 'stopwatchDuration' : 3720 }], 'kind' : 'TEXT' }] Completed Tasks Over A Range Of Days Getting the tasks for a range of days requires passing in datetime objects for the start day, and the end day that you want. # Get the tasks between 8/7/18 and 8/10/18 start = datetime ( 2018 , 8 , 7 ) end = datetime ( 2018 , 8 , 10 ) tasks = client . task . get_completed ( start , end ) Result Completed tasks in a list are returned. [{ 'id' : '5ffffebab04b355792c79e38' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 7696581394432 , 'title' : 'Ride Bike' , 'content' : '' , 'startDate' : '2021-01-14T08:00:00.000+0000' , 'dueDate' : '2021-01-14T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2018-08-09T07:20:11.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T08:21:01.000+0000' , 'etag' : 'mhjyig4y' , 'deleted' : 0 , 'createdTime' : '2021-01-14T08:20:10.000+0000' , 'creator' : 185769383 , 'kind' : 'TEXT' }, { 'id' : '5ffffeaab04b355792c79d89' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 6597069766656 , 'title' : 'Read Book' , 'content' : '' , 'startDate' : '2021-01-14T08:00:00.000+0000' , 'dueDate' : '2021-01-14T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'completedTime' : '2018-08-08T07:20:12.000+0000' , 'completedUserId' : 185769383 , 'priority' : 0 , 'status' : 2 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T08:20:46.000+0000' , 'etag' : 'tzd4coms' , 'deleted' : 0 , 'createdTime' : '2021-01-14T08:19:54.000+0000' , 'creator' : 185769383 , 'kind' : 'TEXT' }] Completed Tasks Over A Specific Duration Of Time You can also get completed tasks that were completed in a specific time duration. Include specific hours, minutes, and seconds for the datetime objects, and specify full to be false -> meaning that the specific times will be put into effect. # Get the tasks completed between 12PM and 5PM on 12/15/2020 start = datetime ( 2020 , 12 , 15 , 12 ) # 12PM 12/15/2020 end = datetime ( 2020 , 12 , 15 , 17 ) # 5PM 12/15/2020 tasks = client . task . get_completed ( start , end , full = False ) Source code in managers/tasks.py @logged_in def get_completed ( self , start , end = None , full : bool = True , tz : str = None ) -> list : \"\"\" Obtains all completed tasks from the given start date and end date. !!! note There is a limit of 100 items for the request Arguments: start (datetime): Start time datetime object. end (datetime): End time datetime object. full: Boolean specifying whether hours, minutes, and seconds are to be taken into account for the query. tz: String specifying a specific time zone, however this will default to your accounts normal time zone. Returns: A list containing all the completed tasks based on the times. Raises: TypeError: If the proper types are not used. ValueError: If start occurs after end. KeyError: If the time zone string passed is not a valid time zone string. RuntimeError: If getting the tasks is unsuccessful. !!! example \"Getting Completed Tasks\" === \"Completed Tasks In A Single Day\" Getting the tasks for a full, complete day requires passing in the datetime object corresponding to the day that you want. ```python # Get the tasks for 1/11/2021 tasks = client.task.get_completed(datetime(2021, 1, 11)) ``` ??? success \"Result\" The list of completed tasks is returned. ```python [{'id': '5ffca35f4c201114702a0607', 'projectId': '004847faa60015487be444cb', 'sortOrder': -50027779063826, 'title': 'Shoulders and Arms', 'content': '', 'desc': '', 'startDate': '2021-01-11T08:00:00.000+0000', 'dueDate': '2021-01-11T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'repeatFlag': '', 'exDate': [], 'completedTime': '2021-01-11T23:25:46.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-11T23:25:41.000+0000', 'etag': '6hlk4e8t', 'deleted': 0, 'createdTime': '2021-01-11T19:13:35.000+0000', 'creator': 185769383, 'tags': ['fitness'], 'commentCount': 0, 'pomodoroSummaries': [{'userId': 185769383, 'count': 0, 'estimatedPomo': 0, 'duration': 0}], 'focusSummaries': [{'userId': 185769383, 'pomoCount': 0, 'estimatedPomo': 0, 'estimatedDuration': 0, 'pomoDuration': 0, 'stopwatchDuration': 3720}], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104562952-e1e68580-55fd-11eb-9e09-f432caa8616b.png) === \"Completed Tasks Over A Range Of Days\" Getting the tasks for a range of days requires passing in datetime objects for the start day, and the end day that you want. ```python # Get the tasks between 8/7/18 and 8/10/18 start = datetime(2018, 8, 7) end = datetime(2018, 8, 10) tasks = client.task.get_completed(start, end) ``` ??? success \"Result\" Completed tasks in a list are returned. ```python [{'id': '5ffffebab04b355792c79e38', 'projectId': 'inbox115781412', 'sortOrder': -7696581394432, 'title': 'Ride Bike', 'content': '', 'startDate': '2021-01-14T08:00:00.000+0000', 'dueDate': '2021-01-14T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2018-08-09T07:20:11.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T08:21:01.000+0000', 'etag': 'mhjyig4y', 'deleted': 0, 'createdTime': '2021-01-14T08:20:10.000+0000', 'creator': 185769383, 'kind': 'TEXT'}, {'id': '5ffffeaab04b355792c79d89', 'projectId': 'inbox115781412', 'sortOrder': -6597069766656, 'title': 'Read Book', 'content': '', 'startDate': '2021-01-14T08:00:00.000+0000', 'dueDate': '2021-01-14T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'completedTime': '2018-08-08T07:20:12.000+0000', 'completedUserId': 185769383, 'priority': 0, 'status': 2, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T08:20:46.000+0000', 'etag': 'tzd4coms', 'deleted': 0, 'createdTime': '2021-01-14T08:19:54.000+0000', 'creator': 185769383, 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104563478-8c5ea880-55fe-11eb-9bcf-91bc44c02083.png) === \"Completed Tasks Over A Specific Duration Of Time\" You can also get completed tasks that were completed in a specific time duration. Include specific hours, minutes, and seconds for the datetime objects, and specify `full` to be false -> meaning that the specific times will be put into effect. ```python # Get the tasks completed between 12PM and 5PM on 12/15/2020 start = datetime(2020, 12, 15, 12) # 12PM 12/15/2020 end = datetime(2020, 12, 15, 17) # 5PM 12/15/2020 tasks = client.task.get_completed(start, end, full=False) ``` \"\"\" url = self . _client . BASE_URL + 'project/all/completed' if tz is None : tz = self . _client . time_zone if not isinstance ( start , datetime . datetime ): raise TypeError ( 'Start Must Be A Datetime Object' ) if not isinstance ( end , datetime . datetime ) and end is not None : raise TypeError ( 'End Must Be A Datetime Object' ) # Handles case when start_date occurs after end_date if end is not None and start > end : raise ValueError ( 'Invalid Date Range: Start Date Occurs After End Date' ) # Handles invalid timezone argument if tz not in pytz . all_timezones_set : raise KeyError ( 'Invalid Time Zone' ) # Single Day Entry if end is None : start = datetime . datetime ( start . year , start . month , start . day , 0 , 0 , 0 ) end = datetime . datetime ( start . year , start . month , start . day , 23 , 59 , 59 ) # Multi DAy -> Full Day Entry elif full is True and end is not None : start = datetime . datetime ( start . year , start . month , start . day , 0 , 0 , 0 ) end = datetime . datetime ( end . year , end . month , end . day , 23 , 59 , 59 ) # Convert Local Time to UTC time based off the time_zone string specified start = convert_local_time_to_utc ( start , tz ) end = convert_local_time_to_utc ( end , tz ) parameters = { 'from' : start . strftime ( DATE_FORMAT ), 'to' : end . strftime ( DATE_FORMAT ), 'limit' : 100 } response = self . _client . http_get ( url , params = parameters , cookies = self . _client . cookies ) return response","title":"get_completed()"},{"location":"usage/tasks/#managers.tasks.TaskManager.get_from_project","text":"Obtains the tasks that are contained in the project. Parameters: Name Type Description Default project str ID string of the project to get the tasks from. required Returns: Type Description dict or list Single Task In Project (dict) : The single task object dictionary. Multiple Tasks In Project (list) : A list of task object dictionaries. No Tasks Found (list) : Empty list. Exceptions: Type Description ValueError If the project ID does not exist. Getting Uncompleted Tasks From The Inbox tasks = client . task . get_from_project ( client . inbox_id ) Result See Returns for the different return values based on the amount of tasks present in the project. [{ 'id' : '5ffe93efb04b35082bbce7af' , 'projectId' : 'inbox115781412' , 'sortOrder' : 2199023255552 , 'title' : 'Go To Library' , 'content' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:32:15.000+0000' , 'etag' : 'kkh0w1jk' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:15.000+0000' , 'creator' : 447666584 , 'tags' : [], 'kind' : 'TEXT' }, { 'id' : '5ffe93f3b04b35082bbce7b0' , 'projectId' : 'inbox115781412' , 'sortOrder' : 1099511627776 , 'title' : 'Deposit Funds' , 'content' : '' , 'startDate' : '2021-01-12T08:00:00.000+0000' , 'dueDate' : '2021-01-12T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T06:32:19.000+0000' , 'etag' : 'w4hj21wf' , 'deleted' : 0 , 'createdTime' : '2021-01-13T06:32:19.000+0000' , 'creator' : 447666584 , 'tags' : [], 'kind' : 'TEXT' }] Source code in managers/tasks.py @logged_in def get_from_project ( self , project : str ): \"\"\" Obtains the tasks that are contained in the project. Arguments: project: ID string of the project to get the tasks from. Returns: dict or list: **Single Task In Project (dict)**: The single task object dictionary. **Multiple Tasks In Project (list)**: A list of task object dictionaries. **No Tasks Found (list)**: Empty list. Raises: ValueError: If the project ID does not exist. !!! example \"Getting Uncompleted Tasks From The Inbox\" ```python tasks = client.task.get_from_project(client.inbox_id) ``` ??? success \"Result\" See `Returns` for the different return values based on the amount of tasks present in the project. ```python [{'id': '5ffe93efb04b35082bbce7af', 'projectId': 'inbox115781412', 'sortOrder': 2199023255552, 'title': 'Go To Library', 'content': '', 'startDate': '2021-01-12T08:00:00.000+0000', 'dueDate': '2021-01-12T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T06:32:15.000+0000', 'etag': 'kkh0w1jk', 'deleted': 0, 'createdTime': '2021-01-13T06:32:15.000+0000', 'creator': 447666584, 'tags': [], 'kind': 'TEXT'}, {'id': '5ffe93f3b04b35082bbce7b0', 'projectId': 'inbox115781412', 'sortOrder': 1099511627776, 'title': 'Deposit Funds', 'content': '', 'startDate': '2021-01-12T08:00:00.000+0000', 'dueDate': '2021-01-12T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T06:32:19.000+0000', 'etag': 'w4hj21wf', 'deleted': 0, 'createdTime': '2021-01-13T06:32:19.000+0000', 'creator': 447666584, 'tags': [], 'kind': 'TEXT'}] ``` ![image](https://user-images.githubusercontent.com/56806733/104415494-f86ddd80-5526-11eb-8b84-75bf3886ba46.png) \"\"\" # Make sure the project exists if project != self . _client . inbox_id : obj = self . _client . get_by_fields ( id = project , search = 'projects' ) if not obj : raise ValueError ( f \"List Id ' { project } ' Does Not Exist\" ) # Get the list of tasks that share the project id tasks = self . _client . get_by_fields ( projectId = project , search = 'tasks' ) if isinstance ( tasks , dict ): return [ tasks ] else : return tasks","title":"get_from_project()"},{"location":"usage/tasks/#managers.tasks.TaskManager.make_subtask","text":"Makes the passed task(s) sub-tasks to the parent task. Important All of the tasks should already be created prior to using this method. Furthermore, the tasks should already be present in the same project as the parent task. Parameters: Name Type Description Default obj dict Single Sub-Task (dict) : The task object dictionary. Multiple Sub-Tasks (list) : A list of task object dictionaries. required parent str The ID of the task that will be the parent task. required Returns: Type Description dict Single Sub-Task (dict) : Created sub-task dictionary. Multiple Sub-Tasks (list) : List of created sub-task dictionaries. Exceptions: Type Description TypeError obj must be a dictionary or list of dictionaries. parent must be a string. ValueError If parent task doesn't exist. ValueError If obj does not share the same project as parent. RuntimeError If the creation was unsuccessful. Creating Sub-Tasks Single Sub-Task Creation Pass the task object that will be made a sub-task to the parent with the passed ID. # Lets make a task in our inbox named \"Read\" with a sub-task \"50 Pages\" read_task = client . task . create ( 'Read' ) pages_task = client . task . create ( '50 pages' ) now_subtask = client . task . make_subtask ( pages_task , read_task [ 'id' ]) Result The dictionary of the sub-task is returned. { 'id' : '5ffff4968f08af50b4654c6b' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 3298534883328 , 'title' : '50 pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:37:36.487+0000' , 'etag' : 'xv5cjzoz' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:36:54.751+0000' , 'creator' : 115781412 , 'parentId' : '5ffff4968f08af50b4654c62' , 'kind' : 'TEXT' } Before After Multiple Sub-Task Creation Pass all the tasks you want to make sub-tasks in a list. # Lets make a task in our inbox named \"Read\" with a sub-tasks \"50 Pages\", \"100 Pages\", and \"200 Pages\" read_task = client . task . create ( \"Read\" ) # Lets batch create our sub-tasks fifty_pages = client . task . builder ( '50 Pages' ) hundred_pages = client . task . builder ( '100 Pages' ) two_hundred_pages = client . task . builder ( '200 Pages' ) page_tasks = client . task . create ([ fifty_pages , hundred_pages , two_hundred_pages ]) # Make the page tasks sub-tasks to read_task subtasks = client . task . make_subtask ( page_tasks , read_task [ 'id' ]) Result A list of the sub-tasks is returned. [{ 'id' : '5ffff6348f082c11cc0da84d' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '50 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.032+0000' , 'etag' : 'avqm3u6o' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:48.858+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }, { 'id' : '5ffff6348f082c11cc0da84e' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '100 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.035+0000' , 'etag' : '6295mmmu' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:49.286+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }, { 'id' : '5ffff6348f082c11cc0da84f' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 5497558138880 , 'title' : '200 Pages' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-14T07:45:04.038+0000' , 'etag' : 'du59zwck' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:43:49.315+0000' , 'creator' : 567893575 , 'parentId' : '5ffff6348f082c11cc0da84a' , 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py @logged_in def make_subtask ( self , obj , parent : str ): \"\"\" Makes the passed task(s) sub-tasks to the parent task. !!! note \"Important\" All of the tasks should already be created prior to using this method. Furthermore, the tasks should already be present in the same project as the parent task. Arguments: obj (dict): **Single Sub-Task (dict)**: The task object dictionary. **Multiple Sub-Tasks (list)**: A list of task object dictionaries. parent (str): The ID of the task that will be the parent task. Returns: dict: **Single Sub-Task (dict)**: Created sub-task dictionary. **Multiple Sub-Tasks (list)**: List of created sub-task dictionaries. Raises: TypeError: `obj` must be a dictionary or list of dictionaries. `parent` must be a string. ValueError: If `parent` task doesn't exist. ValueError: If `obj` does not share the same project as parent. RuntimeError: If the creation was unsuccessful. !!! example \"Creating Sub-Tasks\" === \"Single Sub-Task Creation\" Pass the task object that will be made a sub-task to the parent with the passed ID. ```python # Lets make a task in our inbox named \"Read\" with a sub-task \"50 Pages\" read_task = client.task.create('Read') pages_task = client.task.create('50 pages') now_subtask = client.task.make_subtask(pages_task, read_task['id']) ``` ??? success \"Result\" The dictionary of the sub-task is returned. ```python {'id': '5ffff4968f08af50b4654c6b', 'projectId': 'inbox115781412', 'sortOrder': -3298534883328, 'title': '50 pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:37:36.487+0000', 'etag': 'xv5cjzoz', 'deleted': 0, 'createdTime': '2021-01-14T07:36:54.751+0000', 'creator': 115781412, 'parentId': '5ffff4968f08af50b4654c62', 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104558809-4272c400-55f8-11eb-8c55-e2f77c9d1ac8.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104558849-55859400-55f8-11eb-9692-c3e01aa73233.png) === \"Multiple Sub-Task Creation\" Pass all the tasks you want to make sub-tasks in a list. ```python # Lets make a task in our inbox named \"Read\" with a sub-tasks \"50 Pages\", \"100 Pages\", and \"200 Pages\" read_task = client.task.create(\"Read\") # Lets batch create our sub-tasks fifty_pages = client.task.builder('50 Pages') hundred_pages = client.task.builder('100 Pages') two_hundred_pages = client.task.builder('200 Pages') page_tasks = client.task.create([fifty_pages, hundred_pages, two_hundred_pages]) # Make the page tasks sub-tasks to read_task subtasks = client.task.make_subtask(page_tasks, read_task['id']) ``` ??? success \"Result\" A list of the sub-tasks is returned. ```python [{'id': '5ffff6348f082c11cc0da84d', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '50 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.032+0000', 'etag': 'avqm3u6o', 'deleted': 0, 'createdTime': '2021-01-14T07:43:48.858+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}, {'id': '5ffff6348f082c11cc0da84e', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '100 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.035+0000', 'etag': '6295mmmu', 'deleted': 0, 'createdTime': '2021-01-14T07:43:49.286+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}, {'id': '5ffff6348f082c11cc0da84f', 'projectId': 'inbox115781412', 'sortOrder': -5497558138880, 'title': '200 Pages', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-14T07:45:04.038+0000', 'etag': 'du59zwck', 'deleted': 0, 'createdTime': '2021-01-14T07:43:49.315+0000', 'creator': 567893575, 'parentId': '5ffff6348f082c11cc0da84a', 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104559418-36d3cd00-55f9-11eb-9004-177671a92474.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104559535-64207b00-55f9-11eb-84cf-ca4f989ea075.png) \"\"\" if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( 'obj must be a dictionary or list of dictionaries' ) if not isinstance ( parent , str ): raise TypeError ( 'parent must be a string' ) if isinstance ( obj , dict ): obj = [ obj ] parent_obj = self . _client . get_by_id ( search = 'tasks' , obj_id = parent ) if not parent_obj : raise ValueError ( \"Parent task must exist before creating sub-tasks\" ) ids = [] # Go through obj and if the projects are different make them the same as parent for o in obj : if o [ 'projectId' ] != parent_obj [ 'projectId' ]: raise ValueError ( \"All tasks must be in the same project as the parent\" ) ids . append ( o [ 'id' ]) subtasks = [] for i in ids : # Create the object dictionaries for setting the subtask temp = { 'parentId' : parent , 'projectId' : parent_obj [ 'projectId' ], 'taskId' : i } subtasks . append ( temp ) url = self . _client . BASE_URL + 'batch/taskParent' response = self . _client . http_post ( url , json = subtasks , cookies = self . _client . cookies ) self . _client . sync () # Find and return the updated child objects subtasks = [] for task_id in ids : subtasks . append ( self . _client . get_by_id ( task_id , search = 'tasks' )) if len ( subtasks ) == 1 : return subtasks [ 0 ] # Return just the dictionary object if its a single task else : return subtasks","title":"make_subtask()"},{"location":"usage/tasks/#managers.tasks.TaskManager.move","text":"Moves task(s) from their current project to the new project. It will move the specified tasks with obj to the new project. Important If moving multiple tasks, they must all be from the same project. Parameters: Name Type Description Default obj dict or list Single Task (dict) : Pass the single task dictionary object to move. Multiple Tasks (list) : Pass a list of task dictionary objects to move. required new str The ID string of the project that the task(s) should be moved to. required Returns: Type Description dict or list Single Task (dict) : Returns the dictionary of the moved task. Multiple Tasks (list) : Returns a list of dictionaries for the moved tasks. Exceptions: Type Description TypeError If obj is not a dict or list or if new is not a str. ValueError For multiple tasks, if the projects are not all the same. ValueError If the new project does not exist. RuntimeError If the task(s) could not be successfully moved. Move Examples Moving A Single Task Pass in the task object, and the ID of the project the task should be moved to. # Lets assume that we have a task 'Read' that exists in a project named \"Work\" # Lets move that task to the inbox read_task = client . get_by_fields ( title = 'Read' , search = 'tasks' ) move_read_task = client . task . move ( read_task , client . inbox_id ) Result The dictionary object of the moved task is returned. { 'id' : '5fffed61b04b355792c799a8' , 'projectId' : 'inbox115781412' , 'sortOrder' : 0 , 'title' : 'Read' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:08:15.875+0000' , 'etag' : 'twrmcr55' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:06:09.000+0000' , 'creator' : 47593756 , 'tags' : [], 'kind' : 'TEXT' } Before After Moving Multiple Tasks Pass in the task objects in a list, and the ID of the project that tasks should be moved to. Again, the tasks in the list should all be from the same project. # Lets move two tasks: 'Read' and 'Write' that exist in a project named \"Work\" # Lets move the tasks to another project named \"Hobbies\" that already exists. hobbies_project = client . get_by_fields ( name = 'Hobbies' , search = 'projects' ) hobbies_id = hobbies_project [ 'id' ] # Id of the hobbies project read_task = client . get_by_fields ( title = 'Read' , search = 'tasks' ) write_task = client . get_by_fields ( title = 'Write' , search = 'tasks' ) move_tasks = client . task . move ([ read_task , write_task ], hobbies_id ) # Task objects in a list Result The tasks that were moved are returned in a list. [{ 'id' : '5ffff003b04b355792c799d3' , 'projectId' : '5fffeff68f08654c982c141a' , 'sortOrder' : 0 , 'title' : 'Read' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:19:28.595+0000' , 'etag' : 'co8jfqyn' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:17:23.000+0000' , 'creator' : 768495743 , 'kind' : 'TEXT' }, { 'id' : '5ffff004b04b355792c799d4' , 'projectId' : '5fffeff68f08654c982c141a' , 'sortOrder' : 0 , 'title' : 'Write' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-14T07:19:28.596+0000' , 'etag' : '5unkf7xg' , 'deleted' : 0 , 'createdTime' : '2021-01-14T07:17:24.000+0000' , 'creator' : 768495743 , 'tags' : [], 'kind' : 'TEXT' }] Before After Source code in managers/tasks.py @logged_in def move ( self , obj , new : str ): \"\"\" Moves task(s) from their current project to the new project. It will move the specified tasks with `obj` to the new project. !!! important If moving multiple tasks, they must all be from the same project. Arguments: obj (dict or list): **Single Task (dict)**: Pass the single task dictionary object to move. **Multiple Tasks (list)**: Pass a list of task dictionary objects to move. new: The ID string of the project that the task(s) should be moved to. Returns: dict or list: **Single Task (dict)**: Returns the dictionary of the moved task. **Multiple Tasks (list)**: Returns a list of dictionaries for the moved tasks. Raises: TypeError: If `obj` is not a dict or list or if `new` is not a str. ValueError: For multiple tasks, if the projects are not all the same. ValueError: If the new project does not exist. RuntimeError: If the task(s) could not be successfully moved. !!! example \"Move Examples\" === \"Moving A Single Task\" Pass in the task object, and the ID of the project the task should be moved to. ```python # Lets assume that we have a task 'Read' that exists in a project named \"Work\" # Lets move that task to the inbox read_task = client.get_by_fields(title='Read', search='tasks') move_read_task = client.task.move(read_task, client.inbox_id) ``` ??? success \"Result\" The dictionary object of the moved task is returned. ```python {'id': '5fffed61b04b355792c799a8', 'projectId': 'inbox115781412', 'sortOrder': 0, 'title': 'Read', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:08:15.875+0000', 'etag': 'twrmcr55', 'deleted': 0, 'createdTime': '2021-01-14T07:06:09.000+0000', 'creator': 47593756, 'tags': [], 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104556170-f1f96780-55f3-11eb-9a35-aecc3beea105.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104556336-46044c00-55f4-11eb-98c1-4cffcf4bd006.png) === \"Moving Multiple Tasks\" Pass in the task objects in a list, and the ID of the project that tasks should be moved to. Again, the tasks in the list should all be from the same project. ```python # Lets move two tasks: 'Read' and 'Write' that exist in a project named \"Work\" # Lets move the tasks to another project named \"Hobbies\" that already exists. hobbies_project = client.get_by_fields(name='Hobbies', search='projects') hobbies_id = hobbies_project['id'] # Id of the hobbies project read_task = client.get_by_fields(title='Read', search='tasks') write_task = client.get_by_fields(title='Write', search='tasks') move_tasks = client.task.move([read_task, write_task], hobbies_id) # Task objects in a list ``` ??? success \"Result\" The tasks that were moved are returned in a list. ```python [{'id': '5ffff003b04b355792c799d3', 'projectId': '5fffeff68f08654c982c141a', 'sortOrder': 0, 'title': 'Read', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:19:28.595+0000', 'etag': 'co8jfqyn', 'deleted': 0, 'createdTime': '2021-01-14T07:17:23.000+0000', 'creator': 768495743, 'kind': 'TEXT'}, {'id': '5ffff004b04b355792c799d4', 'projectId': '5fffeff68f08654c982c141a', 'sortOrder': 0, 'title': 'Write', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-14T07:19:28.596+0000', 'etag': '5unkf7xg', 'deleted': 0, 'createdTime': '2021-01-14T07:17:24.000+0000', 'creator': 768495743, 'tags': [], 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104557103-857f6800-55f5-11eb-8b92-cf51bc159745.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104557388-063e6400-55f6-11eb-8ba4-aa64f3f739bd.png) \"\"\" # Type errors if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( 'obj should be a dict or list of dicts' ) if not isinstance ( new , str ): raise TypeError ( 'new should be a string' ) # Get the parent project if new != self . _client . inbox_id : project = self . _client . get_by_id ( new , search = 'projects' ) if not project : raise ValueError ( 'The ID for the new project does not exist' ) if isinstance ( obj , dict ): obj = [ obj ] # Go through and check that the projects are all the same move_tasks = [] project_id = obj [ 0 ][ 'projectId' ] for task in obj : if task [ 'projectId' ] != project_id : raise ValueError ( 'All the tasks must come from the same project' ) else : move_tasks . append ({ 'fromProjectId' : project_id , 'taskId' : task [ 'id' ], 'toProjectId' : new }) url = self . _client . BASE_URL + 'batch/taskProject' self . _client . http_post ( url , json = move_tasks , cookies = self . _client . cookies ) self . _client . sync () # Return the tasks in the new list ids = [ x [ 'id' ] for x in obj ] return_list = [] for i in ids : return_list . append ( self . _client . get_by_id ( i )) if len ( return_list ) == 1 : return return_list [ 0 ] else : return return_list","title":"move()"},{"location":"usage/tasks/#managers.tasks.TaskManager.move_all","text":"Moves all the tasks from the old project to the new project. Parameters: Name Type Description Default old str ID of the old project. required new str ID of the new project. required Returns: Type Description list The tasks contained in the new project. Exceptions: Type Description ValueError If either the old or new projects do not exist. RuntimeError If the movement was unsuccessful. Example Lets assume that we have a project named \"School\", and another project named \"Work\". To move all the tasks from \"School\" to \"Work\": # Get the projects school_project = client . get_by_fields ( name = 'School' , search = 'projects' ) work_project = client . get_by_fields ( name = 'Work' , search = 'projects' ) # Call the method moved_tasks = client . task . move_projects ( school_project [ 'id' ], work_project [ 'id' ]) Result The tasks that were moved are returned. [{ 'id' : '5ffea9afe4b062d60dd62aef' , 'projectId' : '5ffea9afe4b062d60dd62aea' , 'sortOrder' : 0 , 'title' : 'Finish documentation for project' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:06:31.407+0000' , 'etag' : 'ogclghmd' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:05:03.901+0000' , 'creator' : 447666584 , 'kind' : 'TEXT' }, { 'id' : '5ffea9b0e4b062d60dd62af4' , 'projectId' : '5ffea9afe4b062d60dd62aea' , 'sortOrder' : 0 , 'title' : 'Call the boss man' , 'content' : '' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'reminder' : '' , 'reminders' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'modifiedTime' : '2021-01-13T08:06:31.409+0000' , 'etag' : '65c73q8i' , 'deleted' : 0 , 'createdTime' : '2021-01-13T08:05:04.117+0000' , 'creator' : 447666584 , 'kind' : 'TEXT' }] Before : Two tasks are contained in the \"School\" project After : The two tasks are moved to the 'Work' project Source code in managers/tasks.py @logged_in def move_all ( self , old : str , new : str ) -> list : \"\"\" Moves all the tasks from the old project to the new project. Arguments: old: ID of the old project. new: ID of the new project. Returns: The tasks contained in the new project. Raises: ValueError: If either the old or new projects do not exist. RuntimeError: If the movement was unsuccessful. !!! example Lets assume that we have a project named \"School\", and another project named \"Work\". To move all the tasks from \"School\" to \"Work\": ```python # Get the projects school_project = client.get_by_fields(name='School', search='projects') work_project = client.get_by_fields(name='Work', search='projects') # Call the method moved_tasks = client.task.move_projects(school_project['id'], work_project['id']) ``` ??? success \"Result\" The tasks that were moved are returned. ```python [{'id': '5ffea9afe4b062d60dd62aef', 'projectId': '5ffea9afe4b062d60dd62aea', 'sortOrder': 0, 'title': 'Finish documentation for project', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:06:31.407+0000', 'etag': 'ogclghmd', 'deleted': 0, 'createdTime': '2021-01-13T08:05:03.901+0000', 'creator': 447666584, 'kind': 'TEXT'}, {'id': '5ffea9b0e4b062d60dd62af4', 'projectId': '5ffea9afe4b062d60dd62aea', 'sortOrder': 0, 'title': 'Call the boss man', 'content': '', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'reminder': '', 'reminders': [], 'priority': 0, 'status': 0, 'items': [], 'modifiedTime': '2021-01-13T08:06:31.409+0000', 'etag': '65c73q8i', 'deleted': 0, 'createdTime': '2021-01-13T08:05:04.117+0000', 'creator': 447666584, 'kind': 'TEXT'}] ``` **Before**: Two tasks are contained in the \"School\" project ![image](https://user-images.githubusercontent.com/56806733/104423574-1e997a80-5533-11eb-9417-34c31e603d21.png) **After**: The two tasks are moved to the 'Work' project ![image](https://user-images.githubusercontent.com/56806733/104423710-4a1c6500-5533-11eb-90f3-2c3d024280af.png) \"\"\" # Make sure that old and new id's exist if old != self . _client . inbox_id : old_list = self . _client . get_by_fields ( id = old , search = 'projects' ) if not old_list : raise ValueError ( f \"Project Id ' { old } ' Does Not Exist\" ) if new != self . _client . inbox_id : new_list = self . _client . get_by_fields ( id = new , search = 'projects' ) if not new_list : raise ValueError ( f \"Project Id ' { new } ' Does Not Exist\" ) # Get the tasks from the old list tasks = self . get_from_project ( old ) if not tasks : return tasks # No tasks to move so just return the empty list task_project = [] # List containing all the tasks that will be updated for task in tasks : task_project . append ({ 'fromProjectId' : old , 'taskId' : task [ 'id' ], 'toProjectId' : new }) url = self . _client . BASE_URL + 'batch/taskProject' url2 = self . _client . BASE_URL + 'batch/task' # Make the initial call to move the tasks self . _client . http_post ( url , json = task_project , cookies = self . _client . cookies ) self . _client . sync () # Return the tasks in the new list return self . _client . task . get_from_project ( new )","title":"move_all()"},{"location":"usage/tasks/#managers.tasks.TaskManager.update","text":"Updates task(s) remotely. Supports single task update and batch task update. To update a task, change any field in it's dictionary directly then pass to the method. For Help On What Fields Are Present In The Task Dictionaries Example TickTick Task Dictionary Parameters: Name Type Description Default obj dict or list Single Task (dict) : The changed task dictionary object. Multiple Tasks (list) : The changed task dictionary objects in a list. required Returns: Type Description dict or list Single Task (dict) : The updated task dictionary object. Multiple Tasks (list) : The updated task dictionary objects in a list. Exceptions: Type Description TypeError If obj is not a dictionary or list. RuntimeError If the updating was unsuccessful. Formatting Dates Help TickTick uses a certain syntax for their dates. To convert a datetime object to a compatible string to be used for updating dates, see convert_date_to_tick_tick_format Updating Tasks Single Task Update Updating a single task requires changing the task dictionary directly, and then passing the entire object to update . # Lets say we have a task named \"Hang out with Jon\" that we want to rename to \"Call Jon\" jon_task = client . get_by_fields ( title = 'Hang out with Jon' , search = 'tasks' ) # Change the field directly jon_task [ 'title' ] = 'Call Jon' # Pass the entire object to update. updated_jon_task = client . task . update ( jon_task ) Result The updated task dictionary is returned. { 'id' : '5fff566fb04b355792c79417' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 101429947662336 , 'title' : 'Call Jon' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T20:22:07.000+0000' , 'etag' : '5qiug0q2' , 'deleted' : 0 , 'createdTime' : '2021-01-13T20:22:07.000+0000' , 'creator' : 759365027 , 'kind' : 'TEXT' } Before After Multiple Task Update Updating multiple tasks requires changing the task dictionaries directly, and then passing the dictionaries in a list to update . # Lets say we have a task named \"Hang out with Jon\" that we want to rename to \"Call Jon\" jon_task = client . get_by_fields ( title = 'Hang out with Jon' , search = 'tasks' ) # Change the field directly jon_task [ 'title' ] = 'Call Jon' # Lets say we have another task named \"Read Book\" that we want to change the progress to 70%. book_task = client . get_by_fields ( title = 'Read Book' , search = 'tasks' ) # Change the field directly book_task [ 'progress' ] = 70 # Create a list of the objects and pass to update update_tasks = [ jon_task , book_task ] updated = client . task . update ( update_tasks ) Result The updated task dictionaries are returned in a list. [{ 'id' : '5fff566fb04b355792c79417' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 101429947662336 , 'title' : 'Call Jon' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 0 , 'modifiedTime' : '2021-01-13T20:29:56.000+0000' , 'etag' : 'nxahco6u' , 'deleted' : 0 , 'createdTime' : '2021-01-13T20:22:07.000+0000' , 'creator' : 557493756 , 'kind' : 'TEXT' }, { 'id' : '5fff584db04b355792c79430' , 'projectId' : 'inbox115781412' , 'sortOrder' : - 102529459290112 , 'title' : 'Read Book' , 'content' : '' , 'startDate' : '2021-01-13T08:00:00.000+0000' , 'dueDate' : '2021-01-13T08:00:00.000+0000' , 'timeZone' : 'America/Los_Angeles' , 'isFloating' : False , 'isAllDay' : True , 'reminders' : [], 'exDate' : [], 'priority' : 0 , 'status' : 0 , 'items' : [], 'progress' : 70 , 'modifiedTime' : '2021-01-13T20:30:05.000+0000' , 'etag' : 'hdz5rbcj' , 'deleted' : 0 , 'createdTime' : '2021-01-13T20:30:05.000+0000' , 'creator' : 557493756 , 'kind' : 'TEXT' }] Before After Notice the progress icon located near the date now for \"Read Book\" Source code in managers/tasks.py @logged_in def update ( self , obj ): \"\"\" Updates task(s) remotely. Supports single task update and batch task update. To update a task, change any field in it's dictionary directly then pass to the method. !!! tip \"For Help On What Fields Are Present In The Task Dictionaries\" [Example `TickTick` Task Dictionary](tasks.md#example-ticktick-task-dictionary) Arguments: obj (dict or list): **Single Task (dict)**: The changed task dictionary object. **Multiple Tasks (list)**: The changed task dictionary objects in a list. Returns: dict or list: **Single Task (dict)**: The updated task dictionary object. **Multiple Tasks (list)**: The updated task dictionary objects in a list. Raises: TypeError: If `obj` is not a dictionary or list. RuntimeError: If the updating was unsuccessful. !!! tip \"Formatting Dates Help\" TickTick uses a certain syntax for their dates. To convert a datetime object to a compatible string to be used for updating dates, see [convert_date_to_tick_tick_format][helpers.time_methods.convert_date_to_tick_tick_format] !!! example \"Updating Tasks\" === \"Single Task Update\" Updating a single task requires changing the task dictionary directly, and then passing the entire object to `update`. ```python # Lets say we have a task named \"Hang out with Jon\" that we want to rename to \"Call Jon\" jon_task = client.get_by_fields(title='Hang out with Jon', search='tasks') # Change the field directly jon_task['title'] = 'Call Jon' # Pass the entire object to update. updated_jon_task = client.task.update(jon_task) ``` ??? success \"Result\" The updated task dictionary is returned. ```python {'id': '5fff566fb04b355792c79417', 'projectId': 'inbox115781412', 'sortOrder': -101429947662336, 'title': 'Call Jon', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T20:22:07.000+0000', 'etag': '5qiug0q2', 'deleted': 0, 'createdTime': '2021-01-13T20:22:07.000+0000', 'creator': 759365027, 'kind': 'TEXT'} ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104506247-f8f38c00-5599-11eb-9f8e-c4bbb256cf03.png) **After** ![image](https://user-images.githubusercontent.com/56806733/104506300-0e68b600-559a-11eb-952d-ac5d189535b4.png) === \"Multiple Task Update\" Updating multiple tasks requires changing the task dictionaries directly, and then passing the dictionaries in a list to `update`. ```python # Lets say we have a task named \"Hang out with Jon\" that we want to rename to \"Call Jon\" jon_task = client.get_by_fields(title='Hang out with Jon', search='tasks') # Change the field directly jon_task['title'] = 'Call Jon' # Lets say we have another task named \"Read Book\" that we want to change the progress to 70%. book_task = client.get_by_fields(title='Read Book', search='tasks') # Change the field directly book_task['progress'] = 70 # Create a list of the objects and pass to update update_tasks = [jon_task, book_task] updated = client.task.update(update_tasks) ``` ??? success \"Result\" The updated task dictionaries are returned in a list. ```python [{'id': '5fff566fb04b355792c79417', 'projectId': 'inbox115781412', 'sortOrder': -101429947662336, 'title': 'Call Jon', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 0, 'modifiedTime': '2021-01-13T20:29:56.000+0000', 'etag': 'nxahco6u', 'deleted': 0, 'createdTime': '2021-01-13T20:22:07.000+0000', 'creator': 557493756, 'kind': 'TEXT'}, {'id': '5fff584db04b355792c79430', 'projectId': 'inbox115781412', 'sortOrder': -102529459290112, 'title': 'Read Book', 'content': '', 'startDate': '2021-01-13T08:00:00.000+0000', 'dueDate': '2021-01-13T08:00:00.000+0000', 'timeZone': 'America/Los_Angeles', 'isFloating': False, 'isAllDay': True, 'reminders': [], 'exDate': [], 'priority': 0, 'status': 0, 'items': [], 'progress': 70, 'modifiedTime': '2021-01-13T20:30:05.000+0000', 'etag': 'hdz5rbcj', 'deleted': 0, 'createdTime': '2021-01-13T20:30:05.000+0000', 'creator': 557493756, 'kind': 'TEXT'}] ``` **Before** ![image](https://user-images.githubusercontent.com/56806733/104507072-15dc8f00-559b-11eb-9253-3629e1abc668.png) **After** Notice the progress icon located near the date now for \"Read Book\" ![image](https://user-images.githubusercontent.com/56806733/104507219-4ae8e180-559b-11eb-99bf-f0a018c4ae5c.png) \"\"\" if not isinstance ( obj , dict ) and not isinstance ( obj , list ): raise TypeError ( \"Task Objects Must Be A Dictionary or List of Dictionaries.\" ) if isinstance ( obj , dict ): tasks = [ obj ] else : tasks = obj url = self . _client . BASE_URL + 'batch/task' payload = { 'update' : tasks } response = self . _client . http_post ( url , json = payload , cookies = self . _client . cookies ) self . _client . sync () if len ( tasks ) == 1 : return self . _client . get_by_id ( self . _client . parse_id ( response ), search = 'tasks' ) else : etag = response [ 'id2etag' ] etag2 = list ( etag . keys ()) # Tag names are out of order labels = [ x [ 'id' ] for x in tasks ] # Tag names are in order items = [ '' ] * len ( tasks ) # Create enough spots for the objects for tag in etag2 : index = labels . index ( tag ) # Object of the index is here found = self . _client . get_by_id ( labels [ index ], search = 'tasks' ) items [ index ] = found # Place at the correct index return items","title":"update()"}]}